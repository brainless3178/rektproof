{
  "timestamp": "2026-02-18T18:06:23",
  "scanner_version": "0.1.0",
  "programs_scanned": 20,
  "metrics": {
    "overall": {
      "total_findings": 47,
      "true_positives": 25,
      "false_positives": 2,
      "informational": 20,
      "precision": 92.6,
      "recall": 100.0,
      "f1_score": 96.2,
      "static_exploited_tested": 2,
      "static_exploited_detected": 2,
      "semantic_exploited_tested": 1,
      "semantic_exploited_flagged": 1
    },
    "per_detector": {
      "SOL-001": {
        "total_firings": 2,
        "true_positives": 2,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-004": {
        "total_firings": 4,
        "true_positives": 0,
        "false_positives": 1,
        "informational": 3,
        "precision_pct": 0.0
      },
      "SOL-010": {
        "total_firings": 1,
        "true_positives": 0,
        "false_positives": 0,
        "informational": 1,
        "precision_pct": 100.0
      },
      "SOL-012": {
        "total_firings": 1,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-014": {
        "total_firings": 3,
        "true_positives": 0,
        "false_positives": 1,
        "informational": 2,
        "precision_pct": 0.0
      },
      "SOL-017": {
        "total_firings": 2,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 1,
        "precision_pct": 100.0
      },
      "SOL-021": {
        "total_firings": 1,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-023": {
        "total_firings": 4,
        "true_positives": 4,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-031": {
        "total_firings": 2,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 1,
        "precision_pct": 100.0
      },
      "SOL-034": {
        "total_firings": 2,
        "true_positives": 2,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-038": {
        "total_firings": 1,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-046": {
        "total_firings": 2,
        "true_positives": 0,
        "false_positives": 0,
        "informational": 2,
        "precision_pct": 100.0
      },
      "SOL-049": {
        "total_firings": 1,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-056": {
        "total_firings": 1,
        "true_positives": 0,
        "false_positives": 0,
        "informational": 1,
        "precision_pct": 100.0
      },
      "SOL-058": {
        "total_firings": 2,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 1,
        "precision_pct": 100.0
      },
      "SOL-059": {
        "total_firings": 2,
        "true_positives": 2,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-061": {
        "total_firings": 2,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 1,
        "precision_pct": 100.0
      },
      "SOL-062": {
        "total_firings": 3,
        "true_positives": 0,
        "false_positives": 0,
        "informational": 3,
        "precision_pct": 100.0
      },
      "SOL-063": {
        "total_firings": 1,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-065": {
        "total_firings": 1,
        "true_positives": 0,
        "false_positives": 0,
        "informational": 1,
        "precision_pct": 100.0
      },
      "SOL-068": {
        "total_firings": 5,
        "true_positives": 2,
        "false_positives": 0,
        "informational": 3,
        "precision_pct": 100.0
      },
      "SOL-076": {
        "total_firings": 1,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-ALIAS-02": {
        "total_firings": 2,
        "true_positives": 2,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      },
      "SOL-ALIAS-05": {
        "total_firings": 1,
        "true_positives": 1,
        "false_positives": 0,
        "informational": 0,
        "precision_pct": 100.0
      }
    }
  },
  "results": [
    {
      "program": "Cashio (brrr)",
      "category": "EXPLOITED",
      "path": "./real_exploits/cashio/programs/brrr/src",
      "exploit_type": "Missing account validation \u2014 fake collateral accepted",
      "loss": "$52M",
      "expected_detections": [
        "SOL-001",
        "SOL-012"
      ],
      "total_findings": 4,
      "findings": [
        {
          "category": "Authentication",
          "vuln_type": "Missing Signer Check",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-001",
          "cwe": "CWE-287",
          "location": "lib.rs",
          "function_name": "print_cash",
          "line_number": 39,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: PrintCash */\n#[doc = \" Accounts for printing $CASH.\"] #[derive (Accounts)] pub struct PrintCash < 'info> { #[doc = \" Common accounts.\"] pub common : BrrrCommon < 'info> , #[doc = \" The depositor into the pool.\"] #[account (mut)] pub depositor : Signer<'info> , #[doc = \" The source of the deposited [Collateral] tokens.\"] #[account (mut)] pub depositor_source : Box<Account<'info, TokenAccount > > , #[doc = \" Destination of the issued $CASH.\"] #[account (mut)] pub mint_destination : Box<Account<'info, TokenAccount > > , #[doc = \" The [ISSUE_AUTHORITY_ADDRESS].\"] #[doc = \" CHECK: this is handled by Vipers.\"] pub issue_authority : UncheckedAccount<'info> , }\n/* HANDLER: */\n#[doc = \" Prints $CASH.\"] #[doc = \"\"] #[doc = \" $CASH can be printed by depositing Saber LP tokens.\"] #[doc = \" The amount of $CASH created is based on the virtual price of the\"] #[doc = \" Saber LP token; for example, if one deposits 1 USDC-USDT LP\"] #[doc = \" but that LP's virtual price is 1.02, one will receive 1.02 $CASH\"] #[doc = \" for each 1 USDC-USDT LP deposited.\"] #[access_control (ctx . accounts . validate ())] pub fn print_cash (ctx : Context<PrintCash > , deposit_amount : u64) -> Result<() > { vipers :: invariant ! (false , \"temporarily disabled\") ; actions :: print_cash :: print_cash (ctx , deposit_amount) }",
          "description": "An authority/admin/owner account is passed as raw `AccountInfo<'info>` without enforcing `is_signer`. The Solana runtime will NOT check this \u2014 any pubkey can be passed, allowing anyone to impersonate the privileged role. Use `Signer<'info>` or add `#[account(signer)]` to enforce the runtime check.",
          "attack_scenario": "Attacker constructs a transaction passing their own pubkey as the `authority` AccountInfo. Since there is no `Signer<'info>` constraint or `require!(authority.is_signer)` guard, the runtime accepts the instruction. The attacker then executes privileged operations (withdraw, set_authority, etc.) as if they were the real authority.",
          "real_world_incident": {
            "project": "Wormhole",
            "loss": "$320M",
            "date": "2022-02-02"
          },
          "secure_fix": "Replace `pub authority: AccountInfo<'info>` with `pub authority: Signer<'info>`, or add `#[account(signer)]`. For Anchor programs, also add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the account being protected.",
          "prevention": "Never use raw AccountInfo for accounts that must be signers. Always use Signer<'info> for authority/admin/owner accounts in Anchor.",
          "confidence": 80
        },
        {
          "category": "Account Validation",
          "vuln_type": "Account Data Mismatch",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-012",
          "cwe": "CWE-20",
          "location": "lib.rs",
          "function_name": "print_cash",
          "line_number": 39,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: PrintCash */\n#[doc = \" Accounts for printing $CASH.\"] #[derive (Accounts)] pub struct PrintCash < 'info> { #[doc = \" Common accounts.\"] pub common : BrrrCommon < 'info> , #[doc = \" The depositor into the pool.\"] #[account (mut)] pub depositor : Signer<'info> , #[doc = \" The source of the deposited [Collateral] tokens.\"] #[account (mut)] pub depositor_source : Box<Account<'info, TokenAccount > > , #[doc = \" Destination of the issued $CASH.\"] #[account (mut)] pub mint_destination : Box<Account<'info, TokenAccount > > , #[doc = \" The [ISSUE_AUTHORITY_ADDRESS].\"] #[doc = \" CHECK: this is handled by Vipers.\"] pub issue_authority : UncheckedAccount<'info> , }\n/* HANDLER: */\n#[doc = \" Prints $CASH.\"] #[doc = \"\"] #[doc = \" $CASH can be printed by depositing Saber LP tokens.\"] #[doc = \" The amount of $CASH created is based on the virtual price of the\"] #[doc = \" Saber LP token; for example, if one deposits 1 USDC-USDT LP\"] #[doc = \" but that LP's virtual price is 1.02, one will receive 1.02 $CASH\"] #[doc = \" for each 1 USDC-USDT LP deposited.\"] #[access_control (ctx . accounts . validate ())] pub fn print_cash (ctx : Context<PrintCash > , deposit_amount : u64) -> Result<() > { vipers :: invariant ! (false , \"temporarily disabled\") ; actions :: print_cash :: print_cash (ctx , deposit_amount) }",
          "description": "An instruction takes both a state account (vault/pool) and an authority/user account, but does not validate their relationship. Without `has_one = authority` or an equivalent constraint, an attacker can pass any vault with any authority \u2014 even one they control \u2014 to access someone else's funds.",
          "attack_scenario": "Instruction takes `vault: Account<Vault>` and `authority: Signer`. Attacker creates their own vault where they are the authority. Passes their vault + their signer to an instruction that reads from a different token account (passed separately). The program verifies `authority == vault.authority` (both attacker-controlled), then processes the operation on the victim's token account.",
          "real_world_incident": null,
          "secure_fix": "Add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the vault/pool account to ensure the signer matches the stored authority.",
          "prevention": "Always validate relationships between accounts using `has_one` or `constraint`. Every state account that references an authority must be validated against the actual signer.",
          "confidence": 65
        },
        {
          "category": "Logic Security",
          "vuln_type": "Missing State Machine",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-059",
          "cwe": "CWE-841",
          "location": "lib.rs",
          "function_name": "burn_cash",
          "line_number": 50,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: BurnCash */\n#[doc = \" Accounts for burning $CASH.\"] #[derive (Accounts)] pub struct BurnCash < 'info> { #[doc = \" Common accounts.\"] pub common : BrrrCommon < 'info> , #[doc = \" The depositor into the pool.\"] #[account (mut)] pub burner : Signer<'info> , #[doc = \" The source of the burned $CASH.\"] #[account (mut)] pub burned_cash_source : Box<Account<'info, TokenAccount > > , #[doc = \" Destination of the issued tokens.\"] #[account (mut)] pub withdraw_destination : Box<Account<'info, TokenAccount > > , #[doc = \" Author fee token destination\"] #[account (mut)] pub author_fee_destination : Account<'info, TokenAccount > , #[doc = \" Protocol fee token destination\"] #[account (mut)] pub protocol_fee_destination : Account<'info, TokenAccount > , #[doc = \" The [WITHDRAW_AUTHORITY_ADDRESS].\"] #[doc = \" CHECK: this is handled by Vipers.\"] pub withdraw_authority : UncheckedAccount<'info> , }\n/* HANDLER: */\n#[doc = \" Burns $CASH.\"] #[doc = \"\"] #[doc = \" $CASH may be burned for any of the underlying LP tokens.\"] #[doc = \" This means that $CASHs's underlying value is the value of its cheapest (\\\"floor\\\")\"] #[doc = \" LP token, minus the burn fee.\"] #[access_control (ctx . accounts . validate ())] pub fn burn_cash (ctx : Context<BurnCash > , burn_amount : u64) -> Result<() > { vipers :: invariant ! (false , \"temporarily disabled\") ; actions :: burn_cash :: burn_cash (ctx , burn_amount) }",
          "description": "Multi-step instruction flow (init\u2192deposit\u2192finalize) lacks a state machine to enforce ordering. Instructions can be called out-of-order, skipping required preconditions.",
          "attack_scenario": "Protocol has init\u2192deposit\u2192finalize flow. Attacker calls finalize directly without depositing, claiming rewards without providing collateral.",
          "real_world_incident": null,
          "secure_fix": "Add an enum State { Initialized, Active, Finalized } and validate transitions: `require!(account.state == State::Active)`.",
          "prevention": "All multi-step processes need explicit state tracking with validated transitions.",
          "confidence": 65
        },
        {
          "category": "Token Security",
          "vuln_type": "Unvalidated Freeze Authority",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-068",
          "cwe": "CWE-732",
          "location": "lib.rs",
          "function_name": "print_cash",
          "line_number": 39,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: PrintCash */\n#[doc = \" Accounts for printing $CASH.\"] #[derive (Accounts)] pub struct PrintCash < 'info> { #[doc = \" Common accounts.\"] pub common : BrrrCommon < 'info> , #[doc = \" The depositor into the pool.\"] #[account (mut)] pub depositor : Signer<'info> , #[doc = \" The source of the deposited [Collateral] tokens.\"] #[account (mut)] pub depositor_source : Box<Account<'info, TokenAccount > > , #[doc = \" Destination of the issued $CASH.\"] #[account (mut)] pub mint_destination : Box<Account<'info, TokenAccount > > , #[doc = \" The [ISSUE_AUTHORITY_ADDRESS].\"] #[doc = \" CHECK: this is handled by Vipers.\"] pub issue_authority : UncheckedAccount<'info> , }\n/* HANDLER: */\n#[doc = \" Prints $CASH.\"] #[doc = \"\"] #[doc = \" $CASH can be printed by depositing Saber LP tokens.\"] #[doc = \" The amount of $CASH created is based on the virtual price of the\"] #[doc = \" Saber LP token; for example, if one deposits 1 USDC-USDT LP\"] #[doc = \" but that LP's virtual price is 1.02, one will receive 1.02 $CASH\"] #[doc = \" for each 1 USDC-USDT LP deposited.\"] #[access_control (ctx . accounts . validate ())] pub fn print_cash (ctx : Context<PrintCash > , deposit_amount : u64) -> Result<() > { vipers :: invariant ! (false , \"temporarily disabled\") ; actions :: print_cash :: print_cash (ctx , deposit_amount) }",
          "description": "DeFi protocol accepts token deposits without checking if the mint has a freeze authority. A freeze authority can freeze the protocol's token accounts, permanently locking user funds.",
          "attack_scenario": "Users deposit USDC into a lending pool. The token mint's freeze authority freezes the pool's token account. All deposits are permanently locked \u2014 users can never withdraw.",
          "real_world_incident": null,
          "secure_fix": "Check freeze authority: `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` or document the risk and implement contingency plans.",
          "prevention": "Audit accepted token mints for freeze authority. Warn users or reject tokens with active freeze authorities.",
          "confidence": 55
        }
      ]
    },
    {
      "program": "Wormhole Bridge",
      "category": "EXPLOITED",
      "path": "./real_exploits/wormhole/solana/bridge/program/src",
      "exploit_type": "Signature verification bypass (secp256k1 parsing)",
      "loss": "$320M",
      "expected_detections": [],
      "total_findings": 1,
      "findings": [
        {
          "category": "Input Validation",
          "vuln_type": "Unbounded Input Length",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-062",
          "cwe": "CWE-400",
          "location": "governance.rs",
          "function_name": "upgrade_contract",
          "line_number": 95,
          "vulnerable_code": "pub fn upgrade_contract (ctx : & ExecutionContext , accs : & mut UpgradeContract , _data : UpgradeContractData ,) -> Result<() > { verify_governance (& accs . vaa) ? ; claim :: consume (ctx , accs . payer . key , & mut accs . claim , & accs . vaa) ? ; let upgrade_ix = solana_program :: bpf_loader_upgradeable :: upgrade (ctx . program_id , & accs . vaa . new_contract , accs . upgrade_authority . key , accs . spill . key ,) ; let seeds = accs . upgrade_authority . self_bumped_seeds (None , ctx . program_id) ; let seeds : Vec<& [u8] > = seeds . iter () . map (| item | item . as_slice ()) . collect () ; let seeds = seeds . as_slice () ; invoke_signed (& upgrade_ix , ctx . accounts , & [seeds]) ? ; Ok (()) }",
          "description": "Instruction accepts Vec<> input without length bounds. An attacker can pass an extremely large array to consume all compute units or cause excessive memory allocation.",
          "attack_scenario": "Attacker passes a Vec with 10,000 elements. The instruction tries to iterate and runs out of compute units, DOS-ing the program.",
          "real_world_incident": null,
          "secure_fix": "Add length validation: `require!(items.len() <= MAX_ITEMS)`. Define reasonable constants for maximum array sizes.",
          "prevention": "Always validate collection lengths at instruction entry. Define MAX_* constants for all bounded collections.",
          "confidence": 58
        }
      ]
    },
    {
      "program": "Saber Stable-Swap",
      "category": "EXPLOITED",
      "path": "./real_exploits/saber/stable-swap-program/program/src",
      "exploit_type": "Admin key impersonation / authority validation gap",
      "loss": "Undisclosed",
      "expected_detections": [
        "SOL-068"
      ],
      "total_findings": 2,
      "findings": [
        {
          "category": "Token Security",
          "vuln_type": "Unvalidated Freeze Authority",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-068",
          "cwe": "CWE-732",
          "location": "admin.rs",
          "function_name": "set_fee_account",
          "line_number": 179,
          "vulnerable_code": "#[doc = \" Set fee account\"] fn set_fee_account < 'a , 'b : 'a , I : Iterator < Item = & 'a AccountInfo<'b > > > (token_swap : & mut SwapInfo , account_info_iter : & mut I ,) -> ProgramResult { let new_fee_account_info = next_account_info (account_info_iter) ? ; let new_admin_fee_account = utils :: unpack_token_account (& new_fee_account_info . data . borrow_mut ()) ? ; msg ! (\"Admin: New fee account owner {}\" , new_admin_fee_account . owner) ; if new_admin_fee_account . mint == token_swap . token_a . mint { msg ! (\"Admin: Old fee account A {}\" , token_swap . token_a . admin_fees) ; token_swap . token_a . admin_fees = * new_fee_account_info . key ; msg ! (\"Admin: Fee account A set to {}\" , token_swap . token_a . admin_fees) ; } else if new_admin_fee_account . mint == token_swap . token_b . mint { msg ! (\"Admin: Old fee account B {}\" , token_swap . token_b . admin_fees) ; token_swap . token_b . admin_fees = * new_fee_account_info . key ; msg ! (\"Admin: Fee account B set to {}\" , token_swap . token_b . admin_fees) ; } else { return Err (SwapError :: InvalidAdmin . into ()) ; } Ok (()) }",
          "description": "DeFi protocol accepts token deposits without checking if the mint has a freeze authority. A freeze authority can freeze the protocol's token accounts, permanently locking user funds.",
          "attack_scenario": "Users deposit USDC into a lending pool. The token mint's freeze authority freezes the pool's token account. All deposits are permanently locked \u2014 users can never withdraw.",
          "real_world_incident": null,
          "secure_fix": "Check freeze authority: `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` or document the risk and implement contingency plans.",
          "prevention": "Audit accepted token mints for freeze authority. Warn users or reject tokens with active freeze authorities.",
          "confidence": 56
        },
        {
          "category": "Token Security",
          "vuln_type": "Unvalidated Freeze Authority",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-068",
          "cwe": "CWE-732",
          "location": "token.rs",
          "function_name": "mint_to",
          "line_number": 27,
          "vulnerable_code": "#[doc = \" Issue a spl_token `MintTo` instruction.\"] pub fn mint_to < 'a > (swap : & Pubkey , token_program : AccountInfo<'a > , mint : AccountInfo<'a > , destination : AccountInfo<'a > , authority : AccountInfo<'a > , nonce : u8 , amount : u64 ,) -> Result<() , ProgramError > { let swap_bytes = swap . to_bytes () ; let authority_signature_seeds = [& swap_bytes [.. 32] , & [nonce]] ; let signers = & [& authority_signature_seeds [..]] ; let ix = spl_token :: instruction :: mint_to (token_program . key , mint . key , destination . key , authority . key , & [] , amount ,) ? ; invoke_signed (& ix , & [mint , destination , authority , token_program] , signers) }",
          "description": "DeFi protocol accepts token deposits without checking if the mint has a freeze authority. A freeze authority can freeze the protocol's token accounts, permanently locking user funds.",
          "attack_scenario": "Users deposit USDC into a lending pool. The token mint's freeze authority freezes the pool's token account. All deposits are permanently locked \u2014 users can never withdraw.",
          "real_world_incident": null,
          "secure_fix": "Check freeze authority: `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` or document the risk and implement contingency plans.",
          "prevention": "Audit accepted token mints for freeze authority. Warn users or reject tokens with active freeze authorities.",
          "confidence": 56
        }
      ]
    },
    {
      "program": "SPL Governance",
      "category": "CLEAN",
      "path": "./real_exploits/spl/governance/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 3,
      "findings": [
        {
          "category": "Resource Safety",
          "vuln_type": "Compute Unit Exhaustion with Partial State",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-061",
          "cwe": "CWE-400",
          "location": "process_execute_transaction.rs",
          "function_name": "process_execute_transaction",
          "line_number": 23,
          "vulnerable_code": "#[doc = \" Processes ExecuteTransaction instruction\"] pub fn process_execute_transaction (program_id : & Pubkey , accounts : & [AccountInfo]) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let governance_info = next_account_info (account_info_iter) ? ; let proposal_info = next_account_info (account_info_iter) ? ; let proposal_transaction_info = next_account_info (account_info_iter) ? ; let clock = Clock :: get () ? ; let governance_data = get_governance_data (program_id , governance_info) ? ; let mut proposal_data = get_proposal_data_for_governance (program_id , proposal_info , governance_info . key) ? ; let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal (program_id , proposal_transaction_info , proposal_info . key ,) ? ; proposal_data . assert_can_execute_transaction (& proposal_transaction_data , & governance_data . config , clock . unix_timestamp ,) ? ; let instructions = proposal_transaction_data . instructions . iter () . map (Instruction :: from) ; let instruction_account_infos = account_info_iter . as_slice () ; let mut signers_seeds : Vec<& [& [u8]] > = vec ! [] ; let mut governance_seeds = governance_data . get_governance_address_seeds () ? . to_vec () ; let (_ , bump_seed) = Pubkey :: find_program_address (& governance_seeds , program_id) ; let bump = & [bump_seed] ; governance_seeds . push (bump) ; signers_seeds . push (& governance_seeds [..]) ; let mut treasury_seeds = get_native_treasury_address_seeds (governance_info . key) . to_vec () ; let (treasury_address , treasury_bump_seed) = Pubkey :: find_program_address (& treasury_seeds , program_id) ; let treasury_bump = & [treasury_bump_seed] ; if instruction_account_infos . iter () . any (| a | a . key == & treasury_address) { treasury_seeds . push (treasury_bump) ; signers_seeds . push (& treasury_seeds [..]) ; } for instruction in instructions { invoke_signed (& instruction , instruction_account_infos , & signers_seeds [..]) ? ; } if proposal_data . state == ProposalState :: Succeeded { proposal_data . executing_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Executing ; } let option = & mut proposal_data . options [proposal_transaction_data . option_index as usize] ; option . transactions_executed_count = option . transactions_executed_count . checked_add (1) . unwrap () ; if (proposal_data . state == ProposalState :: Executing || proposal_data . state == ProposalState :: ExecutingWithErrors) && proposal_data . options . iter () . filter (| o | o . vote_result == OptionVoteResult :: Succeeded) . all (| o | o . transactions_executed_count == o . transactions_count) { proposal_data . closed_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Completed ; } proposal_data . serialize (& mut proposal_info . data . borrow_mut () [..]) ? ; proposal_transaction_data . executed_at = Some (clock . unix_timestamp) ; proposal_transaction_data . execution_status = TransactionExecutionStatus :: Success ; proposal_transaction_data . serialize (& mut proposal_transaction_info . data . borrow_mut () [..]) ? ; Ok (()) }",
          "description": "Loop processes items while mutating state. If compute units run out mid-loop, the transaction fails but on-chain state may be partially updated (Solana does NOT roll back on CU exhaustion in inner instructions).",
          "attack_scenario": "Attacker provides a large input array. The loop processes 10 of 100 items before CU exhaustion. Those 10 state changes persist, creating an inconsistent state that can be exploited in subsequent transactions.",
          "real_world_incident": null,
          "secure_fix": "Add CU consumption checks in loops, or use pagination/cranking patterns. Process items in fixed-size batches.",
          "prevention": "Bound loop iterations. Use pagination for large datasets. Check remaining CU budget with `sol_remaining_compute_units()`.",
          "confidence": 69
        },
        {
          "category": "Time Safety",
          "vuln_type": "Time Manipulation Risk",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-046",
          "cwe": "CWE-367",
          "location": "process_execute_transaction.rs",
          "function_name": "process_execute_transaction",
          "line_number": 23,
          "vulnerable_code": "#[doc = \" Processes ExecuteTransaction instruction\"] pub fn process_execute_transaction (program_id : & Pubkey , accounts : & [AccountInfo]) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let governance_info = next_account_info (account_info_iter) ? ; let proposal_info = next_account_info (account_info_iter) ? ; let proposal_transaction_info = next_account_info (account_info_iter) ? ; let clock = Clock :: get () ? ; let governance_data = get_governance_data (program_id , governance_info) ? ; let mut proposal_data = get_proposal_data_for_governance (program_id , proposal_info , governance_info . key) ? ; let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal (program_id , proposal_transaction_info , proposal_info . key ,) ? ; proposal_data . assert_can_execute_transaction (& proposal_transaction_data , & governance_data . config , clock . unix_timestamp ,) ? ; let instructions = proposal_transaction_data . instructions . iter () . map (Instruction :: from) ; let instruction_account_infos = account_info_iter . as_slice () ; let mut signers_seeds : Vec<& [& [u8]] > = vec ! [] ; let mut governance_seeds = governance_data . get_governance_address_seeds () ? . to_vec () ; let (_ , bump_seed) = Pubkey :: find_program_address (& governance_seeds , program_id) ; let bump = & [bump_seed] ; governance_seeds . push (bump) ; signers_seeds . push (& governance_seeds [..]) ; let mut treasury_seeds = get_native_treasury_address_seeds (governance_info . key) . to_vec () ; let (treasury_address , treasury_bump_seed) = Pubkey :: find_program_address (& treasury_seeds , program_id) ; let treasury_bump = & [treasury_bump_seed] ; if instruction_account_infos . iter () . any (| a | a . key == & treasury_address) { treasury_seeds . push (treasury_bump) ; signers_seeds . push (& treasury_seeds [..]) ; } for instruction in instructions { invoke_signed (& instruction , instruction_account_infos , & signers_seeds [..]) ? ; } if proposal_data . state == ProposalState :: Succeeded { proposal_data . executing_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Executing ; } let option = & mut proposal_data . options [proposal_transaction_data . option_index as usize] ; option . transactions_executed_count = option . transactions_executed_count . checked_add (1) . unwrap () ; if (proposal_data . state == ProposalState :: Executing || proposal_data . state == ProposalState :: ExecutingWithErrors) && proposal_data . options . iter () . filter (| o | o . vote_result == OptionVoteResult :: Succeeded) . all (| o | o . transactions_executed_count == o . transactions_count) { proposal_data . closed_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Completed ; } proposal_data . serialize (& mut proposal_info . data . borrow_mut () [..]) ? ; proposal_transaction_data . executed_at = Some (clock . unix_timestamp) ; proposal_transaction_data . execution_status = TransactionExecutionStatus :: Success ; proposal_transaction_data . serialize (& mut proposal_transaction_info . data . borrow_mut () [..]) ? ; Ok (()) }",
          "description": "Time-sensitive operation without tolerance.",
          "attack_scenario": "Validator manipulates slot time for advantage.",
          "real_world_incident": null,
          "secure_fix": "Add time buffer for critical operations",
          "prevention": "Don't rely on exact timestamps",
          "confidence": 59
        },
        {
          "category": "Input Validation",
          "vuln_type": "Unbounded Input Length",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-062",
          "cwe": "CWE-400",
          "location": "process_execute_transaction.rs",
          "function_name": "process_execute_transaction",
          "line_number": 23,
          "vulnerable_code": "#[doc = \" Processes ExecuteTransaction instruction\"] pub fn process_execute_transaction (program_id : & Pubkey , accounts : & [AccountInfo]) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let governance_info = next_account_info (account_info_iter) ? ; let proposal_info = next_account_info (account_info_iter) ? ; let proposal_transaction_info = next_account_info (account_info_iter) ? ; let clock = Clock :: get () ? ; let governance_data = get_governance_data (program_id , governance_info) ? ; let mut proposal_data = get_proposal_data_for_governance (program_id , proposal_info , governance_info . key) ? ; let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal (program_id , proposal_transaction_info , proposal_info . key ,) ? ; proposal_data . assert_can_execute_transaction (& proposal_transaction_data , & governance_data . config , clock . unix_timestamp ,) ? ; let instructions = proposal_transaction_data . instructions . iter () . map (Instruction :: from) ; let instruction_account_infos = account_info_iter . as_slice () ; let mut signers_seeds : Vec<& [& [u8]] > = vec ! [] ; let mut governance_seeds = governance_data . get_governance_address_seeds () ? . to_vec () ; let (_ , bump_seed) = Pubkey :: find_program_address (& governance_seeds , program_id) ; let bump = & [bump_seed] ; governance_seeds . push (bump) ; signers_seeds . push (& governance_seeds [..]) ; let mut treasury_seeds = get_native_treasury_address_seeds (governance_info . key) . to_vec () ; let (treasury_address , treasury_bump_seed) = Pubkey :: find_program_address (& treasury_seeds , program_id) ; let treasury_bump = & [treasury_bump_seed] ; if instruction_account_infos . iter () . any (| a | a . key == & treasury_address) { treasury_seeds . push (treasury_bump) ; signers_seeds . push (& treasury_seeds [..]) ; } for instruction in instructions { invoke_signed (& instruction , instruction_account_infos , & signers_seeds [..]) ? ; } if proposal_data . state == ProposalState :: Succeeded { proposal_data . executing_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Executing ; } let option = & mut proposal_data . options [proposal_transaction_data . option_index as usize] ; option . transactions_executed_count = option . transactions_executed_count . checked_add (1) . unwrap () ; if (proposal_data . state == ProposalState :: Executing || proposal_data . state == ProposalState :: ExecutingWithErrors) && proposal_data . options . iter () . filter (| o | o . vote_result == OptionVoteResult :: Succeeded) . all (| o | o . transactions_executed_count == o . transactions_count) { proposal_data . closed_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Completed ; } proposal_data . serialize (& mut proposal_info . data . borrow_mut () [..]) ? ; proposal_transaction_data . executed_at = Some (clock . unix_timestamp) ; proposal_transaction_data . execution_status = TransactionExecutionStatus :: Success ; proposal_transaction_data . serialize (& mut proposal_transaction_info . data . borrow_mut () [..]) ? ; Ok (()) }",
          "description": "Instruction accepts Vec<> input without length bounds. An attacker can pass an extremely large array to consume all compute units or cause excessive memory allocation.",
          "attack_scenario": "Attacker passes a Vec with 10,000 elements. The instruction tries to iterate and runs out of compute units, DOS-ing the program.",
          "real_world_incident": null,
          "secure_fix": "Add length validation: `require!(items.len() <= MAX_ITEMS)`. Define reasonable constants for maximum array sizes.",
          "prevention": "Always validate collection lengths at instruction entry. Define MAX_* constants for all bounded collections.",
          "confidence": 59
        }
      ]
    },
    {
      "program": "SPL Token-Wrap",
      "category": "CLEAN",
      "path": "./real_exploits/spl/token-wrap/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 0,
      "findings": []
    },
    {
      "program": "SPL Token-Lending",
      "category": "CLEAN",
      "path": "./real_exploits/spl/token-lending/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 2,
      "findings": [
        {
          "category": "Reentrancy",
          "vuln_type": "Cross-Program Reentrancy",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-017",
          "cwe": "CWE-841",
          "location": "processor.rs",
          "function_name": "process_flash_loan",
          "line_number": 1509,
          "vulnerable_code": "#[inline (never)] fn process_flash_loan (program_id : & Pubkey , liquidity_amount : u64 , accounts : & [AccountInfo] ,) -> ProgramResult { if liquidity_amount == 0 { msg ! (\"Liquidity amount provided cannot be zero\") ; return Err (LendingError :: InvalidAmount . into ()) ; } let account_info_iter = & mut accounts . iter () ; let source_liquidity_info = next_account_info (account_info_iter) ? ; let destination_liquidity_info = next_account_info (account_info_iter) ? ; let reserve_info = next_account_info (account_info_iter) ? ; let reserve_liquidity_fee_receiver_info = next_account_info (account_info_iter) ? ; let host_fee_receiver_info = next_account_info (account_info_iter) ? ; let lending_market_info = next_account_info (account_info_iter) ? ; let lending_market_authority_info = next_account_info (account_info_iter) ? ; let token_program_id = next_account_info (account_info_iter) ? ; let flash_loan_receiver_program_id = next_account_info (account_info_iter) ? ; if program_id == flash_loan_receiver_program_id . key { msg ! (\"Lending program cannot be used as the flash loan receiver program provided\") ; return Err (LendingError :: InvalidFlashLoanReceiverProgram . into ()) ; } let lending_market = LendingMarket :: unpack (& lending_market_info . data . borrow ()) ? ; if lending_market_info . owner != program_id { return Err (LendingError :: InvalidAccountOwner . into ()) ; } if & lending_market . token_program_id != token_program_id . key { msg ! (\"Lending market token program does not match the token program provided\") ; return Err (LendingError :: InvalidTokenProgram . into ()) ; } let authority_signer_seeds = & [lending_market_info . key . as_ref () , & [lending_market . bump_seed] ,] ; let lending_market_authority_pubkey = Pubkey :: create_program_address (authority_signer_seeds , program_id) ? ; if & lending_market_authority_pubkey != lending_market_authority_info . key { msg ! (\"Derived lending market authority does not match the lending market authority provided\") ; return Err (LendingError :: InvalidMarketAuthority . into ()) ; } let mut reserve = Reserve :: unpack (& reserve_info . data . borrow ()) ? ; if reserve_info . owner != program_id { msg ! (\"Reserve provided is not owned by the lending program\") ; return Err (LendingError :: InvalidAccountOwner . into ()) ; } if & reserve . lending_market != lending_market_info . key { msg ! (\"Invalid reserve lending market account\") ; return Err (LendingError :: InvalidAccountInput . into ()) ; } if & reserve . liquidity . supply_pubkey != source_liquidity_info . key { msg ! (\"Reserve liquidity supply must be used as the source liquidity provided\") ; return Err (LendingError :: InvalidAccountInput . into ()) ; } if & reserve . liquidity . fee_receiver != reserve_liquidity_fee_receiver_info . key { msg ! (\"Reserve liquidity fee receiver does not match the reserve liquidity fee receiver provided\") ; return Err (LendingError :: InvalidAccountInput . into ()) ; } let flash_loan_amount = if liquidity_amount == u64 :: MAX { reserve . liquidity . available_amount } else { liquidity_amount } ; let flash_loan_amount_decimal = Decimal :: from (flash_loan_amount) ; let (origination_fee , host_fee) = reserve . config . fees . calculate_flash_loan_fees (flash_loan_amount_decimal) ? ; let balance_before_flash_loan = Account :: unpack (& source_liquidity_info . data . borrow ()) ? . amount ; let expected_balance_after_flash_loan = balance_before_flash_loan . checked_add (origination_fee) . ok_or (LendingError :: MathOverflow) ? ; let returned_amount_required = flash_loan_amount . checked_add (origination_fee) . ok_or (LendingError :: MathOverflow) ? ; let mut flash_loan_instruction_accounts = vec ! [AccountMeta :: new (* destination_liquidity_info . key , false) , AccountMeta :: new (* source_liquidity_info . key , false) , AccountMeta :: new_readonly (* token_program_id . key , false) ,] ; let mut flash_loan_instruction_account_infos = vec ! [destination_liquidity_info . clone () , flash_loan_receiver_program_id . clone () , source_liquidity_info . clone () , token_program_id . clone () ,] ; for account_info in account_info_iter { flash_loan_instruction_accounts . push (AccountMeta { pubkey : * account_info . key , is_signer : account_info . is_signer , is_writable : account_info . is_writable , }) ; flash_loan_instruction_account_infos . push (account_info . clone ()) ; } reserve . liquidity . borrow (flash_loan_amount_decimal) ? ; Reserve :: pack (reserve , & mut reserve_info . data . borrow_mut ()) ? ; spl_token_transfer (TokenTransferParams { source : source_liquidity_info . clone () , destination : destination_liquidity_info . clone () , amount : flash_loan_amount , authority : lending_market_authority_info . clone () , authority_signer_seeds , token_program : token_program_id . clone () , }) ? ; const RECEIVE_FLASH_LOAN_INSTRUCTION_DATA_SIZE : usize = 9 ; const RECEIVE_FLASH_LOAN_INSTRUCTION_TAG : u8 = 0u8 ; let mut data = Vec :: with_capacity (RECEIVE_FLASH_LOAN_INSTRUCTION_DATA_SIZE) ; data . push (RECEIVE_FLASH_LOAN_INSTRUCTION_TAG) ; data . extend_from_slice (& returned_amount_required . to_le_bytes ()) ; invoke (& Instruction { program_id : * flash_loan_receiver_program_id . key , accounts : flash_loan_instruction_accounts , data , } , & flash_loan_instruction_account_infos [..] ,) ? ; reserve = Reserve :: unpack (& reserve_info . data . borrow ()) ? ; reserve . liquidity . repay (flash_loan_amount , flash_loan_amount_decimal) ? ; Reserve :: pack (reserve , & mut reserve_info . data . borrow_mut ()) ? ; let actual_balance_after_flash_loan = Account :: unpack (& source_liquidity_info . data . borrow ()) ? . amount ; if actual_balance_after_flash_loan < expected_balance_after_flash_loan { msg ! (\"Insufficient reserve liquidity after flash loan\") ; return Err (LendingError :: NotEnoughLiquidityAfterFlashLoan . into ()) ; } let mut owner_fee = origination_fee ; if host_fee > 0 { owner_fee = owner_fee . checked_sub (host_fee) . ok_or (LendingError :: MathOverflow) ? ; spl_token_transfer (TokenTransferParams { source : source_liquidity_info . clone () , destination : host_fee_receiver_info . clone () , amount : host_fee , authority : lending_market_authority_info . clone () , authority_signer_seeds , token_program : token_program_id . clone () , }) ? ; } if owner_fee > 0 { spl_token_transfer (TokenTransferParams { source : source_liquidity_info . clone () , destination : reserve_liquidity_fee_receiver_info . clone () , amount : owner_fee , authority : lending_market_authority_info . clone () , authority_signer_seeds , token_program : token_program_id . clone () , }) ? ; } Ok (()) }",
          "description": "State modification after CPI allows reentrancy attack \u2014 confirmed via AST statement ordering analysis.",
          "attack_scenario": "Attacker's program calls back before state is finalized.",
          "real_world_incident": {
            "project": "Various DeFi",
            "loss": "$100M+",
            "date": "2021-2023"
          },
          "secure_fix": "Update state BEFORE making CPI calls (Checks-Effects-Interactions)",
          "prevention": "Follow CEI pattern, add reentrancy guards",
          "confidence": 75
        },
        {
          "category": "Data Validation",
          "vuln_type": "Unsafe Deserialization",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-014",
          "cwe": "CWE-502",
          "location": "processor.rs",
          "function_name": "process_flash_loan",
          "line_number": 1509,
          "vulnerable_code": "#[inline (never)] fn process_flash_loan (program_id : & Pubkey , liquidity_amount : u64 , accounts : & [AccountInfo] ,) -> ProgramResult { if liquidity_amount == 0 { msg ! (\"Liquidity amount provided cannot be zero\") ; return Err (LendingError :: InvalidAmount . into ()) ; } let account_info_iter = & mut accounts . iter () ; let source_liquidity_info = next_account_info (account_info_iter) ? ; let destination_liquidity_info = next_account_info (account_info_iter) ? ; let reserve_info = next_account_info (account_info_iter) ? ; let reserve_liquidity_fee_receiver_info = next_account_info (account_info_iter) ? ; let host_fee_receiver_info = next_account_info (account_info_iter) ? ; let lending_market_info = next_account_info (account_info_iter) ? ; let lending_market_authority_info = next_account_info (account_info_iter) ? ; let token_program_id = next_account_info (account_info_iter) ? ; let flash_loan_receiver_program_id = next_account_info (account_info_iter) ? ; if program_id == flash_loan_receiver_program_id . key { msg ! (\"Lending program cannot be used as the flash loan receiver program provided\") ; return Err (LendingError :: InvalidFlashLoanReceiverProgram . into ()) ; } let lending_market = LendingMarket :: unpack (& lending_market_info . data . borrow ()) ? ; if lending_market_info . owner != program_id { return Err (LendingError :: InvalidAccountOwner . into ()) ; } if & lending_market . token_program_id != token_program_id . key { msg ! (\"Lending market token program does not match the token program provided\") ; return Err (LendingError :: InvalidTokenProgram . into ()) ; } let authority_signer_seeds = & [lending_market_info . key . as_ref () , & [lending_market . bump_seed] ,] ; let lending_market_authority_pubkey = Pubkey :: create_program_address (authority_signer_seeds , program_id) ? ; if & lending_market_authority_pubkey != lending_market_authority_info . key { msg ! (\"Derived lending market authority does not match the lending market authority provided\") ; return Err (LendingError :: InvalidMarketAuthority . into ()) ; } let mut reserve = Reserve :: unpack (& reserve_info . data . borrow ()) ? ; if reserve_info . owner != program_id { msg ! (\"Reserve provided is not owned by the lending program\") ; return Err (LendingError :: InvalidAccountOwner . into ()) ; } if & reserve . lending_market != lending_market_info . key { msg ! (\"Invalid reserve lending market account\") ; return Err (LendingError :: InvalidAccountInput . into ()) ; } if & reserve . liquidity . supply_pubkey != source_liquidity_info . key { msg ! (\"Reserve liquidity supply must be used as the source liquidity provided\") ; return Err (LendingError :: InvalidAccountInput . into ()) ; } if & reserve . liquidity . fee_receiver != reserve_liquidity_fee_receiver_info . key { msg ! (\"Reserve liquidity fee receiver does not match the reserve liquidity fee receiver provided\") ; return Err (LendingError :: InvalidAccountInput . into ()) ; } let flash_loan_amount = if liquidity_amount == u64 :: MAX { reserve . liquidity . available_amount } else { liquidity_amount } ; let flash_loan_amount_decimal = Decimal :: from (flash_loan_amount) ; let (origination_fee , host_fee) = reserve . config . fees . calculate_flash_loan_fees (flash_loan_amount_decimal) ? ; let balance_before_flash_loan = Account :: unpack (& source_liquidity_info . data . borrow ()) ? . amount ; let expected_balance_after_flash_loan = balance_before_flash_loan . checked_add (origination_fee) . ok_or (LendingError :: MathOverflow) ? ; let returned_amount_required = flash_loan_amount . checked_add (origination_fee) . ok_or (LendingError :: MathOverflow) ? ; let mut flash_loan_instruction_accounts = vec ! [AccountMeta :: new (* destination_liquidity_info . key , false) , AccountMeta :: new (* source_liquidity_info . key , false) , AccountMeta :: new_readonly (* token_program_id . key , false) ,] ; let mut flash_loan_instruction_account_infos = vec ! [destination_liquidity_info . clone () , flash_loan_receiver_program_id . clone () , source_liquidity_info . clone () , token_program_id . clone () ,] ; for account_info in account_info_iter { flash_loan_instruction_accounts . push (AccountMeta { pubkey : * account_info . key , is_signer : account_info . is_signer , is_writable : account_info . is_writable , }) ; flash_loan_instruction_account_infos . push (account_info . clone ()) ; } reserve . liquidity . borrow (flash_loan_amount_decimal) ? ; Reserve :: pack (reserve , & mut reserve_info . data . borrow_mut ()) ? ; spl_token_transfer (TokenTransferParams { source : source_liquidity_info . clone () , destination : destination_liquidity_info . clone () , amount : flash_loan_amount , authority : lending_market_authority_info . clone () , authority_signer_seeds , token_program : token_program_id . clone () , }) ? ; const RECEIVE_FLASH_LOAN_INSTRUCTION_DATA_SIZE : usize = 9 ; const RECEIVE_FLASH_LOAN_INSTRUCTION_TAG : u8 = 0u8 ; let mut data = Vec :: with_capacity (RECEIVE_FLASH_LOAN_INSTRUCTION_DATA_SIZE) ; data . push (RECEIVE_FLASH_LOAN_INSTRUCTION_TAG) ; data . extend_from_slice (& returned_amount_required . to_le_bytes ()) ; invoke (& Instruction { program_id : * flash_loan_receiver_program_id . key , accounts : flash_loan_instruction_accounts , data , } , & flash_loan_instruction_account_infos [..] ,) ? ; reserve = Reserve :: unpack (& reserve_info . data . borrow ()) ? ; reserve . liquidity . repay (flash_loan_amount , flash_loan_amount_decimal) ? ; Reserve :: pack (reserve , & mut reserve_info . data . borrow_mut ()) ? ; let actual_balance_after_flash_loan = Account :: unpack (& source_liquidity_info . data . borrow ()) ? . amount ; if actual_balance_after_flash_loan < expected_balance_after_flash_loan { msg ! (\"Insufficient reserve liquidity after flash loan\") ; return Err (LendingError :: NotEnoughLiquidityAfterFlashLoan . into ()) ; } let mut owner_fee = origination_fee ; if host_fee > 0 { owner_fee = owner_fee . checked_sub (host_fee) . ok_or (LendingError :: MathOverflow) ? ; spl_token_transfer (TokenTransferParams { source : source_liquidity_info . clone () , destination : host_fee_receiver_info . clone () , amount : host_fee , authority : lending_market_authority_info . clone () , authority_signer_seeds , token_program : token_program_id . clone () , }) ? ; } if owner_fee > 0 { spl_token_transfer (TokenTransferParams { source : source_liquidity_info . clone () , destination : reserve_liquidity_fee_receiver_info . clone () , amount : owner_fee , authority : lending_market_authority_info . clone () , authority_signer_seeds , token_program : token_program_id . clone () , }) ? ; } Ok (()) }",
          "description": "Unsafe deserialization can read garbage data or cause undefined behavior.",
          "attack_scenario": "Attacker provides malformed data that crashes or exploits the program.",
          "real_world_incident": null,
          "secure_fix": "Use try_from_slice with proper error handling",
          "prevention": "Always validate data length and format before deserializing",
          "confidence": 65
        }
      ]
    },
    {
      "program": "SPL Managed-Token",
      "category": "CLEAN",
      "path": "./real_exploits/spl/managed-token/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 3,
      "findings": [
        {
          "category": "Account Validation",
          "vuln_type": "Type Cosplay",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-004",
          "cwe": "CWE-843",
          "location": "lib.rs",
          "function_name": "process_instruction",
          "line_number": 62,
          "vulnerable_code": "pub fn process_instruction (_program_id : & Pubkey , accounts : & [AccountInfo] , instruction_data : & [u8] ,) -> ProgramResult { let instruction = ManagedTokenInstruction :: try_from_slice (instruction_data) ? ; match instruction { ManagedTokenInstruction :: InitializeMint { decimals } => { msg ! (\"ManagedTokenInstruction::InitializeMint\") ; process_initialize_mint (accounts , decimals) } ManagedTokenInstruction :: InitializeAccount => { msg ! (\"ManagedTokenInstruction::InitializeAccount\") ; process_initialize_account (accounts) } ManagedTokenInstruction :: Transfer { amount } => { msg ! (\"ManagedTokenInstruction::Transfer\") ; process_transfer (accounts , amount) } ManagedTokenInstruction :: MintTo { amount } => { msg ! (\"ManagedTokenInstruction::MintTo\") ; process_mint_to (accounts , amount) } ManagedTokenInstruction :: Burn { amount } => { msg ! (\"ManagedTokenInstruction::Burn\") ; process_burn (accounts , amount) } ManagedTokenInstruction :: CloseAccount => { msg ! (\"ManagedTokenInstruction::CloseAccount\") ; process_close (accounts) } ManagedTokenInstruction :: Approve { amount } => { msg ! (\"ManagedTokenInstruction::Approve\") ; process_approve (accounts , amount) } ManagedTokenInstruction :: Revoke => { msg ! (\"ManagedTokenInstruction::Revoke\") ; process_revoke (accounts) } } }",
          "description": "Account data is deserialized via `try_from_slice` or `try_borrow_data` without validating the account's 8-byte discriminator. An attacker can create a different account type with the same data layout and pass it in place of the expected type. The Solana runtime does not enforce account type identity -- only the program can validate the discriminator. Anchor's `Account<'info, T>` does this automatically; raw AccountInfo does not.",
          "attack_scenario": "Attacker deploys a program that creates Account Type A with a data layout matching Type B. Passes Type A where the program expects Type B. The deserialization succeeds because the byte layout matches, but semantic meanings differ (e.g., a 'balance' field in Type A is actually a 'fee_rate' in Type B).",
          "real_world_incident": null,
          "secure_fix": "Use Anchor's `Account<'info, T>` which auto-validates the 8-byte discriminator, or manually check: `require!(data[0..8] == MyType::DISCRIMINATOR)`",
          "prevention": "Never deserialize account data without first validating the discriminator. Use Anchor's typed wrappers or add manual discriminator checks.",
          "confidence": 56
        },
        {
          "category": "Token Security",
          "vuln_type": "Unauthorized Token Mint",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-031",
          "cwe": "CWE-269",
          "location": "lib.rs",
          "function_name": "process_instruction",
          "line_number": 62,
          "vulnerable_code": "pub fn process_instruction (_program_id : & Pubkey , accounts : & [AccountInfo] , instruction_data : & [u8] ,) -> ProgramResult { let instruction = ManagedTokenInstruction :: try_from_slice (instruction_data) ? ; match instruction { ManagedTokenInstruction :: InitializeMint { decimals } => { msg ! (\"ManagedTokenInstruction::InitializeMint\") ; process_initialize_mint (accounts , decimals) } ManagedTokenInstruction :: InitializeAccount => { msg ! (\"ManagedTokenInstruction::InitializeAccount\") ; process_initialize_account (accounts) } ManagedTokenInstruction :: Transfer { amount } => { msg ! (\"ManagedTokenInstruction::Transfer\") ; process_transfer (accounts , amount) } ManagedTokenInstruction :: MintTo { amount } => { msg ! (\"ManagedTokenInstruction::MintTo\") ; process_mint_to (accounts , amount) } ManagedTokenInstruction :: Burn { amount } => { msg ! (\"ManagedTokenInstruction::Burn\") ; process_burn (accounts , amount) } ManagedTokenInstruction :: CloseAccount => { msg ! (\"ManagedTokenInstruction::CloseAccount\") ; process_close (accounts) } ManagedTokenInstruction :: Approve { amount } => { msg ! (\"ManagedTokenInstruction::Approve\") ; process_approve (accounts , amount) } ManagedTokenInstruction :: Revoke => { msg ! (\"ManagedTokenInstruction::Revoke\") ; process_revoke (accounts) } } }",
          "description": "A `mint_to` CPI is performed without validating the mint authority as a `Signer<'info>`. Anyone can call this instruction and mint unlimited tokens. The SPL Token program requires the mint authority to sign the transaction, but if a PDA is the mint authority, the instruction handler must verify that the caller is authorized to trigger the PDA-signed mint.",
          "attack_scenario": "Attacker calls the mint instruction bypassing authority checks. If the mint is PDA-controlled, the program signs with invoke_signed, minting tokens to the attacker. They then sell the freshly minted tokens on a DEX, crashing the token price and profiting.",
          "real_world_incident": null,
          "secure_fix": "Validate mint authority: `pub mint_authority: Signer<'info>` with `has_one = mint_authority` on the config account. For PDA-minted tokens, require an admin Signer and enforce supply caps.",
          "prevention": "Gate all mint operations behind Signer-validated authority checks. Consider implementing supply caps for fixed-supply tokens.",
          "confidence": 56
        },
        {
          "category": "DeFi Security",
          "vuln_type": "Flash Loan Price Manipulation",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-058",
          "cwe": "CWE-682",
          "location": "instruction.rs",
          "function_name": "create_initialize_account_instruction",
          "line_number": 112,
          "vulnerable_code": "pub fn create_initialize_account_instruction (mint : & Pubkey , owner : & Pubkey , payer : & Pubkey , upstream_authority : & Pubkey ,) -> Result<Instruction , ProgramError > { let account = get_associated_token_address (owner , mint) ; let (freeze_authority , _) = get_authority (upstream_authority) ; Ok (Instruction { program_id : crate :: id () , accounts : vec ! [AccountMeta :: new (account , false) , AccountMeta :: new_readonly (* owner , false) , AccountMeta :: new (* payer , true) , AccountMeta :: new_readonly (* upstream_authority , true) , AccountMeta :: new_readonly (freeze_authority , false) , AccountMeta :: new_readonly (* mint , false) , AccountMeta :: new_readonly (system_program :: id () , false) , AccountMeta :: new_readonly (spl_associated_token_account_client :: program :: id () , false) , AccountMeta :: new_readonly (spl_token :: id () , false) ,] , data : borsh :: to_vec (& ManagedTokenInstruction :: InitializeAccount) ? , }) }",
          "description": "Price or exchange rate is calculated from spot balances without TWAP or oracle validation. A flash loan can temporarily inflate/deflate pool balances within a single transaction to manipulate the price.",
          "attack_scenario": "Attacker flash-borrows 10M USDC \u2192 dumps into pool \u2192 spot price crashes \u2192 buys cheap at manipulated price \u2192 repays flash loan \u2192 profits.",
          "real_world_incident": {
            "project": "Mango Markets",
            "loss": "$114M",
            "date": "2022-10-11"
          },
          "secure_fix": "Use TWAP oracles (Pyth, Switchboard) instead of spot balances. Add minimum time delays between price reads and actions.",
          "prevention": "Never derive prices from instantaneous pool balances. Use time-weighted averages or signed oracle feeds.",
          "confidence": 56
        }
      ]
    },
    {
      "program": "SPL Token-Swap",
      "category": "CLEAN",
      "path": "./real_exploits/spl/token-swap/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 0,
      "findings": []
    },
    {
      "program": "SPL Name-Service",
      "category": "CLEAN",
      "path": "./real_exploits/spl/name-service/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 0,
      "findings": []
    },
    {
      "program": "SPL Binary-Option",
      "category": "CLEAN",
      "path": "./real_exploits/spl/binary-option/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 1,
      "findings": [
        {
          "category": "Sysvar Security",
          "vuln_type": "Sysvar Address Issues",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-010",
          "cwe": "CWE-20",
          "location": "system_utils.rs",
          "function_name": "create_new_account",
          "line_number": 15,
          "vulnerable_code": "#[inline (always)] pub fn create_new_account < 'a > (from_info : & AccountInfo<'a > , new_account_info : & AccountInfo<'a > , space : usize , owner_info : & AccountInfo<'a > , rent_info : & AccountInfo<'a > ,) -> ProgramResult { let rent = & Rent :: from_account_info (rent_info) ? ; let required_lamports = rent . minimum_balance (space) . max (1) . saturating_sub (new_account_info . lamports ()) ; msg ! (\"Transfer {} lamports to the new account\" , required_lamports) ; invoke (& system_instruction :: create_account (from_info . key , new_account_info . key , required_lamports , space as u64 , owner_info . key ,) , & [from_info . clone () , new_account_info . clone ()] ,) ? ; Ok (()) }",
          "description": "Sysvar (Clock/Rent/SlotHashes) is accessed via raw `AccountInfo` without validating the account address is the real sysvar. An attacker can pass a fake account with fabricated data (e.g., a manipulated timestamp or artificial rent value). Use Anchor's `Sysvar<'info, Clock>` which validates the address automatically, or manually check against `sysvar::clock::id()`.",
          "attack_scenario": "Attacker creates a fake account with arbitrary data and passes it as the Clock sysvar. The program reads a manipulated `unix_timestamp`, allowing the attacker to bypass time-locked operations (vesting schedules, staking cooldowns, auction deadlines).",
          "real_world_incident": null,
          "secure_fix": "Use `pub clock: Sysvar<'info, Clock>` in your Accounts struct, or validate: `require!(clock_info.key() == sysvar::clock::id())`",
          "prevention": "Always use Anchor's typed `Sysvar<'info, T>` wrapper which validates the sysvar address during account deserialization.",
          "confidence": 59
        }
      ]
    },
    {
      "program": "SPL Binary-Oracle-Pair",
      "category": "CLEAN",
      "path": "./real_exploits/spl/binary-oracle-pair/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 1,
      "findings": [
        {
          "category": "Reentrancy",
          "vuln_type": "State Write After CPI",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-017",
          "cwe": "CWE-841",
          "location": "processor.rs",
          "function_name": "process_init_pool",
          "line_number": 304,
          "vulnerable_code": "borsh::to_writer(&mut pool_account_info.data.borrow_mut()[..], &pool).map_err(|e| e.into())",
          "description": "In `process_init_pool`: state is written at line 304 AFTER a CPI call at line 277. This violates the checks-effects-interactions pattern and can be exploited via reentrancy if the CPI target calls back.",
          "attack_scenario": "Attacker deploys a malicious program as the CPI target. When invoked, it re-enters the vulnerable instruction before the state update, draining funds using stale state.",
          "real_world_incident": {
            "project": "Sealevel Reentrancy",
            "loss": "Theoretical",
            "date": "2023"
          },
          "secure_fix": "Move all state writes BEFORE the CPI call, following checks-effects-interactions.",
          "prevention": "Always update state before CPI calls.",
          "confidence": 56
        }
      ]
    },
    {
      "program": "SPL Stateless-Asks",
      "category": "CLEAN",
      "path": "./real_exploits/spl/stateless-asks/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 3,
      "findings": [
        {
          "category": "Account Validation",
          "vuln_type": "Type Cosplay",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-004",
          "cwe": "CWE-843",
          "location": "processor.rs",
          "function_name": "pay_creator_fees",
          "line_number": 276,
          "vulnerable_code": "#[allow (clippy :: too_many_arguments)] fn pay_creator_fees < 'a > (account_info_iter : & mut Iter < AccountInfo<'a > > , metadata_info : & AccountInfo<'a > , src_account_info : & AccountInfo<'a > , src_authority_info : & AccountInfo<'a > , token_program_info : & AccountInfo<'a > , system_program_info : Option<& AccountInfo<'a > > , fee_mint : & AccountInfo<'a > , size : u64 , is_native : bool , seeds : & [& [u8]] ,) -> Result<u64 , ProgramError > { if * metadata_info . owner != inline_mpl_token_metadata :: id () { return Err (ProgramError :: InvalidAccountData) ; } let metadata = try_from_slice_unchecked :: < inline_mpl_token_metadata :: Metadata > (& metadata_info . try_borrow_data () ? ,) ? ; let fees = metadata . data . seller_fee_basis_points ; let total_fee = (fees as u64) . checked_mul (size) . ok_or (UtilError :: NumericalOverflow) ? . checked_div (10000) . ok_or (UtilError :: NumericalOverflow) ? ; let mut remaining_fee = total_fee ; let remaining_size = size . checked_sub (total_fee) . ok_or (UtilError :: NumericalOverflow) ? ; match metadata . data . creators { Some (creators) => { for creator in creators { let pct = creator . share as u64 ; let creator_fee = pct . checked_mul (total_fee) . ok_or (UtilError :: NumericalOverflow) ? . checked_div (100) . ok_or (UtilError :: NumericalOverflow) ? ; remaining_fee = remaining_fee . checked_sub (creator_fee) . ok_or (UtilError :: NumericalOverflow) ? ; let current_creator_info = next_account_info (account_info_iter) ? ; assert_keys_equal (creator . address , * current_creator_info . key) ? ; if ! is_native { let current_creator_token_account_info = next_account_info (account_info_iter) ? ; assert_is_ata (current_creator_token_account_info , current_creator_info . key , fee_mint . key ,) ? ; if creator_fee > 0 { if seeds . is_empty () { invoke (& spl_token :: instruction :: transfer (token_program_info . key , src_account_info . key , current_creator_token_account_info . key , src_authority_info . key , & [] , creator_fee ,) ? , & [src_account_info . clone () , current_creator_token_account_info . clone () , src_authority_info . clone () , token_program_info . clone () ,] ,) ? ; } else { invoke_signed (& spl_token :: instruction :: transfer (token_program_info . key , src_account_info . key , current_creator_token_account_info . key , src_authority_info . key , & [] , creator_fee ,) ? , & [src_account_info . clone () , current_creator_token_account_info . clone () , src_authority_info . clone () , token_program_info . clone () ,] , & [seeds] ,) ? ; } } } else if creator_fee > 0 { if ! seeds . is_empty () { msg ! (\"Maker cannot pay with native SOL\") ; return Err (ProgramError :: InvalidAccountData) ; } match system_program_info { Some (sys_program_info) => { invoke (& system_instruction :: transfer (src_account_info . key , current_creator_info . key , creator_fee ,) , & [src_account_info . clone () , current_creator_info . clone () , sys_program_info . clone () ,] ,) ? ; } None => { msg ! (\"Invalid System Program Info\") ; return Err (ProgramError :: IncorrectProgramId) ; } } } } } None => { msg ! (\"No creators found in metadata\") ; } } Ok (remaining_size . checked_add (remaining_fee) . ok_or (UtilError :: NumericalOverflow) ?) }",
          "description": "Account data is deserialized via `try_from_slice` or `try_borrow_data` without validating the account's 8-byte discriminator. An attacker can create a different account type with the same data layout and pass it in place of the expected type. The Solana runtime does not enforce account type identity -- only the program can validate the discriminator. Anchor's `Account<'info, T>` does this automatically; raw AccountInfo does not.",
          "attack_scenario": "Attacker deploys a program that creates Account Type A with a data layout matching Type B. Passes Type A where the program expects Type B. The deserialization succeeds because the byte layout matches, but semantic meanings differ (e.g., a 'balance' field in Type A is actually a 'fee_rate' in Type B).",
          "real_world_incident": null,
          "secure_fix": "Use Anchor's `Account<'info, T>` which auto-validates the 8-byte discriminator, or manually check: `require!(data[0..8] == MyType::DISCRIMINATOR)`",
          "prevention": "Never deserialize account data without first validating the discriminator. Use Anchor's typed wrappers or add manual discriminator checks.",
          "confidence": 80
        },
        {
          "category": "Data Validation",
          "vuln_type": "Unsafe Deserialization",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-014",
          "cwe": "CWE-502",
          "location": "processor.rs",
          "function_name": "pay_creator_fees",
          "line_number": 276,
          "vulnerable_code": "#[allow (clippy :: too_many_arguments)] fn pay_creator_fees < 'a > (account_info_iter : & mut Iter < AccountInfo<'a > > , metadata_info : & AccountInfo<'a > , src_account_info : & AccountInfo<'a > , src_authority_info : & AccountInfo<'a > , token_program_info : & AccountInfo<'a > , system_program_info : Option<& AccountInfo<'a > > , fee_mint : & AccountInfo<'a > , size : u64 , is_native : bool , seeds : & [& [u8]] ,) -> Result<u64 , ProgramError > { if * metadata_info . owner != inline_mpl_token_metadata :: id () { return Err (ProgramError :: InvalidAccountData) ; } let metadata = try_from_slice_unchecked :: < inline_mpl_token_metadata :: Metadata > (& metadata_info . try_borrow_data () ? ,) ? ; let fees = metadata . data . seller_fee_basis_points ; let total_fee = (fees as u64) . checked_mul (size) . ok_or (UtilError :: NumericalOverflow) ? . checked_div (10000) . ok_or (UtilError :: NumericalOverflow) ? ; let mut remaining_fee = total_fee ; let remaining_size = size . checked_sub (total_fee) . ok_or (UtilError :: NumericalOverflow) ? ; match metadata . data . creators { Some (creators) => { for creator in creators { let pct = creator . share as u64 ; let creator_fee = pct . checked_mul (total_fee) . ok_or (UtilError :: NumericalOverflow) ? . checked_div (100) . ok_or (UtilError :: NumericalOverflow) ? ; remaining_fee = remaining_fee . checked_sub (creator_fee) . ok_or (UtilError :: NumericalOverflow) ? ; let current_creator_info = next_account_info (account_info_iter) ? ; assert_keys_equal (creator . address , * current_creator_info . key) ? ; if ! is_native { let current_creator_token_account_info = next_account_info (account_info_iter) ? ; assert_is_ata (current_creator_token_account_info , current_creator_info . key , fee_mint . key ,) ? ; if creator_fee > 0 { if seeds . is_empty () { invoke (& spl_token :: instruction :: transfer (token_program_info . key , src_account_info . key , current_creator_token_account_info . key , src_authority_info . key , & [] , creator_fee ,) ? , & [src_account_info . clone () , current_creator_token_account_info . clone () , src_authority_info . clone () , token_program_info . clone () ,] ,) ? ; } else { invoke_signed (& spl_token :: instruction :: transfer (token_program_info . key , src_account_info . key , current_creator_token_account_info . key , src_authority_info . key , & [] , creator_fee ,) ? , & [src_account_info . clone () , current_creator_token_account_info . clone () , src_authority_info . clone () , token_program_info . clone () ,] , & [seeds] ,) ? ; } } } else if creator_fee > 0 { if ! seeds . is_empty () { msg ! (\"Maker cannot pay with native SOL\") ; return Err (ProgramError :: InvalidAccountData) ; } match system_program_info { Some (sys_program_info) => { invoke (& system_instruction :: transfer (src_account_info . key , current_creator_info . key , creator_fee ,) , & [src_account_info . clone () , current_creator_info . clone () , sys_program_info . clone () ,] ,) ? ; } None => { msg ! (\"Invalid System Program Info\") ; return Err (ProgramError :: IncorrectProgramId) ; } } } } } None => { msg ! (\"No creators found in metadata\") ; } } Ok (remaining_size . checked_add (remaining_fee) . ok_or (UtilError :: NumericalOverflow) ?) }",
          "description": "Unsafe deserialization can read garbage data or cause undefined behavior.",
          "attack_scenario": "Attacker provides malformed data that crashes or exploits the program.",
          "real_world_incident": null,
          "secure_fix": "Use try_from_slice with proper error handling",
          "prevention": "Always validate data length and format before deserializing",
          "confidence": 70
        },
        {
          "category": "PDA Security",
          "vuln_type": "PDA Seed Collision",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-065",
          "cwe": "CWE-330",
          "location": "processor.rs",
          "function_name": "process_accept_offer",
          "line_number": 91,
          "vulnerable_code": "fn process_accept_offer (program_id : & Pubkey , accounts : & [AccountInfo] , has_metadata : bool , maker_size : u64 , taker_size : u64 , bump_seed : u8 ,) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let maker_wallet = next_account_info (account_info_iter) ? ; let taker_wallet = next_account_info (account_info_iter) ? ; let maker_src_account = next_account_info (account_info_iter) ? ; let maker_dst_account = next_account_info (account_info_iter) ? ; let taker_src_account = next_account_info (account_info_iter) ? ; let taker_dst_account = next_account_info (account_info_iter) ? ; let maker_src_mint = next_account_info (account_info_iter) ? ; let taker_src_mint = next_account_info (account_info_iter) ? ; let transfer_authority = next_account_info (account_info_iter) ? ; let token_program_info = next_account_info (account_info_iter) ? ; let mut system_program_info : Option<& AccountInfo > = None ; let is_native = * taker_src_mint . key == spl_token :: native_mint :: id () ; if is_native { assert_keys_equal (* taker_wallet . key , * taker_src_account . key) ? ; assert_keys_equal (* maker_wallet . key , * maker_dst_account . key) ? ; system_program_info = Some (next_account_info (account_info_iter) ?) ; } let seeds = & [b\"stateless_offer\" , maker_wallet . key . as_ref () , maker_src_mint . key . as_ref () , taker_src_mint . key . as_ref () , & maker_size . to_le_bytes () , & taker_size . to_le_bytes () , & [bump_seed] ,] ; let (maker_pay_size , taker_pay_size) = if has_metadata { let metadata_info = next_account_info (account_info_iter) ? ; let (maker_metadata_key , _) = Pubkey :: find_program_address (& [b\"metadata\" , inline_mpl_token_metadata :: id () . as_ref () , maker_src_mint . key . as_ref () ,] , & inline_mpl_token_metadata :: id () ,) ; let (taker_metadata_key , _) = Pubkey :: find_program_address (& [b\"metadata\" , inline_mpl_token_metadata :: id () . as_ref () , taker_src_mint . key . as_ref () ,] , & inline_mpl_token_metadata :: id () ,) ; if * metadata_info . key == maker_metadata_key { msg ! (\"Taker pays for fees\") ; let taker_remaining_size = pay_creator_fees (account_info_iter , metadata_info , taker_src_account , taker_wallet , token_program_info , system_program_info , taker_src_mint , taker_size , is_native , & [] ,) ? ; (maker_size , taker_remaining_size) } else if * metadata_info . key == taker_metadata_key { msg ! (\"Maker pays for fees\") ; let maker_remaining_size = pay_creator_fees (account_info_iter , metadata_info , maker_src_account , transfer_authority , token_program_info , system_program_info , maker_src_mint , maker_size , is_native , seeds ,) ? ; (maker_remaining_size , taker_size) } else { msg ! (\"Neither maker nor taker metadata keys match\") ; return Err (ProgramError :: InvalidAccountData) ; } } else { (maker_size , taker_size) } ; let maker_src_token_account : spl_token :: state :: Account = spl_token :: state :: Account :: unpack (& maker_src_account . data . borrow ()) ? ; msg ! (\"Delegate {}\" , maker_src_token_account . delegate . unwrap_or (* maker_wallet . key)) ; msg ! (\"Delegated Amount {}\" , maker_src_token_account . delegated_amount) ; if maker_src_token_account . delegated_amount != maker_pay_size { return Err (ProgramError :: InvalidAccountData) ; } let authority_key = Pubkey :: create_program_address (seeds , program_id) ? ; assert_keys_equal (authority_key , * transfer_authority . key) ? ; msg ! (\"Authority key matches\") ; if maker_src_token_account . delegate != COption :: Some (authority_key) { return Err (ProgramError :: InvalidAccountData) ; } msg ! (\"Delegate matches\") ; assert_keys_equal (spl_token :: id () , * token_program_info . key) ? ; assert_is_ata (maker_src_account , maker_wallet . key , maker_src_mint . key) ? ; assert_is_ata (taker_dst_account , taker_wallet . key , maker_src_mint . key) ? ; invoke_signed (& spl_token :: instruction :: transfer (token_program_info . key , maker_src_account . key , taker_dst_account . key , transfer_authority . key , & [] , maker_pay_size ,) ? , & [maker_src_account . clone () , taker_dst_account . clone () , transfer_authority . clone () , token_program_info . clone () ,] , & [seeds] ,) ? ; msg ! (\"done tx from maker to taker {}\" , maker_pay_size) ; if * taker_src_mint . key == spl_token :: native_mint :: id () { match system_program_info { Some (sys_program_info) => { assert_keys_equal (system_program :: id () , * sys_program_info . key) ? ; invoke (& system_instruction :: transfer (taker_src_account . key , maker_dst_account . key , taker_pay_size ,) , & [taker_src_account . clone () , maker_dst_account . clone () , sys_program_info . clone () ,] ,) ? ; } _ => return Err (ProgramError :: InvalidAccountData) , } } else { assert_is_ata (maker_dst_account , maker_wallet . key , taker_src_mint . key) ? ; assert_is_ata (taker_src_account , taker_wallet . key , taker_src_mint . key) ? ; invoke (& spl_token :: instruction :: transfer (token_program_info . key , taker_src_account . key , maker_dst_account . key , taker_wallet . key , & [] , taker_pay_size ,) ? , & [taker_src_account . clone () , maker_dst_account . clone () , taker_wallet . clone () , token_program_info . clone () ,] ,) ? ; } msg ! (\"done tx from taker to maker {}\" , taker_pay_size) ; msg ! (\"done!\") ; Ok (()) }",
          "description": "Multiple PDA derivations use similar seed patterns without unique type prefixes. If seeds overlap, different account types could derive to the same address, causing state corruption.",
          "attack_scenario": "Program uses seeds=[user_key] for both 'balance' and 'config' accounts. An attacker creates a 'config' account that collides with a 'balance' account, corrupting state.",
          "real_world_incident": null,
          "secure_fix": "Add unique type prefixes: seeds = [b\"balance\", user.key()] vs seeds = [b\"config\", admin.key()]. Use SEED_PREFIX constants.",
          "prevention": "Always include a unique byte prefix per PDA type. Define SEED_PREFIX constants to prevent typos.",
          "confidence": 60
        }
      ]
    },
    {
      "program": "SPL Token-Upgrade",
      "category": "CLEAN",
      "path": "./real_exploits/spl/token-upgrade/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 2,
      "findings": [
        {
          "category": "Data Validation",
          "vuln_type": "Unsafe Deserialization",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-014",
          "cwe": "CWE-502",
          "location": "processor.rs",
          "function_name": "burn_original_tokens",
          "line_number": 31,
          "vulnerable_code": "fn burn_original_tokens < 'a > (original_token_program : AccountInfo<'a > , source : AccountInfo<'a > , mint : AccountInfo<'a > , authority : AccountInfo<'a > , multisig_signers : & [AccountInfo<'a >] , amount : u64 , decimals : u8 ,) -> ProgramResult { let multisig_pubkeys = multisig_signers . iter () . map (| s | s . key) . collect :: < Vec<_ > > () ; let ix = spl_token_2022 :: instruction :: burn_checked (original_token_program . key , source . key , mint . key , authority . key , & multisig_pubkeys , amount , decimals ,) ? ; let mut account_infos = vec ! [source , mint , authority] ; account_infos . extend_from_slice (multisig_signers) ; invoke (& ix , & account_infos) }",
          "description": "Unsafe deserialization can read garbage data or cause undefined behavior.",
          "attack_scenario": "Attacker provides malformed data that crashes or exploits the program.",
          "real_world_incident": null,
          "secure_fix": "Use try_from_slice with proper error handling",
          "prevention": "Always validate data length and format before deserializing",
          "confidence": 69
        },
        {
          "category": "Token2022 Security",
          "vuln_type": "Transfer Fee Accounting Mismatch",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-056",
          "cwe": "CWE-682",
          "location": "processor.rs",
          "function_name": "transfer_new_tokens",
          "line_number": 56,
          "vulnerable_code": "#[allow (clippy :: too_many_arguments)] fn transfer_new_tokens < 'a > (new_token_program : AccountInfo<'a > , source : AccountInfo<'a > , mint : AccountInfo<'a > , destination : AccountInfo<'a > , authority : AccountInfo<'a > , authority_seeds : & [& [u8]] , amount : u64 , decimals : u8 ,) -> Result<() , ProgramError > { let ix = spl_token_2022 :: instruction :: transfer_checked (new_token_program . key , source . key , mint . key , destination . key , authority . key , & [] , amount , decimals ,) ? ; invoke_signed (& ix , & [source , mint , destination , authority] , & [authority_seeds] ,) }",
          "description": "Token2022 tokens with the TransferFee extension deduct fees automatically during transfer. If the program assumes the recipient receives the full amount, accounting will be incorrect.",
          "attack_scenario": "DEX records a deposit of 100 tokens, but Token2022 deducted a 2% fee. Only 98 tokens arrived. User withdraws 100, draining the pool of 2 extra tokens per transaction.",
          "real_world_incident": null,
          "secure_fix": "Query the TransferFee extension: `get_epoch_fee(&mint_data, epoch)` to calculate the actual received amount. Use post-transfer balance checks.",
          "prevention": "Always check mint extensions before transfers. Account for fees by comparing pre/post balances or querying the fee config.",
          "confidence": 69
        }
      ]
    },
    {
      "program": "SPL Token-Collection",
      "category": "CLEAN",
      "path": "./real_exploits/spl/token-collection/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 1,
      "findings": [
        {
          "category": "Account Validation",
          "vuln_type": "Type Cosplay",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-004",
          "cwe": "CWE-843",
          "location": "processor.rs",
          "function_name": "check_mint_and_metadata",
          "line_number": 44,
          "vulnerable_code": "#[doc = \" Checks that a mint is valid and contains metadata.\"] fn check_mint_and_metadata (mint_info : & AccountInfo , mint_authority_info : & AccountInfo ,) -> ProgramResult { let mint_data = mint_info . try_borrow_data () ? ; let mint = StateWithExtensions :: < Mint > :: unpack (& mint_data) ? ; if ! mint_authority_info . is_signer { return Err (ProgramError :: MissingRequiredSignature) ; } if mint . base . mint_authority . as_ref () != COption :: Some (mint_authority_info . key) { return Err (TokenGroupError :: IncorrectMintAuthority . into ()) ; } let metadata_pointer = mint . get_extension :: < MetadataPointer > () ? ; let metadata_pointer_address = Option :: < Pubkey > :: from (metadata_pointer . metadata_address) ; if metadata_pointer_address == Some (* mint_info . key) { mint . get_variable_len_extension :: < TokenMetadata > () ? ; } Ok (()) }",
          "description": "Account data is deserialized via `try_from_slice` or `try_borrow_data` without validating the account's 8-byte discriminator. An attacker can create a different account type with the same data layout and pass it in place of the expected type. The Solana runtime does not enforce account type identity -- only the program can validate the discriminator. Anchor's `Account<'info, T>` does this automatically; raw AccountInfo does not.",
          "attack_scenario": "Attacker deploys a program that creates Account Type A with a data layout matching Type B. Passes Type A where the program expects Type B. The deserialization succeeds because the byte layout matches, but semantic meanings differ (e.g., a 'balance' field in Type A is actually a 'fee_rate' in Type B).",
          "real_world_incident": null,
          "secure_fix": "Use Anchor's `Account<'info, T>` which auto-validates the 8-byte discriminator, or manually check: `require!(data[0..8] == MyType::DISCRIMINATOR)`",
          "prevention": "Never deserialize account data without first validating the discriminator. Use Anchor's typed wrappers or add manual discriminator checks.",
          "confidence": 59
        }
      ]
    },
    {
      "program": "SPL Shared-Memory",
      "category": "CLEAN",
      "path": "./real_exploits/spl/shared-memory/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 0,
      "findings": []
    },
    {
      "program": "Cashio Bankman (collateral mgr)",
      "category": "PRODUCTION",
      "path": "./real_exploits/cashio/programs/bankman/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 5,
      "findings": [
        {
          "category": "Resource Safety",
          "vuln_type": "Compute Unit Exhaustion with Partial State",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-061",
          "cwe": "CWE-400",
          "location": "lib.rs",
          "function_name": "authorize_collateral",
          "line_number": 88,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: AuthorizeCollateral */\n#[doc = \" Accounts for [bankman::authorize_collateral].\"] #[derive (Accounts)] pub struct AuthorizeCollateral < 'info> { #[doc = \" The [Bank].\"] pub bank : Account<'info, Bank > , #[doc = \" The [Collateral] to add.\"] #[account (init, seeds = [b\"Collateral\" . as_ref () , bank . key () . to_bytes () . as_ref () , mint . key () . to_bytes () . as_ref ()] , bump , space = 8 + Collateral :: BYTES , payer = payer)] pub collateral : Account<'info, Collateral > , #[doc = \" [Mint] of the collateral.\"] pub mint : Box<Account<'info, Mint > > , #[doc = \" The [Bank::curator].\"] pub curator : Signer<'info> , #[doc = \" Payer of the crate initialization.\"] #[account (mut)] pub payer : Signer<'info> , #[doc = \" System program.\"] pub system_program : Program<'info, System > , }\n/* HANDLER: */\n#[doc = \" Adds a new collateral pool to a [Bank].\"] #[access_control (ctx . accounts . validate ())] pub fn authorize_collateral (ctx : Context<AuthorizeCollateral > , _bump : u8) -> Result<() > { let bank = & ctx . accounts . bank ; let collateral = & mut ctx . accounts . collateral ; collateral . bank = bank . key () ; collateral . mint = ctx . accounts . mint . key () ; collateral . bump = unwrap_bump ! (ctx , \"collateral\") ; emit ! (AddCollateralEvent { bank : bank . key () , collateral : collateral . key () , curator : bank . curator , mint : collateral . mint , timestamp : Clock :: get () ?. unix_timestamp }) ; Ok (()) }",
          "description": "Loop processes items while mutating state. If compute units run out mid-loop, the transaction fails but on-chain state may be partially updated (Solana does NOT roll back on CU exhaustion in inner instructions).",
          "attack_scenario": "Attacker provides a large input array. The loop processes 10 of 100 items before CU exhaustion. Those 10 state changes persist, creating an inconsistent state that can be exploited in subsequent transactions.",
          "real_world_incident": null,
          "secure_fix": "Add CU consumption checks in loops, or use pagination/cranking patterns. Process items in fixed-size batches.",
          "prevention": "Bound loop iterations. Use pagination for large datasets. Check remaining CU budget with `sol_remaining_compute_units()`.",
          "confidence": 65
        },
        {
          "category": "Arithmetic",
          "vuln_type": "Precision Loss",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-038",
          "cwe": "CWE-682",
          "location": "withdraw_author_fee.rs",
          "function_name": "handler",
          "line_number": 34,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: WithdrawAuthorFee */\n#[doc = \" Accounts for [bankman::withdraw_author_fee].\"] #[derive (Accounts)] pub struct WithdrawAuthorFee < 'info> { #[doc = \" The [Bank].\"] #[account (has_one = bankman @ crate :: ErrorCode :: UnauthorizedNotBankman)] pub bank : Account<'info, Bank > , #[doc = \" The [Bank::bankman].\"] pub bankman : Signer<'info> , #[doc = \" The [Collateral].\"] #[account (has_one = bank)] pub collateral : Account<'info, Collateral > , #[doc = \" Author fees.\"] #[account (mut, constraint = author_fees . mint == collateral . mint)] pub author_fees : Account<'info, TokenAccount > , #[doc = \" Account to send the author fees to.\"] #[account (mut)] pub destination : Account<'info, TokenAccount > , #[doc = \" The [Token] program.\"] pub token_program : Program<'info, Token > , }\n/* HANDLER: */\npub fn handler (ctx : Context<WithdrawAuthorFee > , amount : u64) -> Result<() > { let signer_seeds : & [& [& [u8]]] = & [& [b\"Bank\" . as_ref () , & ctx . accounts . bank . crate_token . to_bytes () , & [ctx . accounts . bank . bump] ,]] ; token :: transfer (CpiContext :: new (ctx . accounts . token_program . to_account_info () , token :: Transfer { from : ctx . accounts . author_fees . to_account_info () , to : ctx . accounts . destination . to_account_info () , authority : ctx . accounts . bank . to_account_info () , } ,) . with_signer (signer_seeds) , amount ,) ? ; Ok (()) }",
          "description": "Integer division causes precision loss in rates.",
          "attack_scenario": "Attacker exploits rounding for profit.",
          "real_world_incident": null,
          "secure_fix": "Use higher precision types (u128) for intermediate calcs",
          "prevention": "Scale values before division",
          "confidence": 65
        },
        {
          "category": "Time Safety",
          "vuln_type": "Time Manipulation Risk",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-046",
          "cwe": "CWE-367",
          "location": "lib.rs",
          "function_name": "new_bank",
          "line_number": 30,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: NewBank */\n#[doc = \" Accounts for [bankman::new_bank].\"] #[derive (Accounts)] pub struct NewBank < 'info> { #[doc = \" Information about the [Bank].\"] #[account (init, seeds = [b\"Bank\" . as_ref () , crate_token . key () . to_bytes () . as_ref ()] , bump , space = 8 + Bank :: BYTES , payer = payer)] pub bank : Account<'info, Bank > , #[doc = \" [Mint] of the [crate_token::CrateToken].\"] pub crate_mint : Account<'info, Mint > , #[doc = \" The [crate_token::CrateToken] to be created.\"] #[account (mut)] pub crate_token : SystemAccount<'info> , #[doc = \" The `brrr_issue_authority`.\"] #[doc = \" CHECK: Arbitrary.\"] pub brrr_issue_authority : UncheckedAccount<'info> , #[doc = \" The `burn_withdraw_authority`.\"] #[doc = \" CHECK: Arbitrary.\"] pub burn_withdraw_authority : UncheckedAccount<'info> , #[doc = \" Payer of the crate initialization.\"] #[account (mut)] pub payer : Signer<'info> , #[doc = \" The admin, who becomes the curator and the curator setter.\"] #[doc = \" CHECK: Arbitrary.\"] pub admin : UncheckedAccount<'info> , #[doc = \" System program.\"] pub system_program : Program<'info, System > , #[doc = \" Crate token program.\"] pub crate_token_program : Program<'info, crate_token :: program :: CrateToken > , }\n/* HANDLER: */\n#[doc = \" Provisions a new [Bank].\"] #[access_control (ctx . accounts . validate ())] pub fn new_bank (ctx : Context<NewBank > , _bank_bump : u8 , crate_bump : u8) -> Result<() > { crate_token :: cpi :: new_crate (CpiContext :: new (ctx . accounts . crate_token_program . to_account_info () , crate_token :: cpi :: accounts :: NewCrate { crate_mint : ctx . accounts . crate_mint . to_account_info () , crate_token : ctx . accounts . crate_token . to_account_info () , fee_to_setter : ctx . accounts . bank . to_account_info () , fee_setter_authority : ctx . accounts . bank . to_account_info () , author_fee_to : ctx . accounts . bank . to_account_info () , issue_authority : ctx . accounts . brrr_issue_authority . to_account_info () , withdraw_authority : ctx . accounts . burn_withdraw_authority . to_account_info () , payer : ctx . accounts . payer . to_account_info () , system_program : ctx . accounts . system_program . to_account_info () , } ,) , crate_bump ,) ? ; let bank_bump = unwrap_bump ! (ctx , \"bank\") ; let signer_seeds : & [& [& [u8]]] = & [& [b\"Bank\" . as_ref () , & ctx . accounts . crate_token . key () . to_bytes () , & [bank_bump] ,]] ; crate_token :: cpi :: set_withdraw_fee (CpiContext :: new (ctx . accounts . crate_token_program . to_account_info () , crate_token :: cpi :: accounts :: SetFees { crate_token : ctx . accounts . crate_token . to_account_info () , fee_setter : ctx . accounts . bank . to_account_info () , } ,) . with_signer (signer_seeds) , 50 ,) ? ; let bank = & mut ctx . accounts . bank ; bank . crate_token = ctx . accounts . crate_token . key () ; bank . bump = bank_bump ; bank . crate_mint = ctx . accounts . crate_mint . key () ; bank . curator = ctx . accounts . admin . key () ; bank . bankman = ctx . accounts . admin . key () ; emit ! (NewBankEvent { bank : bank . key () , curator : bank . curator , timestamp : Clock :: get () ?. unix_timestamp }) ; Ok (()) }",
          "description": "Time-sensitive operation without tolerance.",
          "attack_scenario": "Validator manipulates slot time for advantage.",
          "real_world_incident": null,
          "secure_fix": "Add time buffer for critical operations",
          "prevention": "Don't rely on exact timestamps",
          "confidence": 55
        },
        {
          "category": "Token Security",
          "vuln_type": "Unvalidated Freeze Authority",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-068",
          "cwe": "CWE-732",
          "location": "lib.rs",
          "function_name": "new_bank",
          "line_number": 30,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: NewBank */\n#[doc = \" Accounts for [bankman::new_bank].\"] #[derive (Accounts)] pub struct NewBank < 'info> { #[doc = \" Information about the [Bank].\"] #[account (init, seeds = [b\"Bank\" . as_ref () , crate_token . key () . to_bytes () . as_ref ()] , bump , space = 8 + Bank :: BYTES , payer = payer)] pub bank : Account<'info, Bank > , #[doc = \" [Mint] of the [crate_token::CrateToken].\"] pub crate_mint : Account<'info, Mint > , #[doc = \" The [crate_token::CrateToken] to be created.\"] #[account (mut)] pub crate_token : SystemAccount<'info> , #[doc = \" The `brrr_issue_authority`.\"] #[doc = \" CHECK: Arbitrary.\"] pub brrr_issue_authority : UncheckedAccount<'info> , #[doc = \" The `burn_withdraw_authority`.\"] #[doc = \" CHECK: Arbitrary.\"] pub burn_withdraw_authority : UncheckedAccount<'info> , #[doc = \" Payer of the crate initialization.\"] #[account (mut)] pub payer : Signer<'info> , #[doc = \" The admin, who becomes the curator and the curator setter.\"] #[doc = \" CHECK: Arbitrary.\"] pub admin : UncheckedAccount<'info> , #[doc = \" System program.\"] pub system_program : Program<'info, System > , #[doc = \" Crate token program.\"] pub crate_token_program : Program<'info, crate_token :: program :: CrateToken > , }\n/* HANDLER: */\n#[doc = \" Provisions a new [Bank].\"] #[access_control (ctx . accounts . validate ())] pub fn new_bank (ctx : Context<NewBank > , _bank_bump : u8 , crate_bump : u8) -> Result<() > { crate_token :: cpi :: new_crate (CpiContext :: new (ctx . accounts . crate_token_program . to_account_info () , crate_token :: cpi :: accounts :: NewCrate { crate_mint : ctx . accounts . crate_mint . to_account_info () , crate_token : ctx . accounts . crate_token . to_account_info () , fee_to_setter : ctx . accounts . bank . to_account_info () , fee_setter_authority : ctx . accounts . bank . to_account_info () , author_fee_to : ctx . accounts . bank . to_account_info () , issue_authority : ctx . accounts . brrr_issue_authority . to_account_info () , withdraw_authority : ctx . accounts . burn_withdraw_authority . to_account_info () , payer : ctx . accounts . payer . to_account_info () , system_program : ctx . accounts . system_program . to_account_info () , } ,) , crate_bump ,) ? ; let bank_bump = unwrap_bump ! (ctx , \"bank\") ; let signer_seeds : & [& [& [u8]]] = & [& [b\"Bank\" . as_ref () , & ctx . accounts . crate_token . key () . to_bytes () , & [bank_bump] ,]] ; crate_token :: cpi :: set_withdraw_fee (CpiContext :: new (ctx . accounts . crate_token_program . to_account_info () , crate_token :: cpi :: accounts :: SetFees { crate_token : ctx . accounts . crate_token . to_account_info () , fee_setter : ctx . accounts . bank . to_account_info () , } ,) . with_signer (signer_seeds) , 50 ,) ? ; let bank = & mut ctx . accounts . bank ; bank . crate_token = ctx . accounts . crate_token . key () ; bank . bump = bank_bump ; bank . crate_mint = ctx . accounts . crate_mint . key () ; bank . curator = ctx . accounts . admin . key () ; bank . bankman = ctx . accounts . admin . key () ; emit ! (NewBankEvent { bank : bank . key () , curator : bank . curator , timestamp : Clock :: get () ?. unix_timestamp }) ; Ok (()) }",
          "description": "DeFi protocol accepts token deposits without checking if the mint has a freeze authority. A freeze authority can freeze the protocol's token accounts, permanently locking user funds.",
          "attack_scenario": "Users deposit USDC into a lending pool. The token mint's freeze authority freezes the pool's token account. All deposits are permanently locked \u2014 users can never withdraw.",
          "real_world_incident": null,
          "secure_fix": "Check freeze authority: `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` or document the risk and implement contingency plans.",
          "prevention": "Audit accepted token mints for freeze authority. Warn users or reject tokens with active freeze authorities.",
          "confidence": 55
        },
        {
          "category": "Token Security",
          "vuln_type": "Unvalidated Freeze Authority",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-068",
          "cwe": "CWE-732",
          "location": "withdraw_author_fee.rs",
          "function_name": "handler",
          "line_number": 34,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: WithdrawAuthorFee */\n#[doc = \" Accounts for [bankman::withdraw_author_fee].\"] #[derive (Accounts)] pub struct WithdrawAuthorFee < 'info> { #[doc = \" The [Bank].\"] #[account (has_one = bankman @ crate :: ErrorCode :: UnauthorizedNotBankman)] pub bank : Account<'info, Bank > , #[doc = \" The [Bank::bankman].\"] pub bankman : Signer<'info> , #[doc = \" The [Collateral].\"] #[account (has_one = bank)] pub collateral : Account<'info, Collateral > , #[doc = \" Author fees.\"] #[account (mut, constraint = author_fees . mint == collateral . mint)] pub author_fees : Account<'info, TokenAccount > , #[doc = \" Account to send the author fees to.\"] #[account (mut)] pub destination : Account<'info, TokenAccount > , #[doc = \" The [Token] program.\"] pub token_program : Program<'info, Token > , }\n/* HANDLER: */\npub fn handler (ctx : Context<WithdrawAuthorFee > , amount : u64) -> Result<() > { let signer_seeds : & [& [& [u8]]] = & [& [b\"Bank\" . as_ref () , & ctx . accounts . bank . crate_token . to_bytes () , & [ctx . accounts . bank . bump] ,]] ; token :: transfer (CpiContext :: new (ctx . accounts . token_program . to_account_info () , token :: Transfer { from : ctx . accounts . author_fees . to_account_info () , to : ctx . accounts . destination . to_account_info () , authority : ctx . accounts . bank . to_account_info () , } ,) . with_signer (signer_seeds) , amount ,) ? ; Ok (()) }",
          "description": "DeFi protocol accepts token deposits without checking if the mint has a freeze authority. A freeze authority can freeze the protocol's token accounts, permanently locking user funds.",
          "attack_scenario": "Users deposit USDC into a lending pool. The token mint's freeze authority freezes the pool's token account. All deposits are permanently locked \u2014 users can never withdraw.",
          "real_world_incident": null,
          "secure_fix": "Check freeze authority: `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` or document the risk and implement contingency plans.",
          "prevention": "Audit accepted token mints for freeze authority. Warn users or reject tokens with active freeze authorities.",
          "confidence": 55
        }
      ]
    },
    {
      "program": "Saber Stable-Swap Anchor",
      "category": "PRODUCTION",
      "path": "./real_exploits/saber/stable-swap-anchor/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 4,
      "findings": [
        {
          "category": "Authentication",
          "vuln_type": "Missing Signer Check",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-001",
          "cwe": "CWE-287",
          "location": "accounts.rs",
          "function_name": "Initialize",
          "line_number": 12,
          "vulnerable_code": "pub swap_authority: AccountInfo<'info>,",
          "description": "Field `swap_authority` in `Initialize` uses raw `AccountInfo<'info>` without `Signer<'info>` or `#[account(signer)]`. Any pubkey can be passed as this account \u2014 the Solana runtime will NOT enforce signing. This allows unauthorized access to privileged operations.",
          "attack_scenario": "Attacker passes their own pubkey as `swap_authority`. Since there is no signer constraint, the runtime accepts the instruction and the attacker executes privileged operations.",
          "real_world_incident": {
            "project": "Wormhole",
            "loss": "$320M",
            "date": "2022-02-02"
          },
          "secure_fix": "Change `pub swap_authority: AccountInfo<'info>` to `pub swap_authority: Signer<'info>`, or add `#[account(signer)]`.",
          "prevention": "Always use Signer<'info> for authority accounts.",
          "confidence": 85
        },
        {
          "category": "Account Safety",
          "vuln_type": "Raw AccountInfo Without Type Safety",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-ALIAS-02",
          "cwe": "CWE-704",
          "location": "accounts.rs",
          "function_name": "Initialize",
          "line_number": 8,
          "vulnerable_code": "pub swap: AccountInfo<'info>",
          "description": "Account `swap` in `Initialize` uses raw `AccountInfo` which provides no type safety or discriminator checking. The account data can contain anything \u2014 including data from a completely different program.",
          "attack_scenario": "Attacker creates an account with crafted data that mimics the expected layout. Without discriminator checking, the program interprets this data as valid, leading to unauthorized operations.",
          "real_world_incident": {
            "project": "Wormhole Bridge",
            "loss": "$320M",
            "date": "2022-02-02"
          },
          "secure_fix": "Replace `AccountInfo` with a typed Anchor account: `Account<'info, YourType>` which automatically validates the discriminator and owner.",
          "prevention": "Always use typed accounts with discriminator validation.",
          "confidence": 75
        },
        {
          "category": "Authorization",
          "vuln_type": "Authority Account Without Signer Check",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-ALIAS-05",
          "cwe": "CWE-862",
          "location": "accounts.rs",
          "function_name": "Initialize",
          "line_number": 11,
          "vulnerable_code": "pub swap_authority: AccountInfo<'info>",
          "description": "Account `swap_authority` in `Initialize` has an authority-like name but is not marked as a signer. An attacker can pass any account as the authority without proving ownership.",
          "attack_scenario": "Attacker reads the authority pubkey from the program's state, then passes that pubkey as the authority account without signing the transaction with the corresponding private key.",
          "real_world_incident": {
            "project": "Wormhole Bridge",
            "loss": "$320M",
            "date": "2022-02-02"
          },
          "secure_fix": "Add `Signer<'info>` type or `#[account(signer)]` constraint.",
          "prevention": "Always require signer verification for authority accounts.",
          "confidence": 75
        },
        {
          "category": "Type Safety",
          "vuln_type": "Account Type Confusion",
          "severity": 5,
          "severity_label": "Critical",
          "id": "SOL-076",
          "cwe": "CWE-345",
          "location": "accounts.rs",
          "function_name": "initialize",
          "line_number": 12,
          "vulnerable_code": "11:     /// The authority of the swap.\n12:     pub swap_authority: AccountInfo<'info>,\n13:     /// The admin of the swap.",
          "description": "Raw `AccountInfo<'info>` field 'swap_authority' in 'initialize' has no `/// CHECK:` documentation and no Anchor constraints. Anchor will not validate the account type, owner, or data layout \u2014 any account can be substituted. This is the primary vector for account confusion attacks (Cashio $48M exploit, Wormhole $320M exploit).",
          "attack_scenario": "",
          "real_world_incident": null,
          "secure_fix": "Replace `AccountInfo<'info>` with a typed Anchor wrapper:\n\u2022 `Account<'info, MyData>` \u2014 validates owner + deserializes data\n\u2022 `Program<'info, MyProgram>` \u2014 validates program ID\n\u2022 `Signer<'info>` \u2014 validates is_signer flag\n\u2022 `SystemAccount<'info>` \u2014 validates System Program ownership\nIf raw access is truly needed, add `/// CHECK: <justification>` documenting why this is safe.",
          "prevention": "",
          "confidence": 75
        }
      ]
    },
    {
      "program": "Wormhole Migration",
      "category": "PRODUCTION",
      "path": "./real_exploits/wormhole/solana/migration/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 9,
      "findings": [
        {
          "category": "Token Security",
          "vuln_type": "Unprotected Mint Authority",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-021",
          "cwe": "CWE-269",
          "location": "add_liquidity.rs",
          "function_name": "add_liquidity",
          "line_number": 44,
          "vulnerable_code": "pub fn add_liquidity (ctx : & ExecutionContext , accs : & mut AddLiquidity , data : AddLiquidityData ,) -> Result<() > { if * accs . from_mint . info () . key != accs . pool . from { return Err (WrongMint . into ()) ; } if * accs . to_mint . info () . key != accs . pool . to { return Err (WrongMint . into ()) ; } if accs . lp_share_acc . mint != * accs . share_mint . info () . key { return Err (WrongMint . into ()) ; } accs . to_token_custody . verify_derivation (ctx . program_id , & ToCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . share_mint . verify_derivation (ctx . program_id , & ShareMintDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let to_tokens_in = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount } else { data . amount - (data . amount % 10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) } ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . to_lp_acc . info () . key , accs . to_token_custody . info () . key , accs . authority_signer . key , & [] , to_tokens_in ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . authority_signer , None) ? ; let share_amount = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount . checked_mul (10u64 . pow ((accs . from_mint . decimals - accs . to_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } else { data . amount . checked_div (10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } ; let mint_ix = spl_token :: instruction :: mint_to (& spl_token :: id () , accs . share_mint . info () . key , accs . lp_share_acc . info () . key , accs . custody_signer . key , & [] , share_amount ,) ? ; invoke_seeded (& mint_ix , ctx , & accs . custody_signer , None) ? ; Ok (()) }",
          "description": "Mint operation without proper authority validation.",
          "attack_scenario": "Attacker mints unlimited tokens.",
          "real_world_incident": null,
          "secure_fix": "Validate mint authority is a signer",
          "prevention": "Use PDA as mint authority and validate seeds",
          "confidence": 79
        },
        {
          "category": "Token Security",
          "vuln_type": "Unauthorized Token Mint",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-031",
          "cwe": "CWE-269",
          "location": "add_liquidity.rs",
          "function_name": "add_liquidity",
          "line_number": 44,
          "vulnerable_code": "pub fn add_liquidity (ctx : & ExecutionContext , accs : & mut AddLiquidity , data : AddLiquidityData ,) -> Result<() > { if * accs . from_mint . info () . key != accs . pool . from { return Err (WrongMint . into ()) ; } if * accs . to_mint . info () . key != accs . pool . to { return Err (WrongMint . into ()) ; } if accs . lp_share_acc . mint != * accs . share_mint . info () . key { return Err (WrongMint . into ()) ; } accs . to_token_custody . verify_derivation (ctx . program_id , & ToCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . share_mint . verify_derivation (ctx . program_id , & ShareMintDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let to_tokens_in = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount } else { data . amount - (data . amount % 10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) } ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . to_lp_acc . info () . key , accs . to_token_custody . info () . key , accs . authority_signer . key , & [] , to_tokens_in ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . authority_signer , None) ? ; let share_amount = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount . checked_mul (10u64 . pow ((accs . from_mint . decimals - accs . to_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } else { data . amount . checked_div (10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } ; let mint_ix = spl_token :: instruction :: mint_to (& spl_token :: id () , accs . share_mint . info () . key , accs . lp_share_acc . info () . key , accs . custody_signer . key , & [] , share_amount ,) ? ; invoke_seeded (& mint_ix , ctx , & accs . custody_signer , None) ? ; Ok (()) }",
          "description": "A `mint_to` CPI is performed without validating the mint authority as a `Signer<'info>`. Anyone can call this instruction and mint unlimited tokens. The SPL Token program requires the mint authority to sign the transaction, but if a PDA is the mint authority, the instruction handler must verify that the caller is authorized to trigger the PDA-signed mint.",
          "attack_scenario": "Attacker calls the mint instruction bypassing authority checks. If the mint is PDA-controlled, the program signs with invoke_signed, minting tokens to the attacker. They then sell the freshly minted tokens on a DEX, crashing the token price and profiting.",
          "real_world_incident": null,
          "secure_fix": "Validate mint authority: `pub mint_authority: Signer<'info>` with `has_one = mint_authority` on the config account. For PDA-minted tokens, require an admin Signer and enforce supply caps.",
          "prevention": "Gate all mint operations behind Signer-validated authority checks. Consider implementing supply caps for fixed-supply tokens.",
          "confidence": 79
        },
        {
          "category": "Token Security",
          "vuln_type": "Token Account Confusion",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-023",
          "cwe": "CWE-843",
          "location": "migrate_tokens.rs",
          "function_name": "migrate_tokens",
          "line_number": 50,
          "vulnerable_code": "pub fn migrate_tokens (ctx : & ExecutionContext , accs : & mut MigrateTokens , data : MigrateTokensData ,) -> Result<() > { if * accs . from_mint . info () . key != accs . pool . from { return Err (WrongMint . into ()) ; } if * accs . to_mint . info () . key != accs . pool . to { return Err (WrongMint . into ()) ; } if accs . user_from_acc . mint != accs . pool . from { return Err (WrongMint . into ()) ; } if accs . user_to_acc . mint != accs . pool . to { return Err (WrongMint . into ()) ; } accs . to_token_custody . verify_derivation (ctx . program_id , & ToCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . from_token_custody . verify_derivation (ctx . program_id , & FromCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . user_from_acc . info () . key , accs . from_token_custody . info () . key , accs . authority_signer . key , & [] , data . amount ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . authority_signer , None) ? ; let out_amount = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount . checked_div (10u64 . pow ((accs . from_mint . decimals - accs . to_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } else { data . amount . checked_mul (10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . to_token_custody . info () . key , accs . user_to_acc . info () . key , accs . custody_signer . key , & [] , out_amount ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . custody_signer , None) ? ; Ok (()) }",
          "description": "Token account mint not validated.",
          "attack_scenario": "Attacker substitutes token account for different mint.",
          "real_world_incident": null,
          "secure_fix": "Add constraint: token_account.mint == expected_mint",
          "prevention": "Always validate token account mint matches expected",
          "confidence": 69
        },
        {
          "category": "Token Security",
          "vuln_type": "Token Account Confusion",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-023",
          "cwe": "CWE-843",
          "location": "remove_liquidity.rs",
          "function_name": "remove_liquidity",
          "line_number": 49,
          "vulnerable_code": "pub fn remove_liquidity (ctx : & ExecutionContext , accs : & mut RemoveLiquidity , data : RemoveLiquidityData ,) -> Result<() > { if * accs . from_mint . info () . key != accs . pool . from { return Err (WrongMint . into ()) ; } if * accs . to_mint . info () . key != accs . pool . to { return Err (WrongMint . into ()) ; } if accs . lp_share_acc . mint != * accs . share_mint . info () . key { return Err (WrongMint . into ()) ; } accs . to_token_custody . verify_derivation (ctx . program_id , & ToCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . share_mint . verify_derivation (ctx . program_id , & ShareMintDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let out_amount = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount . checked_div (10u64 . pow ((accs . from_mint . decimals - accs . to_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } else { data . amount . checked_mul (10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . to_token_custody . info () . key , accs . to_lp_acc . info () . key , accs . custody_signer . key , & [] , out_amount ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . custody_signer , None) ? ; let mint_ix = spl_token :: instruction :: burn (& spl_token :: id () , accs . lp_share_acc . info () . key , accs . share_mint . info () . key , accs . authority_signer . key , & [] , data . amount ,) ? ; invoke_seeded (& mint_ix , ctx , & accs . authority_signer , None) ? ; Ok (()) }",
          "description": "Token account mint not validated.",
          "attack_scenario": "Attacker substitutes token account for different mint.",
          "real_world_incident": null,
          "secure_fix": "Add constraint: token_account.mint == expected_mint",
          "prevention": "Always validate token account mint matches expected",
          "confidence": 69
        },
        {
          "category": "MEV Protection",
          "vuln_type": "Sandwich Attack Vulnerability",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-034",
          "cwe": "CWE-362",
          "location": "remove_liquidity.rs",
          "function_name": "remove_liquidity",
          "line_number": 49,
          "vulnerable_code": "pub fn remove_liquidity (ctx : & ExecutionContext , accs : & mut RemoveLiquidity , data : RemoveLiquidityData ,) -> Result<() > { if * accs . from_mint . info () . key != accs . pool . from { return Err (WrongMint . into ()) ; } if * accs . to_mint . info () . key != accs . pool . to { return Err (WrongMint . into ()) ; } if accs . lp_share_acc . mint != * accs . share_mint . info () . key { return Err (WrongMint . into ()) ; } accs . to_token_custody . verify_derivation (ctx . program_id , & ToCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . share_mint . verify_derivation (ctx . program_id , & ShareMintDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let out_amount = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount . checked_div (10u64 . pow ((accs . from_mint . decimals - accs . to_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } else { data . amount . checked_mul (10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . to_token_custody . info () . key , accs . to_lp_acc . info () . key , accs . custody_signer . key , & [] , out_amount ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . custody_signer , None) ? ; let mint_ix = spl_token :: instruction :: burn (& spl_token :: id () , accs . lp_share_acc . info () . key , accs . share_mint . info () . key , accs . authority_signer . key , & [] , data . amount ,) ? ; invoke_seeded (& mint_ix , ctx , & accs . authority_signer , None) ? ; Ok (()) }",
          "description": "An AMM liquidity operation (add/remove liquidity) has no slippage or deadline protection. An attacker can sandwich the transaction by manipulating the pool ratio before and after the user's transaction, extracting value from the liquidity provider.",
          "attack_scenario": "User submits add_liquidity(1000 USDC, 1 SOL). Attacker front-runs by swapping heavily into SOL, inflating the SOL/USDC ratio. User's liquidity is added at the distorted ratio, receiving fewer LP tokens. Attacker back-runs by swapping back, profiting from the user's unfavorable entry price.",
          "real_world_incident": null,
          "secure_fix": "Add `min_lp_tokens` parameter: `require!(lp_tokens_minted >= min_lp_tokens, ErrorCode::SlippageExceeded)`. Also add a `deadline` timestamp parameter.",
          "prevention": "All liquidity operations should accept min/max output parameters and a deadline. Validate these before executing the operation.",
          "confidence": 69
        },
        {
          "category": "Token Security",
          "vuln_type": "Token Account Confusion",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-023",
          "cwe": "CWE-843",
          "location": "claim_shares.rs",
          "function_name": "claim_shares",
          "line_number": 45,
          "vulnerable_code": "pub fn claim_shares (ctx : & ExecutionContext , accs : & mut ClaimShares , data : ClaimSharesData ,) -> Result<() > { if accs . lp_share_acc . mint != * accs . share_mint . info () . key { return Err (WrongMint . into ()) ; } accs . from_token_custody . verify_derivation (ctx . program_id , & FromCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . share_mint . verify_derivation (ctx . program_id , & ShareMintDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . from_token_custody . info () . key , accs . from_lp_acc . info () . key , accs . custody_signer . key , & [] , data . amount ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . custody_signer , None) ? ; let mint_ix = spl_token :: instruction :: burn (& spl_token :: id () , accs . lp_share_acc . info () . key , accs . share_mint . info () . key , accs . authority_signer . key , & [] , data . amount ,) ? ; invoke_seeded (& mint_ix , ctx , & accs . authority_signer , None) ? ; Ok (()) }",
          "description": "Token account mint not validated.",
          "attack_scenario": "Attacker substitutes token account for different mint.",
          "real_world_incident": null,
          "secure_fix": "Add constraint: token_account.mint == expected_mint",
          "prevention": "Always validate token account mint matches expected",
          "confidence": 69
        },
        {
          "category": "DeFi Security",
          "vuln_type": "LP Token Manipulation",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-049",
          "cwe": "CWE-682",
          "location": "claim_shares.rs",
          "function_name": "claim_shares",
          "line_number": 45,
          "vulnerable_code": "pub fn claim_shares (ctx : & ExecutionContext , accs : & mut ClaimShares , data : ClaimSharesData ,) -> Result<() > { if accs . lp_share_acc . mint != * accs . share_mint . info () . key { return Err (WrongMint . into ()) ; } accs . from_token_custody . verify_derivation (ctx . program_id , & FromCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . share_mint . verify_derivation (ctx . program_id , & ShareMintDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . from_token_custody . info () . key , accs . from_lp_acc . info () . key , accs . custody_signer . key , & [] , data . amount ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . custody_signer , None) ? ; let mint_ix = spl_token :: instruction :: burn (& spl_token :: id () , accs . lp_share_acc . info () . key , accs . share_mint . info () . key , accs . authority_signer . key , & [] , data . amount ,) ? ; invoke_seeded (& mint_ix , ctx , & accs . authority_signer , None) ? ; Ok (()) }",
          "description": "LP token calculation may be manipulated.",
          "attack_scenario": "First depositor attack or ratio manipulation.",
          "real_world_incident": null,
          "secure_fix": "Check invariants before and after LP operations",
          "prevention": "Initialize pools with minimum liquidity",
          "confidence": 69
        },
        {
          "category": "Token Security",
          "vuln_type": "Token Account Confusion",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-023",
          "cwe": "CWE-843",
          "location": "add_liquidity.rs",
          "function_name": "add_liquidity",
          "line_number": 44,
          "vulnerable_code": "pub fn add_liquidity (ctx : & ExecutionContext , accs : & mut AddLiquidity , data : AddLiquidityData ,) -> Result<() > { if * accs . from_mint . info () . key != accs . pool . from { return Err (WrongMint . into ()) ; } if * accs . to_mint . info () . key != accs . pool . to { return Err (WrongMint . into ()) ; } if accs . lp_share_acc . mint != * accs . share_mint . info () . key { return Err (WrongMint . into ()) ; } accs . to_token_custody . verify_derivation (ctx . program_id , & ToCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . share_mint . verify_derivation (ctx . program_id , & ShareMintDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let to_tokens_in = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount } else { data . amount - (data . amount % 10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) } ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . to_lp_acc . info () . key , accs . to_token_custody . info () . key , accs . authority_signer . key , & [] , to_tokens_in ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . authority_signer , None) ? ; let share_amount = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount . checked_mul (10u64 . pow ((accs . from_mint . decimals - accs . to_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } else { data . amount . checked_div (10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } ; let mint_ix = spl_token :: instruction :: mint_to (& spl_token :: id () , accs . share_mint . info () . key , accs . lp_share_acc . info () . key , accs . custody_signer . key , & [] , share_amount ,) ? ; invoke_seeded (& mint_ix , ctx , & accs . custody_signer , None) ? ; Ok (()) }",
          "description": "Token account mint not validated.",
          "attack_scenario": "Attacker substitutes token account for different mint.",
          "real_world_incident": null,
          "secure_fix": "Add constraint: token_account.mint == expected_mint",
          "prevention": "Always validate token account mint matches expected",
          "confidence": 69
        },
        {
          "category": "MEV Protection",
          "vuln_type": "Sandwich Attack Vulnerability",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-034",
          "cwe": "CWE-362",
          "location": "add_liquidity.rs",
          "function_name": "add_liquidity",
          "line_number": 44,
          "vulnerable_code": "pub fn add_liquidity (ctx : & ExecutionContext , accs : & mut AddLiquidity , data : AddLiquidityData ,) -> Result<() > { if * accs . from_mint . info () . key != accs . pool . from { return Err (WrongMint . into ()) ; } if * accs . to_mint . info () . key != accs . pool . to { return Err (WrongMint . into ()) ; } if accs . lp_share_acc . mint != * accs . share_mint . info () . key { return Err (WrongMint . into ()) ; } accs . to_token_custody . verify_derivation (ctx . program_id , & ToCustodyTokenAccountDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . share_mint . verify_derivation (ctx . program_id , & ShareMintDerivationData { pool : * accs . pool . info () . key , } ,) ? ; accs . pool . verify_derivation (ctx . program_id , & MigrationPoolDerivationData { from : accs . pool . from , to : accs . pool . to , } ,) ? ; let to_tokens_in = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount } else { data . amount - (data . amount % 10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) } ; let transfer_ix = spl_token :: instruction :: transfer (& spl_token :: id () , accs . to_lp_acc . info () . key , accs . to_token_custody . info () . key , accs . authority_signer . key , & [] , to_tokens_in ,) ? ; invoke_seeded (& transfer_ix , ctx , & accs . authority_signer , None) ? ; let share_amount = if accs . from_mint . decimals > accs . to_mint . decimals { data . amount . checked_mul (10u64 . pow ((accs . from_mint . decimals - accs . to_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } else { data . amount . checked_div (10u64 . pow ((accs . to_mint . decimals - accs . from_mint . decimals) as u32)) . ok_or (SolitaireError :: InsufficientFunds) ? } ; let mint_ix = spl_token :: instruction :: mint_to (& spl_token :: id () , accs . share_mint . info () . key , accs . lp_share_acc . info () . key , accs . custody_signer . key , & [] , share_amount ,) ? ; invoke_seeded (& mint_ix , ctx , & accs . custody_signer , None) ? ; Ok (()) }",
          "description": "An AMM liquidity operation (add/remove liquidity) has no slippage or deadline protection. An attacker can sandwich the transaction by manipulating the pool ratio before and after the user's transaction, extracting value from the liquidity provider.",
          "attack_scenario": "User submits add_liquidity(1000 USDC, 1 SOL). Attacker front-runs by swapping heavily into SOL, inflating the SOL/USDC ratio. User's liquidity is added at the distorted ratio, receiving fewer LP tokens. Attacker back-runs by swapping back, profiting from the user's unfavorable entry price.",
          "real_world_incident": null,
          "secure_fix": "Add `min_lp_tokens` parameter: `require!(lp_tokens_minted >= min_lp_tokens, ErrorCode::SlippageExceeded)`. Also add a `deadline` timestamp parameter.",
          "prevention": "All liquidity operations should accept min/max output parameters and a deadline. Validate these before executing the operation.",
          "confidence": 69
        }
      ]
    },
    {
      "program": "SPL Governance Chat",
      "category": "PRODUCTION",
      "path": "./real_exploits/spl/governance/chat/program/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 1,
      "findings": [
        {
          "category": "Account Validation",
          "vuln_type": "Type Cosplay",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-004",
          "cwe": "CWE-843",
          "location": "processor.rs",
          "function_name": "process_instruction",
          "line_number": 31,
          "vulnerable_code": "#[doc = \" Processes an instruction\"] pub fn process_instruction (program_id : & Pubkey , accounts : & [AccountInfo] , input : & [u8] ,) -> ProgramResult { msg ! (\"VERSION:{:?}\" , env ! (\"CARGO_PKG_VERSION\")) ; let instruction = GovernanceChatInstruction :: try_from_slice (input) . map_err (| _ | ProgramError :: InvalidInstructionData) ? ; match instruction { GovernanceChatInstruction :: PostMessage { body , is_reply } => { msg ! (\"GOVERNANCE-CHAT-INSTRUCTION: PostMessage\") ; process_post_message (program_id , accounts , body , is_reply) } } }",
          "description": "Account data is deserialized via `try_from_slice` or `try_borrow_data` without validating the account's 8-byte discriminator. An attacker can create a different account type with the same data layout and pass it in place of the expected type. The Solana runtime does not enforce account type identity -- only the program can validate the discriminator. Anchor's `Account<'info, T>` does this automatically; raw AccountInfo does not.",
          "attack_scenario": "Attacker deploys a program that creates Account Type A with a data layout matching Type B. Passes Type A where the program expects Type B. The deserialization succeeds because the byte layout matches, but semantic meanings differ (e.g., a 'balance' field in Type A is actually a 'fee_rate' in Type B).",
          "real_world_incident": null,
          "secure_fix": "Use Anchor's `Account<'info, T>` which auto-validates the 8-byte discriminator, or manually check: `require!(data[0..8] == MyType::DISCRIMINATOR)`",
          "prevention": "Never deserialize account data without first validating the discriminator. Use Anchor's typed wrappers or add manual discriminator checks.",
          "confidence": 59
        }
      ]
    },
    {
      "program": "SPL Account Compression",
      "category": "PRODUCTION",
      "path": "./real_exploits/spl/account-compression/programs/account-compression/src",
      "exploit_type": null,
      "loss": null,
      "expected_detections": [],
      "total_findings": 5,
      "findings": [
        {
          "category": "DeFi Security",
          "vuln_type": "Flash Loan Price Manipulation",
          "severity": 5,
          "severity_label": "CRITICAL",
          "id": "SOL-058",
          "cwe": "CWE-682",
          "location": "lib.rs",
          "function_name": "append",
          "line_number": 473,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: Modify */\n#[doc = \" Context for modifying a tree: inserting, appending, or replacing a leaf in\"] #[doc = \" the existing tree and setting the canopy or finalizing a prepared tree.\"] #[doc = \"\"] #[doc = \" Modification instructions also require the proof to the leaf to be provided\"] #[doc = \" as 32-byte nodes via \\\"remaining accounts\\\".\"] #[derive (Accounts)] pub struct Modify < 'info> { #[account (mut)] #[doc = \" CHECK: This account is validated in the instruction\"] pub merkle_tree : UncheckedAccount<'info> , #[doc = \" Authority that controls write-access to the tree\"] #[doc = \" Typically a program, e.g., the Bubblegum contract validates that leaves are valid NFTs.\"] pub authority : Signer<'info> , #[doc = \" Program used to emit changelogs as cpi instruction data.\"] pub noop : Program<'info, Noop > , }\n/* HANDLER: */\n#[doc = \" This instruction allows the tree's `authority` to append a new leaf to the tree\"] #[doc = \" without having to supply a proof.\"] #[doc = \"\"] #[doc = \" Learn more about SPL\"] #[doc = \" ConcurrentMerkleTree\"] #[doc = \" [here](https://github.com/solana-labs/solana-program-library/tree/master/libraries/concurrent-merkle-tree)\"] pub fn append (ctx : Context<Modify > , leaf : [u8 ; 32]) -> Result<() > { require_eq ! (* ctx . accounts . merkle_tree . owner , crate :: id () , AccountCompressionError :: IncorrectAccountOwner) ; let mut merkle_tree_bytes = ctx . accounts . merkle_tree . try_borrow_mut_data () ? ; let (header_bytes , rest) = merkle_tree_bytes . split_at_mut (CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1) ; let header = ConcurrentMerkleTreeHeader :: try_from_slice (header_bytes) ? ; header . assert_valid_authority (& ctx . accounts . authority . key ()) ? ; let id = ctx . accounts . merkle_tree . key () ; let merkle_tree_size = merkle_tree_get_size (& header) ? ; let (tree_bytes , canopy_bytes) = rest . split_at_mut (merkle_tree_size) ; let change_log_event = merkle_tree_append_leaf (& header , id , tree_bytes , & leaf) ? ; update_canopy (canopy_bytes , header . get_max_depth () , Some (& change_log_event) ,) ? ; wrap_event (& AccountCompressionEvent :: ChangeLog (* change_log_event) , & ctx . accounts . noop ,) }",
          "description": "Price or exchange rate is calculated from spot balances without TWAP or oracle validation. A flash loan can temporarily inflate/deflate pool balances within a single transaction to manipulate the price.",
          "attack_scenario": "Attacker flash-borrows 10M USDC \u2192 dumps into pool \u2192 spot price crashes \u2192 buys cheap at manipulated price \u2192 repays flash loan \u2192 profits.",
          "real_world_incident": {
            "project": "Mango Markets",
            "loss": "$114M",
            "date": "2022-10-11"
          },
          "secure_fix": "Use TWAP oracles (Pyth, Switchboard) instead of spot balances. Add minimum time delays between price reads and actions.",
          "prevention": "Never derive prices from instantaneous pool balances. Use time-weighted averages or signed oracle feeds.",
          "confidence": 80
        },
        {
          "category": "Account Safety",
          "vuln_type": "Raw AccountInfo Without Type Safety",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-ALIAS-02",
          "cwe": "CWE-704",
          "location": "lib.rs",
          "function_name": "CloseTree",
          "line_number": 122,
          "vulnerable_code": "pub merkle_tree: AccountInfo<'info>",
          "description": "Account `merkle_tree` in `CloseTree` uses raw `AccountInfo` which provides no type safety or discriminator checking. The account data can contain anything \u2014 including data from a completely different program.",
          "attack_scenario": "Attacker creates an account with crafted data that mimics the expected layout. Without discriminator checking, the program interprets this data as valid, leading to unauthorized operations.",
          "real_world_incident": {
            "project": "Wormhole Bridge",
            "loss": "$320M",
            "date": "2022-02-02"
          },
          "secure_fix": "Replace `AccountInfo` with a typed Anchor account: `Account<'info, YourType>` which automatically validates the discriminator and owner.",
          "prevention": "Always use typed accounts with discriminator validation.",
          "confidence": 75
        },
        {
          "category": "Logic Security",
          "vuln_type": "Missing State Machine",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-059",
          "cwe": "CWE-841",
          "location": "lib.rs",
          "function_name": "append_canopy_nodes",
          "line_number": 245,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: Modify */\n#[doc = \" Context for modifying a tree: inserting, appending, or replacing a leaf in\"] #[doc = \" the existing tree and setting the canopy or finalizing a prepared tree.\"] #[doc = \"\"] #[doc = \" Modification instructions also require the proof to the leaf to be provided\"] #[doc = \" as 32-byte nodes via \\\"remaining accounts\\\".\"] #[derive (Accounts)] pub struct Modify < 'info> { #[account (mut)] #[doc = \" CHECK: This account is validated in the instruction\"] pub merkle_tree : UncheckedAccount<'info> , #[doc = \" Authority that controls write-access to the tree\"] #[doc = \" Typically a program, e.g., the Bubblegum contract validates that leaves are valid NFTs.\"] pub authority : Signer<'info> , #[doc = \" Program used to emit changelogs as cpi instruction data.\"] pub noop : Program<'info, Noop > , }\n/* HANDLER: */\n#[doc = \" (Devnet only) This instruction pre-initializes the canopy with the specified leaf nodes of the canopy.\"] #[doc = \" This is intended to be used after `prepare_batch_merkle_tree` and in conjunction with the\"] #[doc = \" `init_prepared_tree_with_root` instruction that'll finalize the tree initialization.\"] #[doc = \" The canopy is used to cache the uppermost nodes of the tree, which allows for a smaller\"] #[doc = \" proof size when updating the tree. The canopy should be filled with the necessary nodes\"] #[doc = \" before calling `init_prepared_tree_with_root`. You may call this instruction multiple\"] #[doc = \" times to fill the canopy with the necessary nodes. The canopy may be filled with the\"] #[doc = \" nodes in any order. The already filled nodes may be replaced with new nodes before calling\"] #[doc = \" `init_prepared_tree_with_root` if the step was done in error.\"] #[doc = \" The canopy should be filled with all the nodes that are to the left of the rightmost\"] #[doc = \" leaf of the tree before calling `init_prepared_tree_with_root`. The canopy should not\"] #[doc = \" contain any nodes to the right of the rightmost leaf of the tree.\"] #[doc = \" This instruction calculates and filles in all the canopy nodes \\\"above\\\" the provided ones.\"] #[doc = \" The validation of the canopy is done in the `init_prepared_tree_with_root` instruction.\"] pub fn append_canopy_nodes (ctx : Context<Modify > , start_index : u32 , canopy_nodes : Vec<[u8 ; 32] > ,) -> Result<() > { require_eq ! (* ctx . accounts . merkle_tree . owner , crate :: id () , AccountCompressionError :: IncorrectAccountOwner) ; let mut merkle_tree_bytes = ctx . accounts . merkle_tree . try_borrow_mut_data () ? ; let (header_bytes , rest) = merkle_tree_bytes . split_at_mut (CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1) ; let header = ConcurrentMerkleTreeHeader :: try_from_slice (header_bytes) ? ; header . assert_valid_authority (& ctx . accounts . authority . key ()) ? ; header . assert_is_batch_initialized () ? ; let merkle_tree_size = merkle_tree_get_size (& header) ? ; let (tree_bytes , canopy_bytes) = rest . split_at_mut (merkle_tree_size) ; require ! (tree_bytes_uninitialized (tree_bytes) , AccountCompressionError :: TreeAlreadyInitialized) ; set_canopy_leaf_nodes (canopy_bytes , header . get_max_depth () , start_index , & canopy_nodes ,) }",
          "description": "Multi-step instruction flow (init\u2192deposit\u2192finalize) lacks a state machine to enforce ordering. Instructions can be called out-of-order, skipping required preconditions.",
          "attack_scenario": "Protocol has init\u2192deposit\u2192finalize flow. Attacker calls finalize directly without depositing, claiming rewards without providing collateral.",
          "real_world_incident": null,
          "secure_fix": "Add an enum State { Initialized, Active, Finalized } and validate transitions: `require!(account.state == State::Active)`.",
          "prevention": "All multi-step processes need explicit state tracking with validated transitions.",
          "confidence": 70
        },
        {
          "category": "Account Validation",
          "vuln_type": "Unvalidated remaining_accounts",
          "severity": 4,
          "severity_label": "HIGH",
          "id": "SOL-063",
          "cwe": "CWE-20",
          "location": "lib.rs",
          "function_name": "init_prepared_tree_with_root",
          "line_number": 289,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: Modify */\n#[doc = \" Context for modifying a tree: inserting, appending, or replacing a leaf in\"] #[doc = \" the existing tree and setting the canopy or finalizing a prepared tree.\"] #[doc = \"\"] #[doc = \" Modification instructions also require the proof to the leaf to be provided\"] #[doc = \" as 32-byte nodes via \\\"remaining accounts\\\".\"] #[derive (Accounts)] pub struct Modify < 'info> { #[account (mut)] #[doc = \" CHECK: This account is validated in the instruction\"] pub merkle_tree : UncheckedAccount<'info> , #[doc = \" Authority that controls write-access to the tree\"] #[doc = \" Typically a program, e.g., the Bubblegum contract validates that leaves are valid NFTs.\"] pub authority : Signer<'info> , #[doc = \" Program used to emit changelogs as cpi instruction data.\"] pub noop : Program<'info, Noop > , }\n/* HANDLER: */\n#[doc = \" (Devnet only) Initializes a prepared tree with a root and a rightmost leaf. The rightmost leaf is used to\"] #[doc = \" verify the canopy if the tree has it. Before calling this instruction, the tree should be\"] #[doc = \" prepared with `prepare_batch_merkle_tree` and the canopy should be filled with the necessary\"] #[doc = \" nodes with `append_canopy_nodes` (if the canopy is used). This method should be used for\"] #[doc = \" batch creation of trees. The indexing of such batches should be done off-chain. The\"] #[doc = \" programs calling this instruction should take care of ensuring the indexing is possible.\"] #[doc = \" For example, staking may be required to ensure the tree creator has some responsibility\"] #[doc = \" for what is being indexed. If indexing is not possible, there should be a mechanism to\"] #[doc = \" penalize the tree creator.\"] pub fn init_prepared_tree_with_root (ctx : Context<Modify > , root : [u8 ; 32] , rightmost_leaf : [u8 ; 32] , rightmost_index : u32 ,) -> Result<() > { require_eq ! (* ctx . accounts . merkle_tree . owner , crate :: id () , AccountCompressionError :: IncorrectAccountOwner) ; let mut merkle_tree_bytes = ctx . accounts . merkle_tree . try_borrow_mut_data () ? ; let (header_bytes , rest) = merkle_tree_bytes . split_at_mut (CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1) ; let header = ConcurrentMerkleTreeHeader :: try_from_slice (header_bytes) ? ; header . assert_valid_authority (& ctx . accounts . authority . key ()) ? ; header . assert_is_batch_initialized () ? ; let merkle_tree_size = merkle_tree_get_size (& header) ? ; let (tree_bytes , canopy_bytes) = rest . split_at_mut (merkle_tree_size) ; check_canopy_root (canopy_bytes , & root , header . get_max_depth ()) ? ; check_canopy_no_nodes_to_right_of_index (canopy_bytes , header . get_max_depth () , rightmost_index ,) ? ; let mut proof = vec ! [] ; for node in ctx . remaining_accounts . iter () { proof . push (node . key () . to_bytes ()) ; } fill_in_proof_from_canopy (canopy_bytes , header . get_max_depth () , rightmost_index , & mut proof ,) ? ; assert_eq ! (proof . len () , header . get_max_depth () as usize) ; let id = ctx . accounts . merkle_tree . key () ; let args = & InitializeWithRootArgs { root , rightmost_leaf , proof_vec : proof , index : rightmost_index , } ; let change_log = merkle_tree_initialize_with_root (& header , id , tree_bytes , args) ? ; update_canopy (canopy_bytes , header . get_max_depth () , Some (& change_log)) ? ; wrap_event (& AccountCompressionEvent :: ChangeLog (* change_log) , & ctx . accounts . noop ,) }",
          "description": "The context uses `remaining_accounts` without validating the accounts' ownership, signer status, or expected keys. These accounts bypass Anchor's automatic validation, so ANY account can be passed.",
          "attack_scenario": "Program reads remaining_accounts[0] as a user's token account without checking owner. Attacker passes a token account they own, redirecting funds or spoofing identity.",
          "real_world_incident": null,
          "secure_fix": "Validate each remaining_account: check owner, key, signer status. Prefer typed accounts in the Accounts struct over remaining_accounts.",
          "prevention": "Minimize remaining_accounts usage. When required, validate each account's owner, key, and writable/signer constraints explicitly.",
          "confidence": 70
        },
        {
          "category": "Input Validation",
          "vuln_type": "Unbounded Input Length",
          "severity": 3,
          "severity_label": "MEDIUM",
          "id": "SOL-062",
          "cwe": "CWE-400",
          "location": "lib.rs",
          "function_name": "append_canopy_nodes",
          "line_number": 245,
          "vulnerable_code": "/* ACCOUNTS_STRUCT: Modify */\n#[doc = \" Context for modifying a tree: inserting, appending, or replacing a leaf in\"] #[doc = \" the existing tree and setting the canopy or finalizing a prepared tree.\"] #[doc = \"\"] #[doc = \" Modification instructions also require the proof to the leaf to be provided\"] #[doc = \" as 32-byte nodes via \\\"remaining accounts\\\".\"] #[derive (Accounts)] pub struct Modify < 'info> { #[account (mut)] #[doc = \" CHECK: This account is validated in the instruction\"] pub merkle_tree : UncheckedAccount<'info> , #[doc = \" Authority that controls write-access to the tree\"] #[doc = \" Typically a program, e.g., the Bubblegum contract validates that leaves are valid NFTs.\"] pub authority : Signer<'info> , #[doc = \" Program used to emit changelogs as cpi instruction data.\"] pub noop : Program<'info, Noop > , }\n/* HANDLER: */\n#[doc = \" (Devnet only) This instruction pre-initializes the canopy with the specified leaf nodes of the canopy.\"] #[doc = \" This is intended to be used after `prepare_batch_merkle_tree` and in conjunction with the\"] #[doc = \" `init_prepared_tree_with_root` instruction that'll finalize the tree initialization.\"] #[doc = \" The canopy is used to cache the uppermost nodes of the tree, which allows for a smaller\"] #[doc = \" proof size when updating the tree. The canopy should be filled with the necessary nodes\"] #[doc = \" before calling `init_prepared_tree_with_root`. You may call this instruction multiple\"] #[doc = \" times to fill the canopy with the necessary nodes. The canopy may be filled with the\"] #[doc = \" nodes in any order. The already filled nodes may be replaced with new nodes before calling\"] #[doc = \" `init_prepared_tree_with_root` if the step was done in error.\"] #[doc = \" The canopy should be filled with all the nodes that are to the left of the rightmost\"] #[doc = \" leaf of the tree before calling `init_prepared_tree_with_root`. The canopy should not\"] #[doc = \" contain any nodes to the right of the rightmost leaf of the tree.\"] #[doc = \" This instruction calculates and filles in all the canopy nodes \\\"above\\\" the provided ones.\"] #[doc = \" The validation of the canopy is done in the `init_prepared_tree_with_root` instruction.\"] pub fn append_canopy_nodes (ctx : Context<Modify > , start_index : u32 , canopy_nodes : Vec<[u8 ; 32] > ,) -> Result<() > { require_eq ! (* ctx . accounts . merkle_tree . owner , crate :: id () , AccountCompressionError :: IncorrectAccountOwner) ; let mut merkle_tree_bytes = ctx . accounts . merkle_tree . try_borrow_mut_data () ? ; let (header_bytes , rest) = merkle_tree_bytes . split_at_mut (CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1) ; let header = ConcurrentMerkleTreeHeader :: try_from_slice (header_bytes) ? ; header . assert_valid_authority (& ctx . accounts . authority . key ()) ? ; header . assert_is_batch_initialized () ? ; let merkle_tree_size = merkle_tree_get_size (& header) ? ; let (tree_bytes , canopy_bytes) = rest . split_at_mut (merkle_tree_size) ; require ! (tree_bytes_uninitialized (tree_bytes) , AccountCompressionError :: TreeAlreadyInitialized) ; set_canopy_leaf_nodes (canopy_bytes , header . get_max_depth () , start_index , & canopy_nodes ,) }",
          "description": "Instruction accepts Vec<> input without length bounds. An attacker can pass an extremely large array to consume all compute units or cause excessive memory allocation.",
          "attack_scenario": "Attacker passes a Vec with 10,000 elements. The instruction tries to iterate and runs out of compute units, DOS-ing the program.",
          "real_world_incident": null,
          "secure_fix": "Add length validation: `require!(items.len() <= MAX_ITEMS)`. Define reasonable constants for maximum array sizes.",
          "prevention": "Always validate collection lengths at instruction entry. Define MAX_* constants for all bounded collections.",
          "confidence": 60
        }
      ]
    }
  ]
}