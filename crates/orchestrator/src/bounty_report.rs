//! Bug Bounty Report Generator
//!
//! Produces submission-ready markdown reports formatted for platforms like
//! Immunefi, HackerOne, and Code4rena. Each finding includes a clear title,
//! severity, CWE mapping, reproduction steps, impact analysis, and fix
//! recommendation â€” everything a triager needs to validate and pay out.

use crate::audit_pipeline::{AuditReport, ConfirmedExploit};

pub struct BountyReportGenerator;

impl BountyReportGenerator {
    /// Generate a bounty-submission-ready markdown report.
    ///
    /// Filters to exploitable findings (severity >= Medium) and formats each
    /// one as a standalone submission with PoC steps and CWE/CVSS metadata.
    pub fn generate(report: &AuditReport) -> String {
        let mut md = String::with_capacity(8192);

        // --- Header ---
        md.push_str("# Bug Bounty Report\n\n");
        md.push_str(&format!("**Target Program:** `{}`\n\n", report.program_id));
        md.push_str(&format!("**Generated:** {}\n\n", report.timestamp));
        md.push_str(&format!(
            "**Security Score:** {}/100\n\n",
            report.security_score
        ));

        // --- Summary table ---
        let exploitable: Vec<&ConfirmedExploit> =
            report.exploits.iter().filter(|e| e.severity >= 3).collect();

        md.push_str("## Summary\n\n");
        md.push_str("| Severity | Count |\n");
        md.push_str("|----------|-------|\n");
        md.push_str(&format!(
            "| Critical | {} |\n",
            exploitable.iter().filter(|e| e.severity >= 5).count()
        ));
        md.push_str(&format!(
            "| High     | {} |\n",
            exploitable.iter().filter(|e| e.severity == 4).count()
        ));
        md.push_str(&format!(
            "| Medium   | {} |\n",
            exploitable.iter().filter(|e| e.severity == 3).count()
        ));
        md.push_str(&format!(
            "| **Total Exploitable** | **{}** |\n\n",
            exploitable.len()
        ));

        if exploitable.is_empty() {
            md.push_str("> No exploitable findings detected. The program appears secure.\n");
            return md;
        }

        // --- Individual findings ---
        md.push_str("---\n\n");
        md.push_str("## Findings\n\n");

        for (i, exploit) in exploitable.iter().enumerate() {
            md.push_str(&Self::render_finding(i + 1, exploit));
        }

        // --- Footer ---
        md.push_str("---\n\n");
        md.push_str("## Methodology\n\n");
        md.push_str("This report was generated by an automated security analysis pipeline using:\n\n");
        md.push_str("- **Static Analysis** â€” AST-based pattern matching (52 Solana vulnerability patterns)\n");
        md.push_str("- **Formal Verification** â€” Z3 SMT solver + Kani CBMC model checker\n");
        md.push_str("- **Bytecode Verification** â€” Certora Solana Prover (SBF bytecode)\n");
        md.push_str("- **Concolic Analysis** â€” WACANA engine (WASM/SBF path exploration)\n");
        md.push_str("- **Fuzzing** â€” Trident stateful fuzzing + FuzzDelSol binary fuzzing\n");
        md.push_str("- **AI Enhancement** â€” Multi-LLM consensus for false-positive reduction\n\n");
        md.push_str(
            "Each finding has been cross-validated by multiple engines. \
             Confidence scores reflect the number of independent confirmations.\n\n",
        );
        md.push_str(&format!("*Report generated at {}*\n", report.timestamp));

        md
    }

    fn render_finding(index: usize, e: &ConfirmedExploit) -> String {
        let mut s = String::with_capacity(2048);

        // Title
        let severity_emoji = match e.severity {
            5 => "ðŸ”´",
            4 => "ðŸŸ ",
            3 => "ðŸŸ¡",
            _ => "ðŸ”µ",
        };
        s.push_str(&format!(
            "### {severity_emoji} Finding #{index}: {vuln_type}\n\n",
            severity_emoji = severity_emoji,
            index = index,
            vuln_type = e.vulnerability_type,
        ));

        // Metadata table
        s.push_str("| Field | Value |\n");
        s.push_str("|-------|-------|\n");
        s.push_str(&format!(
            "| **Severity** | {} ({}/5) |\n",
            e.severity_label, e.severity
        ));
        s.push_str(&format!("| **ID** | `{}` |\n", e.id));
        if let Some(ref cwe) = e.cwe {
            s.push_str(&format!("| **CWE** | {} |\n", cwe));
        }
        s.push_str(&format!("| **Category** | {} |\n", e.category));
        s.push_str(&format!(
            "| **Location** | `{}:{}` |\n",
            e.instruction, e.line_number
        ));
        s.push_str(&format!("| **Confidence** | {}% |\n", e.confidence_score));
        s.push_str(&format!(
            "| **Exploit Complexity** | {} |\n",
            e.exploit_complexity
        ));
        s.push('\n');

        // Description
        s.push_str("#### Description\n\n");
        s.push_str(&e.description);
        s.push_str("\n\n");

        // AI-enhanced description if available
        if let Some(ref enhanced) = e.description_enhanced {
            s.push_str(enhanced);
            s.push_str("\n\n");
        }

        // Impact / Attack scenario
        s.push_str("#### Impact\n\n");
        s.push_str(&e.attack_scenario);
        s.push_str("\n\n");

        if let Some(ref enhanced_attack) = e.attack_scenario_enhanced {
            s.push_str(enhanced_attack);
            s.push_str("\n\n");
        }

        // PoC / Reproduction steps
        s.push_str("#### Proof of Concept / Reproduction Steps\n\n");
        for (step_idx, step) in e.exploit_steps.iter().enumerate() {
            s.push_str(&format!("{}. {}\n", step_idx + 1, step));
        }
        s.push('\n');

        if let Some(ref receipt) = e.proof_receipt {
            s.push_str("**On-chain proof:**\n\n");
            s.push_str(&format!(
                "- TX Signature: `{}`\n",
                receipt.transaction_signature
            ));
            s.push_str(&format!(
                "- Funds drained: {:.4} SOL\n",
                receipt.funds_drained_lamports as f64 / 1e9
            ));
            s.push('\n');
        }

        // Historical context
        if let Some(ref context) = e.historical_hack_context {
            s.push_str("#### Historical Precedent\n\n");
            s.push_str(&format!("> {}\n\n", context));
        }

        // Recommended fix
        s.push_str("#### Recommended Fix\n\n");
        if let Some(ref diff) = e.mitigation_diff {
            s.push_str("```diff\n");
            s.push_str(diff);
            s.push_str("\n```\n\n");
        } else {
            s.push_str(&format!("{}\n\n", e.secure_fix));
        }

        if let Some(ref fix_enhanced) = e.fix_suggestion_enhanced {
            s.push_str(fix_enhanced);
            s.push_str("\n\n");
        }

        s.push_str(&format!("**Prevention:** {}\n\n", e.prevention));

        s.push_str("---\n\n");
        s
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::audit_pipeline::{ConfirmedExploit, ExploitState};

    fn stub_report() -> AuditReport {
        AuditReport {
            program_id: "TestProg111111111111111111111111111111111111".into(),
            total_exploits: 1,
            critical_count: 1,
            high_count: 0,
            medium_count: 0,
            exploits: vec![ConfirmedExploit {
                id: "SOL-AUTH-001".into(),
                category: "Authentication".into(),
                vulnerability_type: "Missing Signer Validation".into(),
                severity: 5,
                severity_label: "CRITICAL".into(),
                cwe: Some("CWE-862".into()),
                instruction: "withdraw".into(),
                line_number: 42,
                description: "No signer check on authority account.".into(),
                attack_scenario: "Attacker calls withdraw without signing.".into(),
                secure_fix: "Add require!(ctx.accounts.authority.is_signer)".into(),
                prevention: "Enforce signer checks on all privileged instructions.".into(),
                error_code: 0,
                proof_tx: "UNPROVEN_STATIC_DETECTION".into(),
                attack_simulation: None,
                state: ExploitState::Discovered,
                fix_metadata: None,
                confidence_score: 85,
                confidence_reasoning: vec!["AST detection with line number (+10), named function (+5)".into()],
                risk_priority: "CRITICAL".into(),
                priority_index: 1,
                exploit_gas_estimate: 5000,
                exploit_steps: vec![
                    "Craft withdraw IX without signer".into(),
                    "Submit to program".into(),
                    "Observe funds drained".into(),
                ],
                exploit_complexity: "LOW".into(),
                value_at_risk_usd: 1_000_000.0,
                cve_reference: None,
                historical_hack_context: Some("Wormhole $320M exploit".into()),
                mitigation_diff: None,
                proof_receipt: None,
                vulnerability_type_enhanced: None,
                description_enhanced: None,
                attack_scenario_enhanced: None,
                fix_suggestion_enhanced: None,
                economic_impact: None,
                ai_explanation: None,
            }],
            timestamp: "2025-01-01T00:00:00Z".into(),
            security_score: 20,
            deployment_advice: None,
            logic_invariants: vec![],
            enhanced_report: None,
            kani_report: None,
            certora_report: None,
            wacana_report: None,
            trident_report: None,
            fuzzdelsol_report: None,
            sec3_report: None,
            l3x_report: None,
            geiger_report: None,
            anchor_report: None,
            crux_report: None,
            engine_status: Default::default(),
            proof_engine_results: Vec::new(),
            logic_integrity: 1.0,
            total_value_at_risk_usd: 1_000_000.0,
            scan_scope: vec![],
            standards_compliance: std::collections::HashMap::new(),
            model_consensus: vec![],
            overall_risk_score: 9.0,
            technical_risk: 8.0,
            financial_risk: 9.0,
            scan_command: "audit --bug-bounty".into(),
            network_status: "CONNECTED".into(),
        }
    }

    #[test]
    fn test_bounty_report_contains_finding() {
        let report = stub_report();
        let md = BountyReportGenerator::generate(&report);
        assert!(md.contains("Missing Signer Validation"));
        assert!(md.contains("CWE-862"));
        assert!(md.contains("Proof of Concept"));
        assert!(md.contains("Recommended Fix"));
    }

    #[test]
    fn test_bounty_report_filters_low_severity() {
        let mut report = stub_report();
        report.exploits[0].severity = 2; // LOW
        let md = BountyReportGenerator::generate(&report);
        assert!(md.contains("No exploitable findings"));
    }
}
