use crate::VulnerabilityFinding;
use crate::ast_checks;

#[derive(Debug, Clone)]
pub struct VulnerabilityPattern {
    pub id: String,
    pub name: String,
    pub severity: u8,
    pub description: String,
    pub example: String,
    pub mitigation: String,
    pub checker: fn(&str) -> Option<VulnerabilityFinding>,
    /// Per-detector base confidence (0-100). Calibrated by detection approach:
    /// - 85-95: AST-level checks, provable patterns (missing signer, unchecked CPI)
    /// - 70-84: Strong heuristic patterns (overflow, type cosplay)
    /// - 55-69: Pattern-match heuristics (informational, stylistic)
    pub base_confidence: u8,
}

impl VulnerabilityPattern {
    pub fn new(
        id: &str,
        name: &str,
        severity: u8,
        checker: fn(&str) -> Option<VulnerabilityFinding>,
    ) -> Self {
        // Default confidence based on severity as a reasonable heuristic
        let base_confidence = match severity {
            5 => 85,
            4 => 75,
            3 => 65,
            2 => 60,
            _ => 55,
        };
        Self {
            id: id.to_string(),
            name: name.to_string(),
            severity,
            description: String::new(),
            example: String::new(),
            mitigation: String::new(),
            checker,
            base_confidence,
        }
    }

    /// Create a pattern with explicitly calibrated confidence.
    pub fn with_confidence(
        id: &str,
        name: &str,
        severity: u8,
        confidence: u8,
        checker: fn(&str) -> Option<VulnerabilityFinding>,
    ) -> Self {
        Self {
            id: id.to_string(),
            name: name.to_string(),
            severity,
            description: String::new(),
            example: String::new(),
            mitigation: String::new(),
            checker,
            base_confidence: confidence,
        }
    }
}

pub struct VulnerabilityDatabase {
    pub patterns: Vec<VulnerabilityPattern>,
}

impl VulnerabilityDatabase {
    pub fn load() -> Self {
        Self {
            patterns: get_default_patterns(),
        }
    }

    pub fn patterns(&self) -> &[VulnerabilityPattern] {
        &self.patterns
    }
}

pub fn get_default_patterns() -> Vec<VulnerabilityPattern> {
    vec![
        // --- auth & authorization (high confidence — strong AST signals) ---
        VulnerabilityPattern::with_confidence("SOL-001", "Missing Signer Check", 5, 90, check_missing_signer),
        VulnerabilityPattern::with_confidence("SOL-002", "Integer Overflow", 4, 80, check_integer_overflow),
        VulnerabilityPattern::with_confidence("SOL-003", "Missing Owner Check", 5, 90, check_missing_owner),
        VulnerabilityPattern::with_confidence("SOL-004", "Type Cosplay", 5, 85, check_type_cosplay),
        VulnerabilityPattern::with_confidence("SOL-005", "Arbitrary CPI", 5, 88, check_arbitrary_cpi),
        VulnerabilityPattern::new(
            "SOL-006",
            "Duplicate Mutable Accounts",
            4,
            check_duplicate_accounts,
        ),
        VulnerabilityPattern::new("SOL-007", "Bump Seed Issues", 4, check_bump_seed),
        VulnerabilityPattern::new("SOL-008", "PDA Sharing", 4, check_pda_sharing),
        VulnerabilityPattern::new(
            "SOL-009",
            "Account Closing Issues",
            4,
            check_closing_accounts,
        ),
        VulnerabilityPattern::new("SOL-010", "Sysvar Address Issues", 3, check_sysvar_address),
        VulnerabilityPattern::new("SOL-011", "Initialization Issues", 4, check_initialization),
        VulnerabilityPattern::new(
            "SOL-012",
            "Account Data Mismatch",
            4,
            check_account_data_matching,
        ),
        // --- additional patterns (13-52) ---
        VulnerabilityPattern::new("SOL-013", "Missing Rent Exemption", 3, check_rent_exemption),
        VulnerabilityPattern::new(
            "SOL-014",
            "Unsafe Deserialization",
            4,
            check_unsafe_deserialization,
        ),
        VulnerabilityPattern::new("SOL-015", "Missing Program ID Check", 5, check_program_id),
        VulnerabilityPattern::new(
            "SOL-016",
            "Unchecked Return Value",
            4,
            check_unchecked_return,
        ),
        VulnerabilityPattern::new("SOL-017", "Reentrancy Risk", 5, check_reentrancy),
        VulnerabilityPattern::new("SOL-018", "Flash Loan Attack", 5, check_flash_loan),
        VulnerabilityPattern::new(
            "SOL-019",
            "Oracle Manipulation",
            5,
            check_oracle_manipulation,
        ),
        VulnerabilityPattern::new("SOL-020", "Price Stale Data", 4, check_stale_oracle),
        VulnerabilityPattern::new("SOL-021", "Mint Authority Issues", 5, check_mint_authority),
        VulnerabilityPattern::new(
            "SOL-022",
            "Freeze Authority Issues",
            4,
            check_freeze_authority,
        ),
        VulnerabilityPattern::new(
            "SOL-023",
            "Token Account Confusion",
            4,
            check_token_account_confusion,
        ),
        VulnerabilityPattern::new(
            "SOL-024",
            "Missing Token Validation",
            4,
            check_token_validation,
        ),
        VulnerabilityPattern::new("SOL-025", "Lamport Balance Drain", 5, check_lamport_drain),
        VulnerabilityPattern::new(
            "SOL-026",
            "Cross-Program Invocation Depth",
            3,
            check_cpi_depth,
        ),
        VulnerabilityPattern::new(
            "SOL-027",
            "Missing Seeds Validation",
            4,
            check_seeds_validation,
        ),
        VulnerabilityPattern::new(
            "SOL-028",
            "Account Resurrection",
            4,
            check_account_resurrection,
        ),
        VulnerabilityPattern::new(
            "SOL-029",
            "Missing Close Authority",
            4,
            check_close_authority,
        ),
        VulnerabilityPattern::new(
            "SOL-030",
            "Privilege Escalation",
            5,
            check_privilege_escalation,
        ),
        VulnerabilityPattern::new(
            "SOL-031",
            "Unauthorized Token Mint",
            5,
            check_unauthorized_mint,
        ),
        VulnerabilityPattern::new("SOL-032", "Missing Decimals Check", 3, check_decimals),
        VulnerabilityPattern::new("SOL-033", "Slippage Attack", 4, check_slippage),
        VulnerabilityPattern::new("SOL-034", "Sandwich Attack", 4, check_sandwich_attack),
        VulnerabilityPattern::new("SOL-035", "Front-Running", 4, check_frontrunning),
        VulnerabilityPattern::new(
            "SOL-036",
            "Missing Amount Validation",
            4,
            check_amount_validation,
        ),
        VulnerabilityPattern::new(
            "SOL-037",
            "Division Before Multiplication",
            3,
            check_div_before_mul,
        ),
        VulnerabilityPattern::new("SOL-038", "Precision Loss", 4, check_precision_loss),
        VulnerabilityPattern::new("SOL-039", "Rounding Errors", 3, check_rounding_errors),
        VulnerabilityPattern::new("SOL-040", "Missing Zero Check", 3, check_zero_check),
        VulnerabilityPattern::new(
            "SOL-041",
            "Unrestricted Transfer",
            5,
            check_unrestricted_transfer,
        ),
        VulnerabilityPattern::new(
            "SOL-042",
            "Missing Pause Mechanism",
            3,
            check_pause_mechanism,
        ),
        VulnerabilityPattern::new("SOL-043", "Hardcoded Address", 1, check_hardcoded_address),
        VulnerabilityPattern::new("SOL-044", "Missing Event Emission", 1, check_event_emission),
        VulnerabilityPattern::new("SOL-045", "Unsafe Math Operations", 4, check_unsafe_math),
        VulnerabilityPattern::new("SOL-046", "Time Manipulation", 3, check_time_manipulation),
        VulnerabilityPattern::new("SOL-047", "Missing Access Control", 5, check_access_control),
        VulnerabilityPattern::new("SOL-048", "Account Hijacking", 5, check_account_hijacking),
        VulnerabilityPattern::new("SOL-049", "LP Token Manipulation", 4, check_lp_manipulation),
        VulnerabilityPattern::new(
            "SOL-050",
            "Reward Calculation Error",
            4,
            check_reward_calculation,
        ),
        VulnerabilityPattern::new("SOL-051", "Missing Deadline Check", 3, check_deadline),
        VulnerabilityPattern::new("SOL-052", "Governance Attack", 4, check_governance_attack),
        // === SOL-053 to SOL-072: Advanced Solana-Specific Detectors ===
        VulnerabilityPattern::new("SOL-053", "Close Account Resurrection", 5, check_close_resurrection),
        VulnerabilityPattern::new("SOL-054", "Program Impersonation", 5, check_program_impersonation),
        VulnerabilityPattern::new("SOL-055", "Token2022 Transfer Hook Risk", 4, check_token2022_hook),
        VulnerabilityPattern::new("SOL-056", "Token2022 Fee Mismatch", 4, check_token2022_fees),
        VulnerabilityPattern::new("SOL-057", "Permanent Delegate Exposure", 4, check_permanent_delegate),
        VulnerabilityPattern::new("SOL-058", "Flash Loan Price Manipulation", 5, check_flash_loan_v2),
        VulnerabilityPattern::new("SOL-059", "Missing State Machine", 4, check_state_machine),
        VulnerabilityPattern::new("SOL-060", "Event Log Spoofing", 3, check_event_spoofing),
        VulnerabilityPattern::new("SOL-061", "CU Exhaustion Partial State", 4, check_cu_exhaustion),
        VulnerabilityPattern::new("SOL-062", "Unbounded Input Length", 3, check_unbounded_input),
        VulnerabilityPattern::new("SOL-063", "Unvalidated remaining_accounts", 4, check_remaining_accounts),
        VulnerabilityPattern::new("SOL-064", "Governance Bypass Risk", 4, check_governance_bypass),
        VulnerabilityPattern::new("SOL-065", "PDA Seed Collision Risk", 3, check_seed_collision),
        VulnerabilityPattern::new("SOL-066", "Insufficient MEV Protection", 3, check_mev_protection),
        VulnerabilityPattern::new("SOL-067", "Single Wallet Upgrade Authority", 4, check_upgrade_authority_risk),
        VulnerabilityPattern::new("SOL-068", "Unvalidated Freeze Authority", 3, check_freeze_auth_risk),
        VulnerabilityPattern::new("SOL-069", "Cross-IX Duplicate Accounts", 5, check_cross_ix_duplicates),
        VulnerabilityPattern::new("SOL-070", "Legacy vs V0 Transaction Risk", 3, check_versioned_tx),
        VulnerabilityPattern::new("SOL-071", "Lookup Table Trust Risk", 3, check_alt_validation),
        VulnerabilityPattern::new("SOL-072", "Missing Slippage Cap", 4, check_slippage_cap),
    ]
}

fn check_missing_signer(code: &str) -> Option<VulnerabilityFinding> {
    // Primary: AST-based analysis using syn
    if !ast_checks::ast_has_missing_signer(code) {
        return None;
    }

    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");
    if is_test {
        return None;
    }

    Some(VulnerabilityFinding {
        category: "Authentication".to_string(),
        vuln_type: "Missing Signer Check".to_string(),
        severity: 5,
        severity_label: "CRITICAL".to_string(),
        id: "SOL-001".to_string(),
        cwe: Some("CWE-287".to_string()),
        location: String::new(),
        function_name: String::new(),
        line_number: 0,
        vulnerable_code: String::new(),
        description: "An authority/admin/owner account is passed as raw `AccountInfo<'info>` without enforcing `is_signer`. The Solana runtime will NOT check this — any pubkey can be passed, allowing anyone to impersonate the privileged role. Use `Signer<'info>` or add `#[account(signer)]` to enforce the runtime check.".to_string(),
        attack_scenario: "Attacker constructs a transaction passing their own pubkey as the `authority` AccountInfo. Since there is no `Signer<'info>` constraint or `require!(authority.is_signer)` guard, the runtime accepts the instruction. The attacker then executes privileged operations (withdraw, set_authority, etc.) as if they were the real authority.".to_string(),
        real_world_incident: Some(crate::Incident { project: "Wormhole".to_string(), loss: "$320M".to_string(), date: "2022-02-02".to_string() }),
        secure_fix: "Replace `pub authority: AccountInfo<'info>` with `pub authority: Signer<'info>`, or add `#[account(signer)]`. For Anchor programs, also add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the account being protected.".to_string(),
        confidence: 85,
        prevention: "Never use raw AccountInfo for accounts that must be signers. Always use Signer<'info> for authority/admin/owner accounts in Anchor.".to_string(),
    })
}

fn check_integer_overflow(code: &str) -> Option<VulnerabilityFinding> {
    // Primary: AST-based analysis
    if !ast_checks::ast_has_integer_overflow(code) {
        return None;
    }

    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");
    if is_test {
        return None;
    }

    Some(VulnerabilityFinding {
        category: "Arithmetic".to_string(),
        vuln_type: "Integer Overflow/Underflow".to_string(),
        severity: 4,
        severity_label: "HIGH".to_string(),
        id: "SOL-002".to_string(),
        cwe: Some("CWE-190".to_string()),
        location: String::new(),
        function_name: String::new(),
        line_number: 0,
        vulnerable_code: String::new(),
        description: "Arithmetic on u64/u128 in a financial context (amount, balance, fee, reward) without `checked_*` or `saturating_*` methods. Solana's BPF runtime uses release-mode compilation where integer arithmetic wraps silently on overflow.".to_string(),
        attack_scenario: "Attacker calls the instruction with `amount = u64::MAX - current_balance + 1`. The addition wraps to a small number, but the internal accounting records a massive deposit.".to_string(),
        real_world_incident: Some(crate::Incident {
            project: "DeFi Protocols".to_string(),
            loss: "Various".to_string(),
            date: "2021-2023".to_string(),
        }),
        secure_fix: "Replace `a + b` with `a.checked_add(b).ok_or(ErrorCode::MathOverflow)?`. Add `overflow-checks = true` under `[profile.release]` in Cargo.toml.".to_string(),
        confidence: 80,
        prevention: "All arithmetic on financial values must use `checked_*` methods. Set `overflow-checks = true` in release profile.".to_string(),
    })
}

fn check_missing_owner(code: &str) -> Option<VulnerabilityFinding> {
    // Primary: AST-based analysis
    if !ast_checks::ast_has_missing_owner(code) {
        return None;
    }

    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");
    if is_test {
        return None;
    }

    Some(VulnerabilityFinding {
        category: "Authorization".to_string(),
        vuln_type: "Missing Owner Check".to_string(),
        severity: 5,
        severity_label: "CRITICAL".to_string(),
        id: "SOL-003".to_string(),
        cwe: Some("CWE-285".to_string()),
        location: String::new(),
        function_name: String::new(),
        line_number: 0,
        vulnerable_code: String::new(),
        description: "Account data is read via raw `AccountInfo::try_borrow_data()` without \
            validating `account.owner == expected_program_id`. An attacker creates a fake \
            account under their own program with crafted data."
            .to_string(),
        attack_scenario: "Attacker deploys a program that creates an account with data \
            mimicking a vault. Since the victim program doesn't check `.owner`, it \
            processes the fake account data as legitimate."
            .to_string(),
        real_world_incident: Some(crate::Incident {
            project: "Cashio".to_string(),
            loss: "$52M".to_string(),
            date: "2022-03-23".to_string(),
        }),
        secure_fix: "Use Anchor's `Account<'info, T>` which validates `account.owner == \
            program_id` automatically. For native programs: \
            `require!(account.owner == &expected_program_id, ErrorCode::InvalidOwner)`"
            .to_string(),
        confidence: 85,
        prevention: "Never trust data from raw AccountInfo without first checking `.owner`. \
            Use Anchor's typed wrappers.".to_string(),
    })
}

fn check_type_cosplay(code: &str) -> Option<VulnerabilityFinding> {
    // raw deserialization without discriminator check — Account<T> handles this
    let raw_deserialize = (code.contains("try_from_slice") || code.contains("deserialize("))
        && !code.contains("discriminator")
        && !code.contains("DISCRIMINATOR")
        && !code.contains("Account<"); // Anchor's typed wrapper handles this

    // manual data read without discriminator
    let manual_data_read = code.contains("try_borrow_data")
        && !code.contains("discriminator")
        && !code.contains("Account<")
        && !code.contains("AccountDeserialize");

    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && (raw_deserialize || manual_data_read) {
        return Some(VulnerabilityFinding {
            category: "Account Validation".to_string(),
            vuln_type: "Type Cosplay".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-004".to_string(),
            cwe: Some("CWE-843".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account data is deserialized via `try_from_slice` or `try_borrow_data` \
                without validating the account's 8-byte discriminator. An attacker can create a \
                different account type with the same data layout and pass it in place of the \
                expected type. The Solana runtime does not enforce account type identity -- only \
                the program can validate the discriminator. Anchor's `Account<'info, T>` does this \
                automatically; raw AccountInfo does not.".to_string(),
            attack_scenario: "Attacker deploys a program that creates Account Type A with a data \
                layout matching Type B. Passes Type A where the program expects Type B. The \
                deserialization succeeds because the byte layout matches, but semantic meanings \
                differ (e.g., a 'balance' field in Type A is actually a 'fee_rate' in Type B)."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Use Anchor's `Account<'info, T>` which auto-validates the 8-byte \
                discriminator, or manually check: `require!(data[0..8] == MyType::DISCRIMINATOR)`"
                .to_string(),
            confidence: 50,
            prevention: "Never deserialize account data without first validating the discriminator. \
                Use Anchor's typed wrappers or add manual discriminator checks.".to_string(),
        });
    }

    None
}

fn check_arbitrary_cpi(code: &str) -> Option<VulnerabilityFinding> {
    // raw invoke() without validated program — Program<T> & known IDs are safe
    let has_raw_cpi = code.contains("invoke(") || code.contains("invoke_signed(");
    let validates_program = code.contains("program.key()")
        || code.contains("program_id ==")
        || code.contains("check_program_account")
        || code.contains("Program<")
        || code.contains("token::ID")
        || code.contains("system_program::ID")
        || code.contains("Token::id()")
        || code.contains("spl_token::id()")
        || code.contains("anchor_spl")
        || code.contains("token_program")
        || code.contains("system_program")
        || code.contains("CpiContext::new")
        || code.contains("constraint =");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_raw_cpi && !validates_program {
        return Some(VulnerabilityFinding {
            category: "CPI Security".to_string(),
            vuln_type: "Arbitrary CPI".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-005".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A raw `invoke()` or `invoke_signed()` call is made without validating \
                the target program's address. The CPI target is passed as an `AccountInfo` which \
                can be ANY program. An attacker substitutes a malicious program that mimics the \
                expected interface but redirects funds. Use Anchor's `Program<'info, T>` which \
                validates the key automatically, or manually compare against a known program ID."
                .to_string(),
            attack_scenario: "Attacker deploys a program with the same instruction layout as the \
                SPL Token program. Passes it as the `token_program` AccountInfo. The `invoke()` \
                call succeeds, but the malicious program transfers tokens to the attacker instead \
                of the intended recipient. This is the Crema Finance attack vector ($8.8M, 2022)."
                .to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Crema Finance".to_string(),
                loss: "$8.8M".to_string(),
                date: "2022-07-03".to_string(),
            }),
            secure_fix: "Use Anchor's `Program<'info, Token>` for typed program validation, or \
                manually check: `require!(program.key() == spl_token::ID, ErrorCode::InvalidProgram)`"
                .to_string(),
            confidence: 50,
            prevention: "Never pass unvalidated AccountInfo as a CPI target. Use Anchor's typed \
                `Program<'info, T>` wrapper which validates the program ID during deserialization."
                .to_string(),
        });
    }

    None
}

fn check_duplicate_accounts(code: &str) -> Option<VulnerabilityFinding> {
    // 2+ mutable accounts of same type without key distinctness check

    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");
    if is_test {
        return None;
    }

    // e.g. two `Account<'info, TokenAccount>` fields both #[account(mut)]
    let has_same_type_mut_pair =
        (code.matches("Account<'info, TokenAccount>").count() >= 2
            || code.matches("Account < 'info , TokenAccount >").count() >= 2
            || code.matches("AccountInfo<'info>").count() >= 3)  // 3 because one is usually program/signer
        && code.contains("#[account(mut");

    let key_compare = code.contains(".key() !=")
        || code.contains("key() != ")
        || code.contains("constraint =")
        || code.contains("has_one");

    if has_same_type_mut_pair && !key_compare {
        return Some(VulnerabilityFinding {
            category: "Account Validation".to_string(),
            vuln_type: "Duplicate Mutable Accounts".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-006".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Multiple mutable accounts of the same type (e.g., two `TokenAccount` \
                fields) are not validated as distinct. An attacker can pass the same account \
                pubkey for both fields. If the instruction debits one and credits the other, \
                the net effect is zero -- but internal accounting may record both operations, \
                doubling the attacker's balance.".to_string(),
            attack_scenario: "Instruction has `from: Account<TokenAccount>` and `to: Account<TokenAccount>`, \
                both `#[account(mut)]`. Attacker passes the same account for both. The instruction \
                debits `from` by amount and credits `to` by amount -- but they are the same account, \
                so the balance is unchanged. The program's internal state records a transfer, \
                inflating the user's tracked balance.".to_string(),
            real_world_incident: None,
            secure_fix: "Add a constraint to enforce distinctness:\n\
                ```rust\n\
                #[account(mut, constraint = from.key() != to.key() @ ErrorCode::DuplicateAccounts)]\n\
                pub from: Account<'info, TokenAccount>,\n\
                #[account(mut)]\n\
                pub to: Account<'info, TokenAccount>,\n\
                ```".to_string(),
            confidence: 50,
            prevention: "Always add key distinctness constraints when two mutable accounts share \
                the same type. Anchor does not enforce this automatically.".to_string(),
        });
    }

    None
}

fn check_bump_seed(code: &str) -> Option<VulnerabilityFinding> {
    // find_program_address = safe (returns canonical bump).
    // create_program_address with user-supplied bump = vuln (~127 valid bumps exist).
    // also: Anchor seeds without `bump` constraint.
    let uses_create_program_address = code.contains("create_program_address");
    let has_bump_from_user = uses_create_program_address
        && !code.contains("find_program_address");
    let anchor_seeds_without_bump = code.contains("seeds = [")
        && !code.contains("bump")
        && !code.contains("init,");  // init auto-derives bump
    let stores_bump = code.contains("bump =")
        || code.contains("bump,")
        || code.contains(".bump")
        || code.contains("seeds::program");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && (has_bump_from_user || (anchor_seeds_without_bump && !stores_bump)) {
        return Some(VulnerabilityFinding {
            category: "PDA Security".to_string(),
            vuln_type: "Bump Seed Canonicalization".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-007".to_string(),
            cwe: Some("CWE-330".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "PDA is created or verified with a non-canonical bump seed. \
                `create_program_address` accepts any valid bump (typically ~127 values per \
                seed set), but only the canonical bump (from `find_program_address`, which \
                starts at 255 and decrements) should be used. Using a non-canonical bump \
                allows creation of multiple valid PDAs from the same seeds, enabling state \
                duplication attacks.".to_string(),
            attack_scenario: "Program creates user accounts at PDA with seeds=[user_key, bump]. \
                Canonical bump is 253. Attacker calls with bump=200, which is also a valid PDA. \
                This creates a second account at a different address, letting the attacker have \
                two 'user accounts' — one to deposit into (canonical) and one to withdraw from \
                (non-canonical), doubling their balance.".to_string(),
            real_world_incident: None,
            secure_fix: "Always derive the canonical bump with `find_program_address()` and store \
                it in the account. On subsequent accesses, validate: `seeds = [...], bump = \
                stored_bump`. In Anchor, use `#[account(seeds = [...], bump = account.bump)]`."
                .to_string(),
            confidence: 50,
            prevention: "Never accept user-provided bump values. Always use `find_program_address` \
                and store + validate the canonical bump. In Anchor, the `bump` constraint in \
                `#[account(...)]` enforces this automatically.".to_string(),
        });
    }

    None
}

fn check_pda_sharing(code: &str) -> Option<VulnerabilityFinding> {
    // per-user PDAs must include user.key() in seeds; pool/vault PDAs don't need it
    let has_pda = code.contains("seeds = [");
    let has_user_seed = code.contains("user.key()")
        || code.contains("payer.key()")
        || code.contains("authority.key()")
        || code.contains("owner.key()")
        || code.contains("signer.key()");
    // per-user state patterns
    let is_per_user = code.contains("user_state")
        || code.contains("user_account")
        || code.contains("user_position")
        || code.contains("escrow")
        || code.contains("user_balance");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_pda && !has_user_seed && is_per_user {
        return Some(VulnerabilityFinding {
            category: "PDA Security".to_string(),
            vuln_type: "PDA Sharing".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-008".to_string(),
            cwe: Some("CWE-284".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A per-user account (user_state, escrow, position) is derived from a \
                PDA that does not include the user's pubkey in its seeds. All users share the \
                same PDA address, meaning any user can read and modify another user's state. \
                Per-user PDAs must include `user.key().as_ref()` in the seed array.".to_string(),
            attack_scenario: "Program stores user balances at PDA seeds=[b\"user_state\"]. Since \
                there's no user key in seeds, all users share the same account. User A deposits \
                100 tokens, User B calls withdraw(100) and succeeds because the shared PDA has \
                User A's balance. User B steals User A's funds.".to_string(),
            real_world_incident: None,
            secure_fix: "Include user pubkey in seeds: `seeds = [b\"user_state\", user.key().as_ref()]`. \
                This ensures each user's state account is at a unique PDA address.".to_string(),
            confidence: 50,
            prevention: "Always include a user-discriminating seed (user pubkey, or authority key) \
                in PDAs that store per-user state. Shared state (pools, config) correctly omits \
                user keys.".to_string(),
        });
    }

    None
}

fn check_closing_accounts(code: &str) -> Option<VulnerabilityFinding> {
    // Anchor `close =` is safe; flag manual close without zeroing data
    let manual_close = code.contains("set_lamports(0)") || code.contains("lamports.borrow_mut");
    let anchor_close = code.contains("close =");
    let clears_data =
        code.contains("data.fill(0)") || code.contains("CLOSED_ACCOUNT_DISCRIMINATOR");

    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && manual_close && !anchor_close && !clears_data {
        return Some(VulnerabilityFinding {
            category: "Account Management".to_string(),
            vuln_type: "Account Closing Issues".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-009".to_string(),
            cwe: Some("CWE-404".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account is closed by setting lamports to 0 without zeroing the data \
                buffer. The Solana runtime garbage-collects zero-lamport accounts at the END of \
                the slot. Within the same slot, a subsequent transaction can 'revive' the account \
                by transferring lamports back, reusing the stale data. This is the account \
                resurrection attack.".to_string(),
            attack_scenario: "Transaction 1: Close account (set lamports=0, don't zero data). \
                Transaction 2 (same slot): Transfer 1 lamport back to the account. The runtime \
                hasn't GC'd it yet, so the data is still intact. The program reads the old data \
                as if the account was never closed, allowing double-withdrawals or state replay."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Zero the account data before draining lamports:\n\
                ```rust\n\
                let mut data = account.try_borrow_mut_data()?;\n\
                data.fill(0);\n\
                // Or use Anchor's close constraint which handles this:\n\
                #[account(mut, close = destination)]\n\
                ```".to_string(),
            confidence: 50,
            prevention: "Use Anchor's `close = <destination>` constraint which automatically \
                zeroes data, transfers lamports, and sets the CLOSED discriminator. For native \
                programs, always call `data.fill(0)` before setting lamports to 0.".to_string(),
        });
    }

    None
}

fn check_sysvar_address(code: &str) -> Option<VulnerabilityFinding> {
    // Sysvar<T> validates address; raw AccountInfo + Clock/Rent is vuln
    let uses_raw_sysvar_access = code.contains("AccountInfo")
        && (code.contains("Clock") || code.contains("Rent") || code.contains("SlotHashes"))
        && !code.contains("Sysvar<")         // Anchor typed wrapper handles validation
        && !code.contains("Sysvar <");       // quote! spacing variant
    let validates_key = code.contains("sysvar::") || code.contains("SYSVAR_")
        || code.contains("clock::id()") || code.contains("rent::id()");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && uses_raw_sysvar_access && !validates_key {
        return Some(VulnerabilityFinding {
            category: "Sysvar Security".to_string(),
            vuln_type: "Sysvar Address Issues".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-010".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Sysvar (Clock/Rent/SlotHashes) is accessed via raw `AccountInfo` \
                without validating the account address is the real sysvar. An attacker can \
                pass a fake account with fabricated data (e.g., a manipulated timestamp or \
                artificial rent value). Use Anchor's `Sysvar<'info, Clock>` which validates \
                the address automatically, or manually check against `sysvar::clock::id()`."
                .to_string(),
            attack_scenario: "Attacker creates a fake account with arbitrary data and passes \
                it as the Clock sysvar. The program reads a manipulated `unix_timestamp`, \
                allowing the attacker to bypass time-locked operations (vesting schedules, \
                staking cooldowns, auction deadlines).".to_string(),
            real_world_incident: None,
            secure_fix: "Use `pub clock: Sysvar<'info, Clock>` in your Accounts struct, or \
                validate: `require!(clock_info.key() == sysvar::clock::id())`".to_string(),
            confidence: 50,
            prevention: "Always use Anchor's typed `Sysvar<'info, T>` wrapper which validates \
                the sysvar address during account deserialization.".to_string(),
        });
    }

    None
}

fn check_initialization(code: &str) -> Option<VulnerabilityFinding> {
    // fn initialize without reinit guard — "init" alone matches too many substrings
    let has_init_fn = code.contains("fn initialize")
        || code.contains("fn init(")
        || code.contains("fn process_initialize")
        || code.contains("Initialize {");  // Anchor instruction context struct
    let checks_initialized = code.contains("is_initialized")
        || code.contains("initialized ==")
        || code.contains("#[account(init")       // Anchor's init constraint prevents reinit
        || code.contains("require!(!state.initialized");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_init_fn && !checks_initialized {
        return Some(VulnerabilityFinding {
            category: "Initialization".to_string(),
            vuln_type: "Reinitialization Vulnerability".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-011".to_string(),
            cwe: Some("CWE-665".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "An initialization function exists without a guard to prevent \
                reinitialization. An attacker can call `initialize` again to reset the \
                program's state, overwriting the authority, resetting balances, or changing \
                configuration. Anchor's `#[account(init)]` prevents this by requiring the \
                account to not exist yet (checked via lamports == 0).".to_string(),
            attack_scenario: "Program has `fn initialize(authority: Pubkey)` that writes the \
                authority to state but doesn't check if state is already initialized. Attacker \
                calls `initialize` with their own pubkey as authority. The program overwrites \
                the legitimate authority, giving the attacker full admin control.".to_string(),
            real_world_incident: None,
            secure_fix: "Add an `is_initialized` flag to state and check it at the start of \
                `initialize`, or use Anchor's `#[account(init)]` which ensures the account \
                was just created (lamports == 0) and sets the discriminator.\n\
                ```rust\n\
                require!(!state.is_initialized, ErrorCode::AlreadyInitialized);\n\
                state.is_initialized = true;\n\
                ```".to_string(),
            confidence: 50,
            prevention: "Use Anchor's `#[account(init)]` constraint. For native programs, \
                always include an `is_initialized: bool` field and check it before writing state."
                .to_string(),
        });
    }

    None
}

fn check_account_data_matching(code: &str) -> Option<VulnerabilityFinding> {
    // state account (vault/pool) + user account without has_one/constraint linking them
    let has_state_account = (code.contains("vault") || code.contains("pool") || code.contains("market"))
        && code.contains("Account<");
    let has_user_ref = code.contains("authority") || code.contains("user") || code.contains("owner");
    let validates_relationships = code.contains("has_one")
        || code.contains("constraint =")
        || code.contains(".authority ==")
        || code.contains(".owner ==")
        || code.contains("vault.authority");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_state_account && has_user_ref && !validates_relationships {
        return Some(VulnerabilityFinding {
            category: "Account Validation".to_string(),
            vuln_type: "Account Data Mismatch".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-012".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "An instruction takes both a state account (vault/pool) and an authority/user \
                account, but does not validate their relationship. Without `has_one = authority` or \
                an equivalent constraint, an attacker can pass any vault with any authority — even \
                one they control — to access someone else's funds.".to_string(),
            attack_scenario: "Instruction takes `vault: Account<Vault>` and `authority: Signer`. \
                Attacker creates their own vault where they are the authority. Passes their vault \
                + their signer to an instruction that reads from a different token account (passed \
                separately). The program verifies `authority == vault.authority` (both attacker-controlled), \
                then processes the operation on the victim's token account.".to_string(),
            real_world_incident: None,
            secure_fix: "Add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the \
                vault/pool account to ensure the signer matches the stored authority.".to_string(),
            confidence: 50,
            prevention: "Always validate relationships between accounts using `has_one` or `constraint`. \
                Every state account that references an authority must be validated against the actual signer."
                .to_string(),
        });
    }

    None
}

// --- SOL-013 to SOL-052 ---

fn check_rent_exemption(code: &str) -> Option<VulnerabilityFinding> {
    // #[account(init)] handles rent; flag native create_account without Rent::get()
    let creates_native = code.contains("create_account")
        || code.contains("CreateAccount")
        || code.contains("system_instruction::create_account");
    let uses_anchor_init = code.contains("#[account(init");
    let checks_rent = code.contains("rent_exempt")
        || code.contains("Rent::get")
        || code.contains("minimum_balance")
        || code.contains("rent.minimum_balance");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && creates_native && !uses_anchor_init && !checks_rent {
        return Some(VulnerabilityFinding {
            category: "Account Management".to_string(),
            vuln_type: "Missing Rent Exemption Check".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-013".to_string(),
            cwe: Some("CWE-754".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A native `create_account` instruction is called without calculating \
                the rent-exempt minimum balance via `Rent::get()?.minimum_balance(data_len)`. \
                If insufficient lamports are assigned, the account will be garbage-collected \
                by the runtime after ~2 years (or immediately if below the rent-exempt minimum \
                and not paying rent). Anchor's `#[account(init)]` handles this automatically."
                .to_string(),
            attack_scenario: "Program creates an account with a hardcoded lamport amount that is \
                below rent-exempt minimum. After the rent epoch passes, the runtime deducts rent, \
                eventually reducing lamports to 0 and garbage-collecting the account. All state \
                stored in the account is lost permanently.".to_string(),
            real_world_incident: None,
            secure_fix: "Calculate rent-exempt balance dynamically: \
                `let rent = Rent::get()?; let lamports = rent.minimum_balance(data_len);` \
                and pass it to `create_account`. Or use Anchor's `#[account(init)]` which \
                handles this automatically.".to_string(),
            confidence: 50,
            prevention: "Always use `Rent::get()?.minimum_balance(data_len)` for native account \
                creation. Never hardcode lamport amounts. Use Anchor's `#[account(init)]` when \
                possible.".to_string(),
        });
    }
    None
}

fn check_unsafe_deserialization(code: &str) -> Option<VulnerabilityFinding> {
    let unsafe_deserialize = code.contains("try_from_slice_unchecked")
        || (code.contains("from_slice") && !code.contains("try_from"));

    if unsafe_deserialize {
        return Some(VulnerabilityFinding {
            category: "Data Validation".to_string(),
            vuln_type: "Unsafe Deserialization".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-014".to_string(),
            cwe: Some("CWE-502".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description:
                "Unsafe deserialization can read garbage data or cause undefined behavior."
                    .to_string(),
            attack_scenario:
                "Attacker provides malformed data that crashes or exploits the program.".to_string(),
            real_world_incident: None,
            secure_fix: "Use try_from_slice with proper error handling".to_string(),
            confidence: 50,
            prevention: "Always validate data length and format before deserializing".to_string(),
        });
    }
    None
}

fn check_program_id(code: &str) -> Option<VulnerabilityFinding> {
    // CpiContext with untyped AccountInfo program — SOL-005 covers raw invoke()
    let has_cpi_context = code.contains("CpiContext");
    let has_untyped_program = code.contains("program:") && code.contains("AccountInfo");
    let validates_program = code.contains("program_id ==")
        || code.contains("key() ==")
        || code.contains("Program<")
        || code.contains("Program <")
        || code.contains("token::ID")
        || code.contains("Token::id()");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_cpi_context && has_untyped_program && !validates_program {
        return Some(VulnerabilityFinding {
            category: "CPI Security".to_string(),
            vuln_type: "Missing Program ID Validation".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-015".to_string(),
            cwe: Some("CWE-345".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A `CpiContext` is constructed with an untyped `AccountInfo` as the \
                program argument instead of Anchor's `Program<'info, T>`. The program ID is \
                not validated before the CPI, allowing an attacker to substitute any program. \
                Use `Program<'info, Token>` or manually validate the key before constructing \
                the CpiContext.".to_string(),
            attack_scenario: "Attacker passes a malicious program as an AccountInfo to the CPI \
                instruction. The CpiContext is constructed without checking the program key. \
                The malicious program processes the instruction differently (e.g., sends funds \
                to the attacker instead of the intended recipient).".to_string(),
            real_world_incident: None,
            secure_fix: "Replace `AccountInfo` with `Program<'info, Token>` in your Accounts \
                struct: `pub token_program: Program<'info, Token>`. Anchor validates the key \
                automatically.".to_string(),
            confidence: 50,
            prevention: "Always use typed `Program<'info, T>` for CPI program accounts. Never \
                construct CpiContext with unvalidated AccountInfo.".to_string(),
        });
    }
    None
}

fn check_unchecked_return(code: &str) -> Option<VulnerabilityFinding> {
    // .unwrap() on CPI/borrow in financial context — .get()/.find() unwraps are fine
    let has_dangerous_unwrap = (code.contains("invoke(") || code.contains("invoke_signed("))
        && code.contains(".unwrap()")
        && !code.contains("// safe:");
    let has_borrow_unwrap = code.contains("try_borrow") && code.contains(".unwrap()");
    let in_financial = code.contains("transfer") || code.contains("withdraw") || code.contains("deposit");
    let uses_error_handling = code.contains("?") || code.contains(".ok_or(") || code.contains(".map_err(");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && (has_dangerous_unwrap || has_borrow_unwrap) && in_financial && !uses_error_handling {
        return Some(VulnerabilityFinding {
            category: "Error Handling".to_string(),
            vuln_type: "Unchecked Return Value".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-016".to_string(),
            cwe: Some("CWE-252".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "`.unwrap()` is used on a fallible CPI or account borrow operation in \
                a financial instruction. If the operation fails, the BPF program panics and the \
                entire transaction is reverted. While Solana's runtime rolls back state on panic, \
                the lack of proper error handling means: (1) no meaningful error message for \
                clients, (2) potential denial-of-service if an attacker can trigger the panic \
                condition, (3) wasted compute units.".to_string(),
            attack_scenario: "Attacker triggers the unwrap failure condition (e.g., by providing \
                an account that can't be borrowed). The transaction panics with a generic error \
                instead of a clean program error. If this is in a critical path (like a liquidation \
                bot), the attacker can grief the system by repeatedly triggering panics.".to_string(),
            real_world_incident: None,
            secure_fix: "Replace `.unwrap()` with `?` or `.ok_or(ErrorCode::OperationFailed)?`. \
                For borrows: `account.try_borrow_data().map_err(|_| ErrorCode::BorrowFailed)?`"
                .to_string(),
            confidence: 50,
            prevention: "Never use `.unwrap()` on fallible operations in production BPF code. \
                Use the `?` operator with custom error types for meaningful error propagation."
                .to_string(),
        });
    }
    None
}

fn check_reentrancy(code: &str) -> Option<VulnerabilityFinding> {
    // Primary: AST-based analysis verifying CPI-before-state-write ordering
    if !ast_checks::ast_has_reentrancy(code) {
        return None;
    }

    let has_guard = code.contains("ReentrancyGuard") || code.contains("is_locked");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if has_guard || is_test {
        return None;
    }

    Some(VulnerabilityFinding {
        category: "Reentrancy".to_string(),
        vuln_type: "Cross-Program Reentrancy".to_string(),
        severity: 5,
        severity_label: "CRITICAL".to_string(),
        id: "SOL-017".to_string(),
        cwe: Some("CWE-841".to_string()),
        location: String::new(),
        function_name: String::new(),
        line_number: 0,
        vulnerable_code: String::new(),
        description: "State modification after CPI allows reentrancy attack — confirmed via AST statement ordering analysis.".to_string(),
        attack_scenario: "Attacker's program calls back before state is finalized.".to_string(),
        real_world_incident: Some(crate::Incident {
            project: "Various DeFi".to_string(),
            loss: "$100M+".to_string(),
            date: "2021-2023".to_string(),
        }),
        secure_fix: "Update state BEFORE making CPI calls (Checks-Effects-Interactions)"
            .to_string(),
        confidence: 80,
        prevention: "Follow CEI pattern, add reentrancy guards".to_string(),
    })
}

fn check_flash_loan(code: &str) -> Option<VulnerabilityFinding> {
    let is_flash = code.contains("flash_loan") || code.contains("FlashLoan");
    let checks_repay = code.contains("require!") || code.contains("assert!");

    if is_flash && !checks_repay {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "Flash Loan Vulnerability".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-018".to_string(),
            cwe: Some("CWE-362".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Flash loan without proper repayment validation.".to_string(),
            attack_scenario: "Attacker manipulates state during flash loan and doesn't repay."
                .to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Multiple".to_string(),
                loss: "$200M+".to_string(),
                date: "2020-2023".to_string(),
            }),
            secure_fix: "Verify repayment + fee at end of flash loan instruction".to_string(),
            confidence: 50,
            prevention: "Track pre/post balances and enforce invariants".to_string(),
        });
    }
    None
}

fn check_oracle_manipulation(code: &str) -> Option<VulnerabilityFinding> {
    let uses_oracle = code.contains("oracle")
        || code.contains("price_feed")
        || code.contains("Pyth")
        || code.contains("Switchboard");
    let single_source = !code.contains("twap") && !code.contains("median");
    let no_bounds = !code.contains("max_price") && !code.contains("min_price");

    if uses_oracle && single_source && no_bounds {
        return Some(VulnerabilityFinding {
            category: "Oracle Security".to_string(),
            vuln_type: "Oracle Price Manipulation".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-019".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Single oracle source without price bounds check.".to_string(),
            attack_scenario: "Attacker manipulates oracle price to drain funds.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Mango Markets".to_string(),
                loss: "$114M".to_string(),
                date: "2022-10-11".to_string(),
            }),
            secure_fix: "Use multiple oracles, TWAP, and price deviation checks".to_string(),
            confidence: 50,
            prevention: "Implement circuit breakers for sudden price changes".to_string(),
        });
    }
    None
}

fn check_stale_oracle(code: &str) -> Option<VulnerabilityFinding> {
    // actual oracle feed without staleness check — not just the word "price"
    let uses_oracle_integration = code.contains("price_feed")
        || code.contains("oracle_account")
        || code.contains("PriceFeed")
        || code.contains("Pyth")
        || code.contains("Switchboard")
        || code.contains("get_price")
        || (code.contains("oracle") && code.contains("AccountInfo"));
    let checks_freshness = code.contains("timestamp")
        || code.contains("stale")
        || code.contains("last_update")
        || code.contains("age")
        || code.contains("max_staleness")
        || code.contains("publish_time");

    if uses_oracle_integration && !checks_freshness {
        return Some(VulnerabilityFinding {
            category: "Oracle Security".to_string(),
            vuln_type: "Stale Oracle Data".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-020".to_string(),
            cwe: Some("CWE-672".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Oracle price data is consumed without checking freshness. Pyth feeds include `publish_time` and Switchboard feeds include `latest_confirmed_round.round_open_timestamp` — neither is being validated. During network congestion or oracle downtime, the program will use arbitrarily old prices, enabling manipulation.".to_string(),
            attack_scenario: "Attacker waits for the oracle to go stale (network congestion, oracle downtime, or Pyth publisher outage). When the price is outdated by minutes or hours, the attacker executes a trade/liquidation using the stale price that diverges from the real market price. For lending protocols, this means artificial liquidations. For DEXes, this means swapping at a favorable rate.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Mango Markets".to_string(),
                loss: "$114M".to_string(),
                date: "2022-10-11".to_string(),
            }),
            secure_fix: "Add staleness check: `let price = oracle.get_price_no_older_than(clock.unix_timestamp, MAX_ORACLE_AGE)?;` For Pyth: check `price_feed.get_price_no_older_than(max_age)`. For Switchboard: check `aggregator.latest_confirmed_round.round_open_timestamp > clock.unix_timestamp - MAX_STALENESS`.".to_string(),
            confidence: 50,
            prevention: "Always validate oracle freshness with a configurable max age (typically 30-120 seconds). Add circuit breakers for sudden large price deviations (>10% in one slot).".to_string(),
        });
    }
    None
}

fn check_mint_authority(code: &str) -> Option<VulnerabilityFinding> {
    let has_mint = code.contains("mint_to") || code.contains("MintTo");
    let checks_authority = code.contains("mint_authority") && code.contains("Signer");

    if has_mint && !checks_authority {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Unprotected Mint Authority".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-021".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Mint operation without proper authority validation.".to_string(),
            attack_scenario: "Attacker mints unlimited tokens.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate mint authority is a signer".to_string(),
            confidence: 50,
            prevention: "Use PDA as mint authority and validate seeds".to_string(),
        });
    }
    None
}

fn check_freeze_authority(code: &str) -> Option<VulnerabilityFinding> {
    // actual freeze CPI ops — ignore 'freeze' in comments or var names
    let has_freeze_cpi = code.contains("freeze_account")
        || code.contains("FreezeAccount")
        || code.contains("token::freeze")
        || code.contains("thaw_account");
    let validates_authority = (code.contains("freeze_authority") && code.contains("Signer"))
        || code.contains("has_one = freeze_authority")
        || code.contains("Program<");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_freeze_cpi && !validates_authority {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Freeze Authority Issues".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-022".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A freeze/thaw CPI operation is performed without validating the \
                freeze authority as a `Signer<'info>`. Anyone can call this instruction and \
                freeze arbitrary token accounts, locking users' funds.".to_string(),
            attack_scenario: "Attacker calls the freeze instruction passing a victim's token \
                account. Since the freeze authority is not validated as a signer, the CPI \
                succeeds and the victim's tokens are locked. The attacker can then demand \
                ransom to thaw the account.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate the freeze authority is a signer: \
                `pub freeze_authority: Signer<'info>` with `has_one` on the mint.".to_string(),
            confidence: 50,
            prevention: "Always validate freeze authority as Signer. For DeFi tokens, consider \
                disabling freeze authority entirely by setting it to None on mint creation."
                .to_string(),
        });
    }
    None
}

fn check_token_account_confusion(code: &str) -> Option<VulnerabilityFinding> {
    let has_token_accounts = code.contains("TokenAccount") || code.contains("token::Token");
    let validates_mint = code.contains("token_account.mint ==") || code.contains("constraint = ");

    if has_token_accounts && !validates_mint && code.contains("transfer") {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Token Account Confusion".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-023".to_string(),
            cwe: Some("CWE-843".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token account mint not validated.".to_string(),
            attack_scenario: "Attacker substitutes token account for different mint.".to_string(),
            real_world_incident: None,
            secure_fix: "Add constraint: token_account.mint == expected_mint".to_string(),
            confidence: 50,
            prevention: "Always validate token account mint matches expected".to_string(),
        });
    }
    None
}

fn check_token_validation(code: &str) -> Option<VulnerabilityFinding> {
    // token CPI without validating the program is spl_token
    let has_token_cpi = (code.contains("token::transfer") || code.contains("token::Transfer")
        || code.contains("transfer_checked") || code.contains("mint_to") || code.contains("burn"))
        && (code.contains("CpiContext") || code.contains("invoke"));
    let validates_program = code.contains("Program<")
        || code.contains("token_program")
        || code.contains("Token::id()");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if has_token_cpi && !validates_program && !is_test {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Missing Token Program Validation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-024".to_string(),
            cwe: Some("CWE-345".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A token CPI (transfer/mint_to/burn) is made without validating the target program is the real SPL Token program. An attacker can pass a malicious program that implements the same interface but redirects tokens to the attacker. Use `Program<'info, Token>` in your Accounts struct to have Anchor validate the program ID automatically.".to_string(),
            attack_scenario: "Attacker deploys a program that exports `transfer()` but sends tokens to the attacker's account instead. They pass this fake program's ID as `token_program`. Since the CPI target isn't validated against `spl_token::ID`, the invoke succeeds with the malicious program. This is exactly what happened in the Crema Finance exploit ($8.8M, 2022-07-03).".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Crema Finance".to_string(),
                loss: "$8.8M".to_string(),
                date: "2022-07-03".to_string(),
            }),
            secure_fix: "Add `pub token_program: Program<'info, Token>` to your Accounts struct. Anchor will verify `token_program.key() == spl_token::ID` during account validation. For Token-2022, use `Interface<'info, TokenInterface>`.".to_string(),
            confidence: 50,
            prevention: "Always use `Program<'info, Token>` (not `AccountInfo`) for the token program. Never pass unvalidated program accounts to CPI calls.".to_string(),
        });
    }
    None
}

fn check_lamport_drain(code: &str) -> Option<VulnerabilityFinding> {
    // direct lamport manipulation without auth or rent check
    let modifies_lamports = code.contains("lamports.borrow_mut");
    let sets_lamports = code.contains("set_lamports");
    let has_rent_check = code.contains("rent_exempt")
        || code.contains("minimum_balance")
        || code.contains("Rent::get");
    let has_auth = code.contains("Signer") || code.contains("authority") || code.contains("require!");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && (modifies_lamports || sets_lamports) && !has_rent_check && !has_auth {
        return Some(VulnerabilityFinding {
            category: "Account Management".to_string(),
            vuln_type: "Lamport Balance Drain".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-025".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Direct lamport manipulation via `lamports.borrow_mut()` or \
                `set_lamports()` without authorization checks or rent-exemption validation. \
                An attacker could drain lamports from program-owned accounts, either stealing \
                SOL directly or making accounts non-rent-exempt (causing garbage collection)."
                .to_string(),
            attack_scenario: "Attacker calls the instruction that modifies lamports without \
                signer/authority validation. They set the victim account's lamports to 0, \
                transferring all SOL to their own account. The victim's account data is lost \
                when the runtime garbage-collects the zero-lamport account.".to_string(),
            real_world_incident: None,
            secure_fix: "Add Signer<'info> authorization and validate the remaining lamports \
                are above rent-exempt minimum: `require!(account.lamports() >= rent.minimum_balance(account.data_len()))`"
                .to_string(),
            confidence: 50,
            prevention: "Never allow unrestricted lamport modification. Gate all lamport changes \
                behind authority checks. Validate rent-exemption after modification.".to_string(),
        });
    }
    None
}

fn check_cpi_depth(code: &str) -> Option<VulnerabilityFinding> {
    // counting invoke() calls != nesting depth; detect recursive CPI instead
    // (CPI entrypoint that itself calls invoke → potential recursion)
    let is_cpi_entrypoint = code.contains("process_instruction")
        || code.contains("fn execute_hook")
        || code.contains("fn transfer_hook");
    let makes_cpi = code.contains("invoke(") || code.contains("invoke_signed(");
    let uses_self_program_id = code.contains("program_id") && code.contains("invoke");


    if is_cpi_entrypoint && makes_cpi && uses_self_program_id {
        return Some(VulnerabilityFinding {
            category: "CPI Security".to_string(),
            vuln_type: "Recursive CPI Risk".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-026".to_string(),
            cwe: Some("CWE-674".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A CPI entry point (process_instruction or hook handler) makes CPI \
                calls that could potentially recurse back to itself. Solana limits CPI nesting \
                to 4 levels; exceeding this causes the transaction to fail. More importantly, \
                recursive CPIs can cause reentrancy-style vulnerabilities where state is read \
                before a nested call modifies it.".to_string(),
            attack_scenario: "Attacker invokes the program via CPI. The program's handler \
                makes a CPI to a malicious program, which calls back into the original \
                program. If state was modified before the CPI but not finalized, the \
                recursive call reads stale/inconsistent state.".to_string(),
            real_world_incident: None,
            secure_fix: "Ensure CPI targets are validated (use `Program<'info, T>`) and avoid \
                making CPIs from within CPI handlers. If unavoidable, use reentrancy guards."
                .to_string(),
            confidence: 50,
            prevention: "Design programs to avoid CPI from within CPI handlers. Validate all \
                CPI target programs. Use the Checks-Effects-Interactions pattern.".to_string(),
        });
    }
    None
}

fn check_seeds_validation(code: &str) -> Option<VulnerabilityFinding> {
    let has_pda = code.contains("find_program_address") || code.contains("seeds =");
    let user_input_seeds = code.contains("user.key()") || code.contains("ctx.accounts.");
    let validates = code.contains("bump =") || code.contains("bump,");

    if has_pda && user_input_seeds && !validates {
        return Some(VulnerabilityFinding {
            category: "PDA Security".to_string(),
            vuln_type: "Missing Seeds Validation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-027".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "PDA seeds from user input not validated.".to_string(),
            attack_scenario: "Attacker provides malicious seeds to access other PDAs.".to_string(),
            real_world_incident: None,
            secure_fix: "Store bump seed and validate on each access".to_string(),
            confidence: 50,
            prevention: "Always verify PDA derivation".to_string(),
        });
    }
    None
}

fn check_account_resurrection(code: &str) -> Option<VulnerabilityFinding> {
    // manual close without data zeroing → same-slot resurrection
    let manual_close = (code.contains("close_account") || code.contains("lamports.borrow_mut")
        || code.contains("set_lamports(0)"))
        && !code.contains("#[account(close");
    let clears_data = code.contains("fill(0)")
        || code.contains("CLOSED_ACCOUNT_DISCRIMINATOR")
        || code.contains("data.borrow_mut().fill(0)");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if manual_close && !clears_data && !is_test {
        return Some(VulnerabilityFinding {
            category: "Account Management".to_string(),
            vuln_type: "Account Resurrection".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-028".to_string(),
            cwe: Some("CWE-672".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account is closed manually (lamports transferred out) but its data buffer is not zeroed and the discriminator is not set to `CLOSED_ACCOUNT_DISCRIMINATOR`. Within the SAME transaction, a subsequent instruction can 'resurrect' the account by sending lamports back to it. The stale data is still readable, allowing the attacker to reuse the account's state (balance, permissions, etc.) after it was supposedly closed. Use Anchor's `#[account(close = recipient)]` which handles all three steps automatically.".to_string(),
            attack_scenario: "Attacker calls the close instruction, which transfers lamports but doesn't zero data. In the same transaction, the attacker sends lamports back to the account (making it rent-exempt again). The account now has its original data but the program thinks it was closed. Attacker replays operations using the 'closed' account's stale state — e.g., withdrawing funds that were supposed to be returned.".to_string(),
            real_world_incident: None,
            secure_fix: "Use Anchor's `#[account(close = recipient)]` constraint which: (1) sets discriminator to CLOSED, (2) zeros all data, (3) transfers all lamports. For manual closing: `account.data.borrow_mut().fill(0); **account.lamports.borrow_mut() = 0;`".to_string(),
            confidence: 50,
            prevention: "Always use Anchor's close constraint. If manual closing is required, zero all data bytes AND set the 8-byte discriminator to the CLOSED sentinel value before transferring lamports.".to_string(),
        });
    }
    None
}

fn check_close_authority(code: &str) -> Option<VulnerabilityFinding> {
    // close without any auth (no signer, no has_one, no require!)
    let has_close = code.contains("close =") || code.contains("close_account");
    let has_any_auth = code.contains("authority") && code.contains("Signer")
        || code.contains("admin") && code.contains("Signer")
        || code.contains("owner") && code.contains("Signer")
        || code.contains("has_one")
        || code.contains("#[account(signer)]")
        || code.contains("require!");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_close && !has_any_auth {
        return Some(VulnerabilityFinding {
            category: "Authorization".to_string(),
            vuln_type: "Missing Close Authority".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-029".to_string(),
            cwe: Some("CWE-285".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "An account close operation (`close =` or `close_account`) is performed \
                without any authority validation (no Signer, no has_one, no require!). Anyone \
                can call this instruction and close accounts, stealing all remaining lamports \
                (which go to the `close` recipient).".to_string(),
            attack_scenario: "Attacker calls the close instruction for a victim's account. Since \
                no authority check exists, the instruction succeeds. The lamports from the closed \
                account are sent to the `close = recipient` address. If the attacker controls the \
                recipient, they steal the victim's SOL. Even if not, the victim's state is \
                permanently destroyed.".to_string(),
            real_world_incident: None,
            secure_fix: "Add `pub authority: Signer<'info>` and `#[account(has_one = authority)]` \
                on the account being closed. This ensures only the authorized owner can close it."
                .to_string(),
            confidence: 50,
            prevention: "Every close operation must validate the caller is authorized. Use \
                `has_one = authority` or `constraint = authority.key() == account.owner`."
                .to_string(),
        });
    }
    None
}

fn check_privilege_escalation(code: &str) -> Option<VulnerabilityFinding> {
    // Primary: AST-based analysis
    if !ast_checks::ast_has_privilege_escalation(code) {
        return None;
    }

    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");
    if is_test {
        return None;
    }

    Some(VulnerabilityFinding {
        category: "Authorization".to_string(),
        vuln_type: "Privilege Escalation".to_string(),
        severity: 5,
        severity_label: "CRITICAL".to_string(),
        id: "SOL-030".to_string(),
        cwe: Some("CWE-269".to_string()),
        location: String::new(),
        function_name: String::new(),
        line_number: 0,
        vulnerable_code: String::new(),
        description: "The program's authority/admin can be changed without requiring the current authority to sign. Anyone can call the authority-change instruction and seize control.".to_string(),
        attack_scenario: "Attacker calls the update-authority instruction passing their own pubkey. Since the current authority isn't validated as a signer, the attacker becomes the new authority.".to_string(),
        real_world_incident: Some(crate::Incident {
            project: "Multiple DeFi".to_string(),
            loss: "Various".to_string(),
            date: "2021-2023".to_string(),
        }),
        secure_fix: "Require the current authority to sign: `pub authority: Signer<'info>` with `#[account(mut, has_one = authority)]`. Implement two-step authority transfer.".to_string(),
        confidence: 85,
        prevention: "All authority transfer operations must validate the current authority as a Signer.".to_string(),
    })
}

fn check_unauthorized_mint(code: &str) -> Option<VulnerabilityFinding> {
    // mint_to without authority validation — uncapped supply alone is fine (LP tokens etc)
    let mints = code.contains("mint_to") || code.contains("MintTo");
    let validates_authority = (code.contains("mint_authority") || code.contains("authority"))
        && (code.contains("Signer") || code.contains("has_one"));
    let has_access_control = code.contains("require!") || code.contains("#[access_control");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && mints && !validates_authority && !has_access_control {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Unauthorized Token Mint".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-031".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A `mint_to` CPI is performed without validating the mint authority \
                as a `Signer<'info>`. Anyone can call this instruction and mint unlimited tokens. \
                The SPL Token program requires the mint authority to sign the transaction, but if \
                a PDA is the mint authority, the instruction handler must verify that the caller \
                is authorized to trigger the PDA-signed mint.".to_string(),
            attack_scenario: "Attacker calls the mint instruction bypassing authority checks. \
                If the mint is PDA-controlled, the program signs with invoke_signed, minting \
                tokens to the attacker. They then sell the freshly minted tokens on a DEX, \
                crashing the token price and profiting.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate mint authority: `pub mint_authority: Signer<'info>` with \
                `has_one = mint_authority` on the config account. For PDA-minted tokens, \
                require an admin Signer and enforce supply caps.".to_string(),
            confidence: 50,
            prevention: "Gate all mint operations behind Signer-validated authority checks. \
                Consider implementing supply caps for fixed-supply tokens.".to_string(),
        });
    }
    None
}

fn check_decimals(code: &str) -> Option<VulnerabilityFinding> {
    let has_amounts = code.contains("amount") && code.contains("transfer");
    let checks_decimals = code.contains("decimals") || code.contains("10.pow");

    if has_amounts && !checks_decimals && code.contains("u64") {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Missing Decimals Validation".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-032".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token decimals not validated in calculations.".to_string(),
            attack_scenario: "Wrong decimals cause incorrect value calculations.".to_string(),
            real_world_incident: None,
            secure_fix: "Normalize amounts based on token decimals".to_string(),
            confidence: 50,
            prevention: "Always account for token decimals".to_string(),
        });
    }
    None
}

fn check_slippage(code: &str) -> Option<VulnerabilityFinding> {
    let is_swap = code.contains("swap") || code.contains("exchange");
    let has_slippage =
        code.contains("slippage") || code.contains("min_amount") || code.contains("max_amount");

    if is_swap && !has_slippage {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "Missing Slippage Protection".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-033".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Swap operation without slippage protection.".to_string(),
            attack_scenario: "MEV bots sandwich the transaction for profit.".to_string(),
            real_world_incident: None,
            secure_fix: "Add min_amount_out parameter and validate".to_string(),
            confidence: 50,
            prevention: "Always implement slippage tolerance".to_string(),
        });
    }
    None
}

fn check_sandwich_attack(code: &str) -> Option<VulnerabilityFinding> {
    // AMM liquidity ops without slippage — swap is covered by SOL-033
    let is_amm_lp = code.contains("pool")
        && (code.contains("add_liquidity") || code.contains("remove_liquidity")
            || code.contains("provide_liquidity"));
    let has_protection = code.contains("deadline")
        || code.contains("slippage")
        || code.contains("min_amount")
        || code.contains("max_amount");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && is_amm_lp && !has_protection {
        return Some(VulnerabilityFinding {
            category: "MEV Protection".to_string(),
            vuln_type: "Sandwich Attack Vulnerability".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-034".to_string(),
            cwe: Some("CWE-362".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "An AMM liquidity operation (add/remove liquidity) has no slippage \
                or deadline protection. An attacker can sandwich the transaction by manipulating \
                the pool ratio before and after the user's transaction, extracting value from \
                the liquidity provider.".to_string(),
            attack_scenario: "User submits add_liquidity(1000 USDC, 1 SOL). Attacker front-runs \
                by swapping heavily into SOL, inflating the SOL/USDC ratio. User's liquidity is \
                added at the distorted ratio, receiving fewer LP tokens. Attacker back-runs by \
                swapping back, profiting from the user's unfavorable entry price.".to_string(),
            real_world_incident: None,
            secure_fix: "Add `min_lp_tokens` parameter: `require!(lp_tokens_minted >= min_lp_tokens, \
                ErrorCode::SlippageExceeded)`. Also add a `deadline` timestamp parameter."
                .to_string(),
            confidence: 50,
            prevention: "All liquidity operations should accept min/max output parameters and \
                a deadline. Validate these before executing the operation.".to_string(),
        });
    }
    None
}

fn check_frontrunning(code: &str) -> Option<VulnerabilityFinding> {
    // auction bid/reveal without commit-reveal — skip generic 'commit' usage
    let has_bid_reveal = code.contains("fn bid") || code.contains("fn reveal")
        || (code.contains("auction") && code.contains("bid"));
    let has_commit_reveal = code.contains("commit_reveal") || code.contains("CommitReveal")
        || (code.contains("commit_hash") && code.contains("reveal"));
    let uses_scheme = has_commit_reveal
        || (code.contains("hash") && (code.contains("commit") || code.contains("seal")));
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_bid_reveal && !uses_scheme {
        return Some(VulnerabilityFinding {
            category: "MEV Protection".to_string(),
            vuln_type: "Front-Running Vulnerability".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-035".to_string(),
            cwe: Some("CWE-362".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "An auction or bid operation submits a value in plaintext without a \
                commit-reveal scheme. Validators and MEV bots can observe the pending transaction \
                in the mempool and submit a higher bid before the user's transaction is processed."
                .to_string(),
            attack_scenario: "User submits bid(100 SOL) for an NFT auction. A validator sees the \
                pending transaction and submits bid(101 SOL) with higher priority fees. The \
                validator wins the auction by exactly outbidding the user.".to_string(),
            real_world_incident: None,
            secure_fix: "Implement a commit-reveal scheme: (1) User submits hash(bid + salt) in \
                commit phase, (2) User reveals bid + salt in reveal phase. The bid value is \
                hidden during the commit phase.".to_string(),
            confidence: 50,
            prevention: "Use commit-reveal for any operation where the submitted value gives \
                an advantage to observers. Hide sensitive data until the execution phase."
                .to_string(),
        });
    }
    None
}

fn check_amount_validation(code: &str) -> Option<VulnerabilityFinding> {
    // transfer/withdraw with unchecked amount param
    let has_value_transfer = (code.contains("transfer") || code.contains("withdraw") || code.contains("send"))
        && (code.contains("CpiContext") || code.contains("invoke") || code.contains("borrow_mut"));
    let validates_amount = code.contains("amount >") || code.contains("amount >=")
        || code.contains("amount !=" ) || code.contains("require!(")
        || code.contains("amount.checked") || code.contains("ensure!");
    let has_amount_param = code.contains("amount:") || code.contains("amount,");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if has_value_transfer && !validates_amount && has_amount_param && !is_test {
        return Some(VulnerabilityFinding {
            category: "Input Validation".to_string(),
            vuln_type: "Missing Amount Validation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-036".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A transfer/withdraw instruction accepts an `amount` parameter from the caller without validation. Zero amounts can be used for griefing (filling transaction logs, triggering unnecessary state changes). Amounts exceeding the balance will cause the CPI to fail with a runtime error instead of a clean program error. Validate `amount > 0 && amount <= available_balance` before processing.".to_string(),
            attack_scenario: "Attacker calls the instruction with `amount = 0` repeatedly to spam the transaction log and waste compute units. Alternatively, they call with `amount = u64::MAX` to trigger ungraceful failures that may leave program state in an inconsistent intermediate state if earlier state mutations weren't rolled back.".to_string(),
            real_world_incident: None,
            secure_fix: "`require!(amount > 0, ErrorCode::ZeroAmount); require!(amount <= vault.balance, ErrorCode::InsufficientFunds);` before any state mutation or CPI.".to_string(),
            confidence: 50,
            prevention: "Validate all instruction input parameters at the top of every handler. For amounts: check > 0, <= balance, and within any protocol-defined limits.".to_string(),
        });
    }
    None
}

fn check_div_before_mul(code: &str) -> Option<VulnerabilityFinding> {
    // per-line ` / ... * ` in financial code — can't just find first '/' and '*'
    // (those match path separators, deref operators, etc.)
    let has_financial = code.contains("amount") || code.contains("balance")
        || code.contains("price") || code.contains("rate")
        || code.contains("fee") || code.contains("reward");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_financial {
            for line in code.lines() {
            let trimmed = line.trim();
            if trimmed.starts_with("//") || trimmed.starts_with("/*") || trimmed.starts_with('*') {
                continue;
            }

            if let Some(div_pos) = trimmed.find(" / ") {
                let after_div = &trimmed[div_pos + 3..];
                if after_div.contains(" * ") {
                    return Some(VulnerabilityFinding {
                        category: "Arithmetic".to_string(),
                        vuln_type: "Division Before Multiplication".to_string(),
                        severity: 3,
                        severity_label: "MEDIUM".to_string(),
                        id: "SOL-037".to_string(),
                        cwe: Some("CWE-682".to_string()),
                        location: String::new(),
                        function_name: String::new(),
                        line_number: 0,
                        vulnerable_code: String::new(),
                        description: "An expression divides before multiplying (e.g., `a / b * c`). \
                            In integer arithmetic, this truncates the intermediate result, losing \
                            precision. For small values of `a`, `a / b` can truncate to 0, making \
                            the entire expression 0 regardless of `c`.".to_string(),
                        attack_scenario: "Protocol calculates fees as `amount / total_supply * fee_rate`. \
                            With amount=5 and total_supply=1000, `5 / 1000` truncates to 0, so \
                            no fee is charged. Attacker splits a large transfer into many small \
                            ones, each below the truncation threshold, paying zero fees.".to_string(),
                        real_world_incident: None,
                        secure_fix: "Reorder to multiply first: `a * c / b` or use u128 intermediate: \
                            `(a as u128 * c as u128 / b as u128) as u64`".to_string(),
                        confidence: 50,
            prevention: "Always multiply before dividing in integer arithmetic. Scale \
                            up values before division to preserve precision.".to_string(),
                    });
                }
            }
        }
    }
    None
}

fn check_precision_loss(code: &str) -> Option<VulnerabilityFinding> {
    let has_division = code.contains('/') && code.contains("u64");
    let uses_fixed = code.contains("Decimal") || code.contains("U256") || code.contains("u128");

    if has_division && !uses_fixed && code.contains("rate") {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Precision Loss".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-038".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Integer division causes precision loss in rates.".to_string(),
            attack_scenario: "Attacker exploits rounding for profit.".to_string(),
            real_world_incident: None,
            secure_fix: "Use higher precision types (u128) for intermediate calcs".to_string(),
            confidence: 50,
            prevention: "Scale values before division".to_string(),
        });
    }
    None
}

fn check_rounding_errors(code: &str) -> Option<VulnerabilityFinding> {
    let has_shares = code.contains("shares") || code.contains("pool_tokens");
    let has_division = code.contains('/');
    let rounds_correctly = code.contains("round_up") || code.contains("ceil");

    if has_shares && has_division && !rounds_correctly {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Rounding Direction Error".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-039".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Rounding direction may favor attacker.".to_string(),
            attack_scenario: "Attacker profits from repeated rounding errors.".to_string(),
            real_world_incident: None,
            secure_fix: "Round in favor of protocol, not user".to_string(),
            confidence: 50,
            prevention: "Always round against the user in financial ops".to_string(),
        });
    }
    None
}

fn check_zero_check(code: &str) -> Option<VulnerabilityFinding> {
    // any dynamic denominator (supply, shares, balance, etc) without != 0 guard
    let has_division = code.contains(" / ");
    let has_zero_check = code.contains("!= 0") || code.contains("> 0")
        || code.contains("require!") || code.contains("assert!")
        || code.contains(".checked_div");
    let has_dynamic_denominator = code.contains("supply")
        || code.contains("total_shares")
        || code.contains("denominator")
        || code.contains("divisor")
        || code.contains("pool_balance")
        || code.contains("total_staked");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_division && !has_zero_check && has_dynamic_denominator {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Missing Zero Divisor Check".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-040".to_string(),
            cwe: Some("CWE-369".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Division is performed using a dynamic denominator (supply, total_shares, \
                pool_balance) without checking if it's zero. On Solana's BPF runtime, division by \
                zero causes the program to panic, reverting the transaction. While this doesn't \
                corrupt state, it creates a denial-of-service vector: if an attacker can drain the \
                denominator to zero, all subsequent operations that use this value will fail."
                .to_string(),
            attack_scenario: "Attacker withdraws all liquidity from a pool, setting total_shares = 0. \
                Subsequent deposit attempts compute `amount / total_shares`, which panics. The pool \
                is bricked until someone manually adds shares through a separate code path (if one \
                exists).".to_string(),
            real_world_incident: None,
            secure_fix: "`require!(total_shares > 0, ErrorCode::PoolEmpty)` before division. Or use \
                `checked_div` which returns None on zero division.".to_string(),
            confidence: 50,
            prevention: "Always validate denominators before division. Use `checked_div` which returns \
                Option::None on zero division. Handle the empty-pool case explicitly.".to_string(),
        });
    }
    None
}

fn check_unrestricted_transfer(code: &str) -> Option<VulnerabilityFinding> {
    // transfer CPI without any auth
    let has_token_transfer = code.contains("token::transfer")
        || code.contains("system_instruction::transfer")
        || (code.contains("transfer(") && (code.contains("CpiContext") || code.contains("invoke")));
    let has_any_auth = code.contains("Signer")
        || code.contains("authority")
        || code.contains("admin")
        || code.contains("owner")
        || code.contains("require!")
        || code.contains("is_signer")
        || code.contains("#[account(signer)]")
        || code.contains("has_one")
        || code.contains("seeds =")
        || code.contains("constraint =")
        || code.contains("invoke_signed")
        || code.contains("payer")
        || code.contains("signer_seeds")
        || code.contains("access_control");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if has_token_transfer && !has_any_auth && !is_test {
        return Some(VulnerabilityFinding {
            category: "Authorization".to_string(),
            vuln_type: "Unrestricted Transfer".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-041".to_string(),
            cwe: Some("CWE-285".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A token or SOL transfer instruction (via `token::transfer`, `system_instruction::transfer`, or CPI `invoke`) has no authorization check. No `Signer<'info>` constraint, no `authority` field, no `require!()` guard. This means anyone can call this instruction and trigger the transfer — effectively draining the account.".to_string(),
            attack_scenario: "Attacker calls the transfer instruction with their own token account as the destination. Since no signer is required and no authority is checked, the BPF runtime processes the CPI, transferring tokens/SOL from the program's account to the attacker. This can be repeated in a loop within a single transaction to maximize drainage.".to_string(),
            real_world_incident: None,
            secure_fix: "Add `pub authority: Signer<'info>` to the Accounts struct and validate it against the stored authority: `#[account(has_one = authority @ ErrorCode::Unauthorized)]`. For PDA-signed transfers, use `invoke_signed()` with seeds that can only be derived by the program.".to_string(),
            confidence: 50,
            prevention: "Every instruction that moves value (transfers, burns, closes, authority changes) must validate the caller's authorization. Use `Signer<'info>` + `has_one` for user-initiated operations. Use PDA signing for program-initiated operations.".to_string(),
        });
    }
    None
}

fn check_pause_mechanism(code: &str) -> Option<VulnerabilityFinding> {
    // 2+ DeFi signals (swap, pool, vault, etc) without a pause flag
    let defi_signals = [
        code.contains("swap"), code.contains("deposit"), code.contains("withdraw"),
        code.contains("pool"), code.contains("vault"), code.contains("liquidity"),
        code.contains("stake"), code.contains("lend"),
    ];
    let defi_signal_count = defi_signals.iter().filter(|&&x| x).count();
    let has_pause = code.contains("paused")
        || code.contains("is_active")
        || code.contains("emergency")
        || code.contains("frozen")
        || code.contains("halt")
        || code.contains("enabled")
        || code.contains("disabled")
        || code.contains("state.active")
        || code.contains("is_paused");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");
    let is_handler = code.contains("pub fn ") && code.contains("Context<");

    if defi_signal_count >= 3 && !has_pause && !is_test && is_handler {
        return Some(VulnerabilityFinding {
            category: "Protocol Safety".to_string(),
            vuln_type: "Missing Pause Mechanism".to_string(),
            severity: 1,
            severity_label: "INFO".to_string(),
            id: "SOL-042".to_string(),
            cwe: Some("CWE-754".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "This DeFi program (handling deposits/withdrawals/swaps/liquidity) has no emergency pause mechanism. If an exploit is discovered, there is no way to halt the program while a fix is deployed. Every major DeFi protocol (Marinade, Solend, Mango) has been exploited and used pause mechanisms to limit damage.".to_string(),
            attack_scenario: "An exploit is discovered in production. The team has a fix but needs 2-4 hours to deploy. Without a pause mechanism, the attacker continues draining funds during this window. With a pause, the team freezes the protocol in one transaction, deploys the fix, then unpauses.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Solend".to_string(),
                loss: "Prevented via pause".to_string(),
                date: "2022-06-19".to_string(),
            }),
            secure_fix: "Add a `paused: bool` field to your global state account. Check it at the start of every instruction: `require!(!state.paused, ErrorCode::ProtocolPaused)`. Add `pause()` and `unpause()` instructions gated by an admin `Signer<'info>`. Consider a timelock on unpause.".to_string(),
            confidence: 50,
            prevention: "Every DeFi protocol should have an emergency pause. Gate it behind a multisig or governance mechanism. Test the pause flow in integration tests.".to_string(),
        });
    }
    None
}

fn check_hardcoded_address(code: &str) -> Option<VulnerabilityFinding> {
    // hardcoded custom pubkeys that should be in config state
    // (system program, spl_token etc are fine)
    let has_pubkey_literal = code.contains("Pubkey::from_str(")
        || code.contains("pubkey!(")
        || code.contains("declare_id!(");
    let is_well_known = code.contains("system_program")
        || code.contains("spl_token")
        || code.contains("token_program")
        || code.contains("associated_token")
        || code.contains("declare_id");
    let has_configurable = code.contains("admin") || code.contains("fee_recipient")
        || code.contains("treasury") || code.contains("oracle_address");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_pubkey_literal && !is_well_known && has_configurable {
        return Some(VulnerabilityFinding {
            category: "Code Quality".to_string(),
            vuln_type: "Hardcoded Address".to_string(),
            severity: 1,
            severity_label: "INFO".to_string(),
            id: "SOL-043".to_string(),
            cwe: Some("CWE-798".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A configurable address (admin, fee recipient, treasury, oracle) is \
                hardcoded as a pubkey literal. If the address needs to change (key rotation, \
                oracle migration), a full program upgrade is required. Store configurable \
                addresses in a program state account that can be updated by an admin.".to_string(),
            attack_scenario: "The hardcoded admin key is compromised. The team cannot rotate \
                to a new key without upgrading the entire program, which takes time (especially \
                with a governance timelock). During this window, the attacker has admin access."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Store the address in a program config account: `pub struct Config { \
                pub admin: Pubkey, pub treasury: Pubkey }`. Add an update instruction gated by \
                the current admin's Signer.".to_string(),
            confidence: 50,
            prevention: "Never hardcode addresses that might need to change. Use program state \
                accounts for all configurable addresses. Only well-known program IDs (System, \
                SPL Token) should be hardcoded.".to_string(),
        });
    }
    None
}

fn check_event_emission(code: &str) -> Option<VulnerabilityFinding> {
    // financial state change (transfer/deposit/withdraw) without emit!/msg!
    let has_state_mutation = (code.contains("transfer") || code.contains("deposit") || code.contains("withdraw"))
        && (code.contains("borrow_mut") || code.contains("CpiContext") || code.contains("invoke"));
    let emits_event = code.contains("emit!")
        || code.contains("msg!")
        || code.contains("#[event]")
        || code.contains("Event ")
        || code.contains("log_instruction")
        || code.contains("sol_log")
        || code.contains("emit_cpi");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if has_state_mutation && !emits_event && !is_test {
        return Some(VulnerabilityFinding {
            category: "Observability".to_string(),
            vuln_type: "Missing Event Emission".to_string(),
            severity: 2,
            severity_label: "LOW".to_string(),
            id: "SOL-044".to_string(),
            cwe: None,
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Financial state changes (transfers, deposits, withdrawals) are made without emitting Anchor events (`emit!(EventName {...})`) or Solana logs (`msg!()`). This makes it impossible for off-chain indexers, monitoring systems, and forensic tools to track protocol activity. In a post-exploit scenario, the lack of events means the team cannot reconstruct what happened.".to_string(),
            attack_scenario: "An exploit drains protocol funds. The team tries to analyze what happened but there are no on-chain event logs to trace the attacker's transactions. They must manually decode instruction data from each transaction — a process that takes days instead of minutes.".to_string(),
            real_world_incident: None,
            secure_fix: "Define events with `#[event]` and emit them after every significant state change: `emit!(DepositEvent { user: ctx.accounts.user.key(), amount, timestamp: Clock::get()?.unix_timestamp });`".to_string(),
            confidence: 50,
            prevention: "Every instruction that modifies balances, authorities, or protocol parameters should emit a structured event. Use Anchor's `#[event]` macro for type-safe events that indexers can parse.".to_string(),
        });
    }
    None
}

fn check_unsafe_math(code: &str) -> Option<VulnerabilityFinding> {
    // .pow() on numeric types without checked_pow
    let has_pow = code.contains(".pow(") || code.contains("pow(");
    let has_numeric_context = code.contains("u64") || code.contains("u128") || code.contains("i64");
    let has_protection = code.contains("checked_pow") || code.contains("saturating_pow")
        || code.contains("overflow");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && has_pow && has_numeric_context && !has_protection {
        return Some(VulnerabilityFinding {
            category: "Arithmetic".to_string(),
            vuln_type: "Unsafe Exponentiation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-045".to_string(),
            cwe: Some("CWE-190".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "`.pow()` is called on an integer type without overflow protection. \
                Exponentiation grows extremely fast — `2u64.pow(63)` overflows. In Solana's \
                release-mode BPF compilation, this wraps silently. If the exponent is \
                user-controlled, an attacker can cause overflow.".to_string(),
            attack_scenario: "Protocol calculates compound interest as `base.pow(periods)`. \
                Attacker provides periods=65, causing u64 overflow. The wrapped result is a \
                small number, allowing the attacker to repay a loan for virtually nothing."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Use `checked_pow`: `base.checked_pow(exp).ok_or(ErrorCode::Overflow)?`. \
                Also validate the exponent is within reasonable bounds.".to_string(),
            confidence: 50,
            prevention: "Always use `checked_pow` for exponentiation. Validate exponent bounds. \
                Consider using fixed-point libraries for compound calculations.".to_string(),
        });
    }
    None
}

fn check_time_manipulation(code: &str) -> Option<VulnerabilityFinding> {
    let uses_clock = code.contains("Clock::get") || code.contains("unix_timestamp");
    let is_critical = code.contains("lock") || code.contains("vest") || code.contains("deadline");
    let has_buffer = code.contains("buffer") || code.contains("tolerance");

    if uses_clock && is_critical && !has_buffer {
        return Some(VulnerabilityFinding {
            category: "Time Safety".to_string(),
            vuln_type: "Time Manipulation Risk".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-046".to_string(),
            cwe: Some("CWE-367".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Time-sensitive operation without tolerance.".to_string(),
            attack_scenario: "Validator manipulates slot time for advantage.".to_string(),
            real_world_incident: None,
            secure_fix: "Add time buffer for critical operations".to_string(),
            confidence: 50,
            prevention: "Don't rely on exact timestamps".to_string(),
        });
    }
    None
}

fn check_access_control(code: &str) -> Option<VulnerabilityFinding> {
    // Primary: AST-based analysis
    if !ast_checks::ast_has_missing_access_control(code) {
        return None;
    }

    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");
    if is_test {
        return None;
    }

    Some(VulnerabilityFinding {
        category: "Authorization".to_string(),
        vuln_type: "Missing Access Control".to_string(),
        severity: 5,
        severity_label: "CRITICAL".to_string(),
        id: "SOL-047".to_string(),
        cwe: Some("CWE-862".to_string()),
        location: String::new(),
        function_name: String::new(),
        line_number: 0,
        vulnerable_code: String::new(),
        description: "State modification without access control — function mutates state via borrow_mut/serialize/set_* without any Signer constraint, has_one, or require! check in scope.".to_string(),
        attack_scenario: "Anyone can call this instruction and modify protected state.".to_string(),
        real_world_incident: Some(crate::Incident {
            project: "Wormhole".to_string(),
            loss: "$320M".to_string(),
            date: "2022-02-02".to_string(),
        }),
        secure_fix: "Validate caller is authorized signer. Add `Signer<'info>` and `has_one` constraint.".to_string(),
        confidence: 80,
        prevention: "Always check authorization before state changes.".to_string(),
    })
}

fn check_account_hijacking(code: &str) -> Option<VulnerabilityFinding> {
    // keypair-based create_account is frontrunnable; PDA init is safe
    let creates_keypair_account = code.contains("create_account")
        && !code.contains("seeds =")
        && !code.contains("find_program_address")
        && !code.contains("#[account(init")
        && !code.contains("create_program_address")
        && !code.contains("Pubkey::create_with_seed")
        && !code.contains("system_instruction::create_account");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && creates_keypair_account {
        return Some(VulnerabilityFinding {
            category: "Account Security".to_string(),
            vuln_type: "Account Hijacking Risk".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-048".to_string(),
            cwe: Some("CWE-287".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account is created at a keypair address (not a PDA). An attacker who \
                observes the target address in the mempool can front-run the creation by sending \
                lamports to the address first (making it 'already initialized'). The legitimate \
                create_account instruction then fails. Use PDAs with deterministic seeds instead."
                .to_string(),
            attack_scenario: "User's transaction includes create_account for a new keypair. \
                Attacker sees the pending transaction, extracts the target address, and sends \
                lamports to it. When the user's transaction executes, create_account fails because \
                the account already has lamports. The user must generate a new keypair and retry."
                .to_string(),
            real_world_incident: None,
            secure_fix: "Use PDAs with deterministic seeds: `#[account(init, seeds = [b\"state\", \
                user.key().as_ref()], bump, payer = user)]`. PDAs cannot be front-run because their \
                address is derived from the program ID.".to_string(),
            confidence: 50,
            prevention: "Always use PDA-derived addresses for program accounts. Never use keypair-based \
                accounts that require a separate create_account instruction.".to_string(),
        });
    }
    None
}

fn check_lp_manipulation(code: &str) -> Option<VulnerabilityFinding> {
    let is_lp = code.contains("lp_token") || code.contains("pool_token") || code.contains("shares");
    let has_invariant = code.contains("k_before")
        || code.contains("invariant")
        || code.contains("constant_product");

    if is_lp && !has_invariant && code.contains("mint") {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "LP Token Manipulation".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-049".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "LP token calculation may be manipulated.".to_string(),
            attack_scenario: "First depositor attack or ratio manipulation.".to_string(),
            real_world_incident: None,
            secure_fix: "Check invariants before and after LP operations".to_string(),
            confidence: 50,
            prevention: "Initialize pools with minimum liquidity".to_string(),
        });
    }
    None
}

fn check_reward_calculation(code: &str) -> Option<VulnerabilityFinding> {
    let is_staking = code.contains("reward") || code.contains("stake");
    let time_based = code.contains("timestamp") || code.contains("duration");
    let validates = code.contains("elapsed") && code.contains("checked");

    if is_staking && time_based && !validates {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "Reward Calculation Error".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-050".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Reward calculation may have timing issues.".to_string(),
            attack_scenario: "Attacker games reward timing for extra rewards.".to_string(),
            real_world_incident: None,
            secure_fix: "Use checked arithmetic for reward calculations".to_string(),
            confidence: 50,
            prevention: "Validate time deltas and handle edge cases".to_string(),
        });
    }
    None
}

fn check_deadline(code: &str) -> Option<VulnerabilityFinding> {
    let is_swap = code.contains("swap") || code.contains("trade");
    let has_deadline = code.contains("deadline") || code.contains("expires");

    if is_swap && !has_deadline {
        return Some(VulnerabilityFinding {
            category: "Transaction Safety".to_string(),
            vuln_type: "Missing Deadline Check".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-051".to_string(),
            cwe: Some("CWE-367".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Transaction has no expiry deadline.".to_string(),
            attack_scenario: "Stale transactions execute at unfavorable prices.".to_string(),
            real_world_incident: None,
            secure_fix: "Add deadline parameter and validate".to_string(),
            confidence: 50,
            prevention: "All user-facing txs should have deadlines".to_string(),
        });
    }
    None
}

fn check_governance_attack(code: &str) -> Option<VulnerabilityFinding> {
    // actual governance instructions (not just the word 'vote')
    let is_gov = (code.contains("proposal") && code.contains("fn vote"))
        || (code.contains("governance") && (code.contains("execute_proposal") || code.contains("cast_vote")))
        || (code.contains("fn create_proposal") || code.contains("fn execute_proposal"));
    let has_timelock = code.contains("timelock") || code.contains("execution_delay")
        || code.contains("cooldown_period");
    let has_quorum = code.contains("quorum") || code.contains("threshold")
        || code.contains("min_votes");
    let is_test = code.contains("#[cfg(test)]") || code.contains("#[test]");

    if !is_test && is_gov && (!has_timelock || !has_quorum) {
        return Some(VulnerabilityFinding {
            category: "Governance".to_string(),
            vuln_type: "Governance Attack".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-052".to_string(),
            cwe: Some("CWE-284".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Governance system is missing a timelock or quorum requirement. Without \
                a timelock, proposals can be created and executed in the same block. Without a \
                quorum, a single large token holder can pass proposals unilaterally. Both enable \
                flash loan governance attacks where an attacker borrows tokens, votes, executes, \
                and repays in one transaction.".to_string(),
            attack_scenario: "Attacker flash-borrows governance tokens from a lending pool. Creates \
                a proposal to drain the treasury. Votes with the borrowed tokens (meeting the \
                threshold since quorum is missing or low). Executes the proposal immediately (no \
                timelock). Repays the flash loan. Net cost: only the flash loan fee.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Beanstalk".to_string(),
                loss: "$182M".to_string(),
                date: "2022-04-17".to_string(),
            }),
            secure_fix: "Implement both: (1) Timelock: `require!(proposal.created_at + VOTING_PERIOD \
                < clock.unix_timestamp, ErrorCode::VotingPeriodActive)` before execution. \
                (2) Quorum: `require!(proposal.votes_for >= MIN_QUORUM, ErrorCode::QuorumNotMet)`. \
                (3) Use token snapshots, not live balances, for vote weight.".to_string(),
            confidence: 50,
            prevention: "All governance systems need: timelock (>= 24h), quorum requirements, \
                vote-weight snapshots at proposal creation, and a separate execution step."
                .to_string(),
        });
    }
    None
}

// ─── SOL-053 to SOL-072: Advanced Solana-Specific Detectors ─────────────────

fn check_close_resurrection(code: &str) -> Option<VulnerabilityFinding> {
    let has_close = code.contains("close =") || code.contains("close_account")
        || (code.contains("lamports") && code.contains("set_lamports(0)"));
    let has_cpi_after = code.contains("invoke(") || code.contains("invoke_signed(")
        || code.contains("CpiContext");
    let missing_revalidation = !code.contains("reload()")
        && !code.contains("try_borrow_data")
        && !code.contains("CLOSED_ACCOUNT_DISCRIMINATOR");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && has_close && has_cpi_after && missing_revalidation {
        return Some(VulnerabilityFinding {
            category: "Account Lifecycle".to_string(),
            vuln_type: "Close Account Resurrection".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-053".to_string(),
            cwe: Some("CWE-672".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Account is closed (lamports drained) but a subsequent CPI within the \
                same transaction can resurrect it. The Solana runtime only garbage-collects \
                zero-lamport accounts at slot boundaries, so within the same slot a CPI can \
                transfer lamports back, reviving the account with stale data.".to_string(),
            attack_scenario: "TX1: Close victim's account (drain lamports). TX2 (same slot): \
                Transfer 1 lamport back via CPI. The account data is still intact because GC \
                hasn't run. Attacker replays the old state to double-withdraw.".to_string(),
            real_world_incident: None,
            secure_fix: "After closing, set the discriminator to CLOSED_ACCOUNT_DISCRIMINATOR \
                and zero all data. Revalidate account state after any CPI with `reload()`.".to_string(),
            confidence: 55,
            prevention: "Use Anchor's `close` constraint which zeroes data. After CPI calls, \
                always reload and recheck account state.".to_string(),
        });
    }
    None
}

fn check_program_impersonation(code: &str) -> Option<VulnerabilityFinding> {
    let has_cpi = code.contains("invoke(") || code.contains("invoke_signed(");
    let passes_program_info = code.contains("AccountInfo") && has_cpi;
    let validates_program = code.contains("Program<")
        || code.contains("token::ID")
        || code.contains("system_program::ID")
        || code.contains("spl_token::id()")
        || code.contains("program.key() ==")
        || code.contains("Token::id()")
        || code.contains("anchor_spl")
        || code.contains("require_keys_eq");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && passes_program_info && !validates_program {
        return Some(VulnerabilityFinding {
            category: "CPI Security".to_string(),
            vuln_type: "System/Token Program Impersonation".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-054".to_string(),
            cwe: Some("CWE-290".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "A CPI target program is passed as unvalidated AccountInfo. An attacker \
                can substitute a malicious program that mimics the System Program or SPL Token \
                interface but redirects funds to the attacker.".to_string(),
            attack_scenario: "Attacker deploys a fake token program that accepts transfer \
                instructions but sends tokens to the attacker's account. Passes this as the \
                token_program AccountInfo. The invoke() call succeeds with the wrong program.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Crema Finance".to_string(),
                loss: "$8.8M".to_string(),
                date: "2022-07-03".to_string(),
            }),
            secure_fix: "Use Anchor's `Program<'info, Token>` for typed validation, or manually \
                check: `require!(program.key() == spl_token::ID)`".to_string(),
            confidence: 55,
            prevention: "Never pass unvalidated program AccountInfo to invoke(). Use typed \
                Program<> wrappers.".to_string(),
        });
    }
    None
}

fn check_token2022_hook(code: &str) -> Option<VulnerabilityFinding> {
    let uses_token2022 = code.contains("token_2022") || code.contains("Token2022")
        || code.contains("spl_token_2022") || code.contains("TokenExtension");
    let has_transfer = code.contains("transfer") || code.contains("Transfer");
    let checks_hook = code.contains("transfer_hook")
        || code.contains("TransferHook")
        || code.contains("get_transfer_hook")
        || code.contains("execute_transfer_hook");
    let has_state_before_transfer = code.contains("checked_sub")
        || code.contains("balance -=")
        || code.contains("amount -=");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && uses_token2022 && has_transfer && !checks_hook && has_state_before_transfer {
        return Some(VulnerabilityFinding {
            category: "Token2022 Security".to_string(),
            vuln_type: "Transfer Hook Reentrancy".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-055".to_string(),
            cwe: Some("CWE-841".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token2022 transfer hooks execute arbitrary code during transfers. If \
                state is modified before the transfer CPI, the hook program could re-enter and \
                observe inconsistent state, enabling reentrancy-style attacks.".to_string(),
            attack_scenario: "Program deducts internal balance, then calls Token2022 transfer. \
                The transfer hook re-enters the program's withdraw function, which sees the \
                reduced balance but token account hasn't been debited yet.".to_string(),
            real_world_incident: None,
            secure_fix: "Apply checks-effects-interactions pattern: validate, update state, \
                then perform transfer. Check for transfer hooks with \
                `get_transfer_hook()` and handle reentrancy guards.".to_string(),
            confidence: 50,
            prevention: "Always audit Token2022 mint extensions. Add reentrancy guards \
                when interacting with tokens that have transfer hooks.".to_string(),
        });
    }
    None
}

fn check_token2022_fees(code: &str) -> Option<VulnerabilityFinding> {
    let uses_token2022 = code.contains("token_2022") || code.contains("Token2022")
        || code.contains("spl_token_2022");
    let has_transfer = code.contains("transfer") && code.contains("amount");
    let checks_fee = code.contains("transfer_fee")
        || code.contains("TransferFee")
        || code.contains("get_epoch_fee")
        || code.contains("calculate_fee")
        || code.contains("fee_amount")
        || code.contains("withheld_amount");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && uses_token2022 && has_transfer && !checks_fee {
        return Some(VulnerabilityFinding {
            category: "Token2022 Security".to_string(),
            vuln_type: "Transfer Fee Accounting Mismatch".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-056".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token2022 tokens with the TransferFee extension deduct fees \
                automatically during transfer. If the program assumes the recipient receives \
                the full amount, accounting will be incorrect.".to_string(),
            attack_scenario: "DEX records a deposit of 100 tokens, but Token2022 deducted a \
                2% fee. Only 98 tokens arrived. User withdraws 100, draining the pool of \
                2 extra tokens per transaction.".to_string(),
            real_world_incident: None,
            secure_fix: "Query the TransferFee extension: \
                `get_epoch_fee(&mint_data, epoch)` to calculate the actual received amount. \
                Use post-transfer balance checks.".to_string(),
            confidence: 50,
            prevention: "Always check mint extensions before transfers. Account for fees \
                by comparing pre/post balances or querying the fee config.".to_string(),
        });
    }
    None
}

fn check_permanent_delegate(code: &str) -> Option<VulnerabilityFinding> {
    let uses_token2022 = code.contains("token_2022") || code.contains("Token2022")
        || code.contains("spl_token_2022");
    let has_delegate = code.contains("delegate") || code.contains("approve");
    let checks_permanent = code.contains("PermanentDelegate")
        || code.contains("permanent_delegate")
        || code.contains("get_permanent_delegate");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && uses_token2022 && has_delegate && !checks_permanent {
        return Some(VulnerabilityFinding {
            category: "Token2022 Security".to_string(),
            vuln_type: "Permanent Delegate Exposure".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-057".to_string(),
            cwe: Some("CWE-732".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Token2022's PermanentDelegate extension allows a designated authority \
                to transfer or burn tokens from ANY account holding that mint, without holder \
                approval. Programs must check for this extension before accepting deposits.".to_string(),
            attack_scenario: "User deposits Token2022 tokens with PermanentDelegate into a vault. \
                The mint authority uses PermanentDelegate to transfer tokens out of the vault \
                without the program's consent, draining user deposits.".to_string(),
            real_world_incident: None,
            secure_fix: "Check for PermanentDelegate extension on mint accounts: \
                `get_permanent_delegate(&mint_data)`. Reject or warn on mints with this extension \
                unless explicitly whitelisted.".to_string(),
            confidence: 50,
            prevention: "Audit all Token2022 mint extensions before accepting deposits. \
                Reject mints with PermanentDelegate unless trust is established.".to_string(),
        });
    }
    None
}

fn check_flash_loan_v2(code: &str) -> Option<VulnerabilityFinding> {
    let has_price_calc = code.contains("price") || code.contains("rate")
        || code.contains("exchange_rate") || code.contains("spot_price");
    let uses_balance = code.contains("get_balance") || code.contains("token_account")
        || code.contains(".amount") || code.contains("supply");
    let has_twap = code.contains("twap") || code.contains("TWAP")
        || code.contains("time_weighted") || code.contains("moving_average")
        || code.contains("oracle") || code.contains("pyth");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && has_price_calc && uses_balance && !has_twap {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "Flash Loan Price Manipulation".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-058".to_string(),
            cwe: Some("CWE-682".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Price or exchange rate is calculated from spot balances without \
                TWAP or oracle validation. A flash loan can temporarily inflate/deflate pool \
                balances within a single transaction to manipulate the price.".to_string(),
            attack_scenario: "Attacker flash-borrows 10M USDC → dumps into pool → spot price \
                crashes → buys cheap at manipulated price → repays flash loan → profits.".to_string(),
            real_world_incident: Some(crate::Incident {
                project: "Mango Markets".to_string(),
                loss: "$114M".to_string(),
                date: "2022-10-11".to_string(),
            }),
            secure_fix: "Use TWAP oracles (Pyth, Switchboard) instead of spot balances. \
                Add minimum time delays between price reads and actions.".to_string(),
            confidence: 45,
            prevention: "Never derive prices from instantaneous pool balances. Use \
                time-weighted averages or signed oracle feeds.".to_string(),
        });
    }
    None
}

fn check_state_machine(code: &str) -> Option<VulnerabilityFinding> {
    let has_multi_step = (code.contains("initialize") && code.contains("finalize"))
        || (code.contains("deposit") && code.contains("withdraw"))
        || (code.contains("open") && code.contains("close"))
        || (code.contains("start") && code.contains("end"))
        || (code.contains("create") && code.contains("execute"));
    let has_state_enum = code.contains("enum State") || code.contains("enum Status")
        || code.contains("state:") || code.contains("status:");
    let validates_state = code.contains("require!(state ==")
        || code.contains("match state")
        || code.contains("match self.state")
        || code.contains("Status::")
        || code.contains("State::");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && has_multi_step && !has_state_enum && !validates_state {
        return Some(VulnerabilityFinding {
            category: "Logic Security".to_string(),
            vuln_type: "Missing State Machine".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-059".to_string(),
            cwe: Some("CWE-841".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Multi-step instruction flow (init→deposit→finalize) lacks a state \
                machine to enforce ordering. Instructions can be called out-of-order, \
                skipping required preconditions.".to_string(),
            attack_scenario: "Protocol has init→deposit→finalize flow. Attacker calls finalize \
                directly without depositing, claiming rewards without providing collateral.".to_string(),
            real_world_incident: None,
            secure_fix: "Add an enum State { Initialized, Active, Finalized } and validate \
                transitions: `require!(account.state == State::Active)`.".to_string(),
            confidence: 45,
            prevention: "All multi-step processes need explicit state tracking with \
                validated transitions.".to_string(),
        });
    }
    None
}

fn check_event_spoofing(code: &str) -> Option<VulnerabilityFinding> {
    let emits_events = code.contains("emit!") || code.contains("msg!") || code.contains("sol_log");
    let has_cpi = code.contains("invoke(") || code.contains("CpiContext");
    let validates_emitter = code.contains("program_id ==")
        || code.contains("emitter")
        || code.contains("msg_sender");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && emits_events && has_cpi && !validates_emitter {
        return Some(VulnerabilityFinding {
            category: "Event Security".to_string(),
            vuln_type: "Event Log Spoofing".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-060".to_string(),
            cwe: Some("CWE-290".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Program emits events (emit!/msg!) but a CPI'd program can also emit \
                events that appear to come from this program. Off-chain indexers may \
                incorrectly attribute spoofed events.".to_string(),
            attack_scenario: "Malicious CPI target emits fake 'Transfer' events. Indexers \
                record phantom transfers that didn't actually occur on-chain.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate event sources off-chain by checking instruction program IDs. \
                Use Anchor's `emit!` with typed events for better indexer filtering.".to_string(),
            confidence: 40,
            prevention: "Off-chain consumers must verify the emitting program ID. \
                Use structured event schemas.".to_string(),
        });
    }
    None
}

fn check_cu_exhaustion(code: &str) -> Option<VulnerabilityFinding> {
    let has_loops = code.contains("for ") || code.contains("while ")
        || code.contains(".iter()") || code.contains(".map(");
    let has_state_mutation = code.contains("mut ") && (code.contains("+=") || code.contains("-=")
        || code.contains("= ") || code.contains("push("));
    let has_cu_check = code.contains("compute_budget")
        || code.contains("sol_remaining_compute_units")
        || code.contains("ComputeBudget");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && has_loops && has_state_mutation && !has_cu_check {
        return Some(VulnerabilityFinding {
            category: "Resource Safety".to_string(),
            vuln_type: "Compute Unit Exhaustion with Partial State".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-061".to_string(),
            cwe: Some("CWE-400".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Loop processes items while mutating state. If compute units run out \
                mid-loop, the transaction fails but on-chain state may be partially updated \
                (Solana does NOT roll back on CU exhaustion in inner instructions).".to_string(),
            attack_scenario: "Attacker provides a large input array. The loop processes 10 of 100 \
                items before CU exhaustion. Those 10 state changes persist, creating an \
                inconsistent state that can be exploited in subsequent transactions.".to_string(),
            real_world_incident: None,
            secure_fix: "Add CU consumption checks in loops, or use pagination/cranking patterns. \
                Process items in fixed-size batches.".to_string(),
            confidence: 45,
            prevention: "Bound loop iterations. Use pagination for large datasets. Check \
                remaining CU budget with `sol_remaining_compute_units()`.".to_string(),
        });
    }
    None
}

fn check_unbounded_input(code: &str) -> Option<VulnerabilityFinding> {
    let has_vec_input = code.contains("Vec<") && (code.contains("pub fn ") || code.contains("fn process"));
    let has_length_check = code.contains(".len() <")
        || code.contains(".len() <=")
        || code.contains(".len() >")
        || code.contains("MAX_")
        || code.contains("max_len")
        || code.contains("require!(items.len")
        || code.contains("max_accounts");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && has_vec_input && !has_length_check {
        return Some(VulnerabilityFinding {
            category: "Input Validation".to_string(),
            vuln_type: "Unbounded Input Length".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-062".to_string(),
            cwe: Some("CWE-400".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Instruction accepts Vec<> input without length bounds. An attacker \
                can pass an extremely large array to consume all compute units or cause \
                excessive memory allocation.".to_string(),
            attack_scenario: "Attacker passes a Vec with 10,000 elements. The instruction tries \
                to iterate and runs out of compute units, DOS-ing the program.".to_string(),
            real_world_incident: None,
            secure_fix: "Add length validation: `require!(items.len() <= MAX_ITEMS)`. \
                Define reasonable constants for maximum array sizes.".to_string(),
            confidence: 45,
            prevention: "Always validate collection lengths at instruction entry. Define \
                MAX_* constants for all bounded collections.".to_string(),
        });
    }
    None
}

fn check_remaining_accounts(code: &str) -> Option<VulnerabilityFinding> {
    let uses_remaining = code.contains("remaining_accounts")
        || code.contains("ctx.remaining_accounts");
    let validates_remaining = code.contains("remaining_accounts.iter()")
        && (code.contains(".key()") || code.contains("owner ==") || code.contains("is_signer"));
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && uses_remaining && !validates_remaining {
        return Some(VulnerabilityFinding {
            category: "Account Validation".to_string(),
            vuln_type: "Unvalidated remaining_accounts".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-063".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "The context uses `remaining_accounts` without validating the accounts' \
                ownership, signer status, or expected keys. These accounts bypass Anchor's \
                automatic validation, so ANY account can be passed.".to_string(),
            attack_scenario: "Program reads remaining_accounts[0] as a user's token account \
                without checking owner. Attacker passes a token account they own, redirecting \
                funds or spoofing identity.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate each remaining_account: check owner, key, signer status. \
                Prefer typed accounts in the Accounts struct over remaining_accounts.".to_string(),
            confidence: 55,
            prevention: "Minimize remaining_accounts usage. When required, validate each \
                account's owner, key, and writable/signer constraints explicitly.".to_string(),
        });
    }
    None
}

fn check_governance_bypass(code: &str) -> Option<VulnerabilityFinding> {
    let has_admin = code.contains("admin") || code.contains("authority")
        || code.contains("governance") || code.contains("multisig");
    let has_config_change = code.contains("set_authority") || code.contains("update_config")
        || code.contains("set_fee") || code.contains("set_admin")
        || code.contains("upgrade_authority");
    let has_timelock = code.contains("timelock") || code.contains("time_lock")
        || code.contains("delay") || code.contains("cooldown")
        || code.contains("pending_admin");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && has_admin && has_config_change && !has_timelock {
        return Some(VulnerabilityFinding {
            category: "Governance Security".to_string(),
            vuln_type: "Governance/Timelock Bypass".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-064".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Admin/authority can change critical protocol parameters (fees, \
                authority, config) without a timelock or governance delay. A compromised admin \
                key can instantly rug-pull users.".to_string(),
            attack_scenario: "Admin key is compromised (phishing, leaked private key). Attacker \
                immediately sets fee to 100%, drains all funds, and changes authority — all \
                in a single transaction. Users have no time to react.".to_string(),
            real_world_incident: None,
            secure_fix: "Implement two-step authority changes with timelock: \
                propose_change → wait(DELAY) → execute_change. \
                Use multisig for admin keys.".to_string(),
            confidence: 50,
            prevention: "All admin operations should have timelocks (>= 24h). Use multisig \
                wallets. Implement two-step authority transfers.".to_string(),
        });
    }
    None
}

fn check_seed_collision(code: &str) -> Option<VulnerabilityFinding> {
    let has_pda = code.contains("find_program_address") || code.contains("seeds = [");
    let uses_short_seeds = code.contains("b\"") && has_pda;
    let has_unique_discriminator = code.contains("b\"user_")
        || code.contains("b\"vault_")
        || code.contains("b\"pool_")
        || code.contains("SEED_PREFIX");
    let multiple_pda_types = code.matches("seeds = [").count() >= 2
        || code.matches("find_program_address").count() >= 2;
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && multiple_pda_types && uses_short_seeds && !has_unique_discriminator {
        return Some(VulnerabilityFinding {
            category: "PDA Security".to_string(),
            vuln_type: "PDA Seed Collision".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-065".to_string(),
            cwe: Some("CWE-330".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Multiple PDA derivations use similar seed patterns without unique \
                type prefixes. If seeds overlap, different account types could derive to the \
                same address, causing state corruption.".to_string(),
            attack_scenario: "Program uses seeds=[user_key] for both 'balance' and 'config' \
                accounts. An attacker creates a 'config' account that collides with a \
                'balance' account, corrupting state.".to_string(),
            real_world_incident: None,
            secure_fix: "Add unique type prefixes: seeds = [b\"balance\", user.key()] vs \
                seeds = [b\"config\", admin.key()]. Use SEED_PREFIX constants.".to_string(),
            confidence: 40,
            prevention: "Always include a unique byte prefix per PDA type. Define SEED_PREFIX \
                constants to prevent typos.".to_string(),
        });
    }
    None
}

fn check_mev_protection(code: &str) -> Option<VulnerabilityFinding> {
    let is_defi = code.contains("swap") || code.contains("trade")
        || code.contains("exchange") || code.contains("amm");
    let has_slippage = code.contains("slippage") || code.contains("min_amount")
        || code.contains("minimum_out") || code.contains("max_price");
    let has_mev_protection = code.contains("jito") || code.contains("tip")
        || code.contains("bundle") || code.contains("priority_fee")
        || code.contains("ComputeBudgetInstruction");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && is_defi && !has_slippage && !has_mev_protection {
        return Some(VulnerabilityFinding {
            category: "MEV Security".to_string(),
            vuln_type: "Insufficient MEV Protection".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-066".to_string(),
            cwe: Some("CWE-362".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "DeFi swap/trade instruction lacks slippage protection and MEV \
                mitigation. Transactions are vulnerable to sandwich attacks where a \
                searcher front-runs and back-runs the user's trade for profit.".to_string(),
            attack_scenario: "User submits swap(100 SOL → USDC) without min_amount_out. MEV \
                bot front-runs with a large buy (pumps price), user swaps at inflated price, \
                bot back-runs with a sell. User receives fewer tokens.".to_string(),
            real_world_incident: None,
            secure_fix: "Require minimum output amount: \
                `require!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded)`. \
                Consider Jito bundles for MEV protection.".to_string(),
            confidence: 45,
            prevention: "All swap instructions must accept and enforce min_amount_out. \
                Educate users to set reasonable slippage tolerance.".to_string(),
        });
    }
    None
}

fn check_upgrade_authority_risk(code: &str) -> Option<VulnerabilityFinding> {
    let upgradeable = code.contains("upgrade_authority")
        || code.contains("UpgradeAuthority") || code.contains("BpfUpgradeable");
    let has_multisig = code.contains("multisig") || code.contains("Multisig")
        || code.contains("threshold") || code.contains("Squads");
    let has_immutable = code.contains("set_upgrade_authority_checked")
        || code.contains("None") && code.contains("authority");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && upgradeable && !has_multisig && !has_immutable {
        return Some(VulnerabilityFinding {
            category: "Authority Security".to_string(),
            vuln_type: "Single Wallet Upgrade Authority".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-067".to_string(),
            cwe: Some("CWE-269".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Program references an upgrade authority without multisig or \
                immutability checks. A single compromised wallet can silently upgrade the \
                program to a malicious version, stealing all user funds.".to_string(),
            attack_scenario: "Single-key upgrade authority wallet is compromised. Attacker \
                deploys malicious program update that drains all PDAs. By the time users \
                notice, funds are gone.".to_string(),
            real_world_incident: None,
            secure_fix: "Use multisig (Squads Protocol) for upgrade authority. For production: \
                either make immutable or use a governance-controlled upgrade process.".to_string(),
            confidence: 40,
            prevention: "Production programs should use multisig upgrade authority or be \
                made immutable. Never use a single EOA for upgradeable programs.".to_string(),
        });
    }
    None
}

fn check_freeze_auth_risk(code: &str) -> Option<VulnerabilityFinding> {
    let handles_tokens = code.contains("TokenAccount") || code.contains("token_account")
        || code.contains("Mint") || code.contains("spl_token");
    let checks_freeze = code.contains("freeze_authority")
        || code.contains("is_frozen")
        || code.contains("FreezeAccount")
        || code.contains("ThawAccount");
    let is_defi = code.contains("deposit") || code.contains("withdraw")
        || code.contains("swap") || code.contains("stake");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && handles_tokens && is_defi && !checks_freeze {
        return Some(VulnerabilityFinding {
            category: "Token Security".to_string(),
            vuln_type: "Unvalidated Freeze Authority".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-068".to_string(),
            cwe: Some("CWE-732".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "DeFi protocol accepts token deposits without checking if the mint \
                has a freeze authority. A freeze authority can freeze the protocol's token \
                accounts, permanently locking user funds.".to_string(),
            attack_scenario: "Users deposit USDC into a lending pool. The token mint's freeze \
                authority freezes the pool's token account. All deposits are permanently \
                locked — users can never withdraw.".to_string(),
            real_world_incident: None,
            secure_fix: "Check freeze authority: \
                `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` \
                or document the risk and implement contingency plans.".to_string(),
            confidence: 40,
            prevention: "Audit accepted token mints for freeze authority. Warn users or \
                reject tokens with active freeze authorities.".to_string(),
        });
    }
    None
}

fn check_cross_ix_duplicates(code: &str) -> Option<VulnerabilityFinding> {
    let has_instruction_data = code.contains("instruction_sysvar")
        || code.contains("Instructions")
        || code.contains("get_instruction_relative");
    let has_multiple_ix = code.contains("num_instructions")
        || code.contains("instruction_data");
    let validates_duplicates = code.contains("unique")
        || code.contains("dedup")
        || code.contains("HashSet")
        || code.contains("seen_accounts");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && has_instruction_data && has_multiple_ix && !validates_duplicates {
        return Some(VulnerabilityFinding {
            category: "Transaction Security".to_string(),
            vuln_type: "Cross-Instruction Duplicate Accounts".to_string(),
            severity: 5,
            severity_label: "CRITICAL".to_string(),
            id: "SOL-069".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Program inspects the instruction sysvar for multi-instruction \
                validation but doesn't check for duplicate accounts across instructions. \
                An attacker can pass the same account in multiple instructions within one \
                transaction to exploit state inconsistencies.".to_string(),
            attack_scenario: "Transaction bundles IX1(account=A, debit) and IX2(account=A, credit). \
                The program processes both against account A. The debit and credit may not \
                cancel out due to state mutation timing.".to_string(),
            real_world_incident: None,
            secure_fix: "Track seen accounts across instruction introspection. Use a HashSet \
                to detect and reject duplicate account usage.".to_string(),
            confidence: 45,
            prevention: "When using instruction introspection, validate account uniqueness \
                across all instructions in the transaction.".to_string(),
        });
    }
    None
}

fn check_versioned_tx(code: &str) -> Option<VulnerabilityFinding> {
    let uses_tx_introspection = code.contains("instruction_sysvar")
        || code.contains("get_instruction_relative")
        || code.contains("Instructions");
    let handles_v0 = code.contains("MessageV0")
        || code.contains("VersionedTransaction")
        || code.contains("v0::Message")
        || code.contains("address_lookup");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && uses_tx_introspection && !handles_v0 {
        return Some(VulnerabilityFinding {
            category: "Transaction Security".to_string(),
            vuln_type: "Legacy vs V0 Transaction Handling".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-070".to_string(),
            cwe: Some("CWE-436".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Program uses transaction introspection but doesn't handle versioned \
                (V0) transactions. V0 transactions use Address Lookup Tables which change \
                how account indices map to pubkeys, potentially causing incorrect account \
                resolution.".to_string(),
            attack_scenario: "Program validates that instruction N uses a specific account at \
                index I. With V0 transactions and ALTs, the same index maps to a different \
                account, bypassing the validation.".to_string(),
            real_world_incident: None,
            secure_fix: "Support both legacy and V0 transaction formats. Validate accounts \
                by pubkey, not by index.".to_string(),
            confidence: 35,
            prevention: "When using instruction introspection, validate by account pubkey \
                rather than array index. Support VersionedTransaction formats.".to_string(),
        });
    }
    None
}

fn check_alt_validation(code: &str) -> Option<VulnerabilityFinding> {
    let uses_alt = code.contains("address_lookup")
        || code.contains("AddressLookupTable")
        || code.contains("lookup_table");
    let validates_alt = code.contains("lookup_table.key()")
        || code.contains("freeze_authority")
        || code.contains("deactivation_slot")
        || code.contains("is_active");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && uses_alt && !validates_alt {
        return Some(VulnerabilityFinding {
            category: "Transaction Security".to_string(),
            vuln_type: "Address Lookup Table Trust".to_string(),
            severity: 3,
            severity_label: "MEDIUM".to_string(),
            id: "SOL-071".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "Program references Address Lookup Tables without validating the \
                table's authority, deactivation status, or contained addresses. A malicious \
                ALT could resolve to unexpected accounts.".to_string(),
            attack_scenario: "Attacker creates an ALT mapping index 0 to their own token \
                account instead of the protocol's. Uses this ALT in a V0 transaction to \
                redirect funds.".to_string(),
            real_world_incident: None,
            secure_fix: "Validate ALT address against a known whitelist. Check \
                `deactivation_slot` and `freeze_authority` to ensure the table is active \
                and controlled by a trusted authority.".to_string(),
            confidence: 35,
            prevention: "Whitelist trusted ALTs. Always validate the resolved addresses \
                against expected pubkeys.".to_string(),
        });
    }
    None
}

fn check_slippage_cap(code: &str) -> Option<VulnerabilityFinding> {
    let is_defi = code.contains("swap") || code.contains("exchange") || code.contains("trade");
    let has_slippage_param = code.contains("slippage") || code.contains("min_amount")
        || code.contains("maximum_slippage") || code.contains("min_out");
    let has_cap = code.contains("MAX_SLIPPAGE")
        || code.contains("max_slippage")
        || code.contains("slippage_bps <=")
        || code.contains("slippage_bps <")
        || code.contains("require!(slippage");
    let is_test = code.contains("#[test]") || code.contains("#[cfg(test)]");

    if !is_test && is_defi && has_slippage_param && !has_cap {
        return Some(VulnerabilityFinding {
            category: "DeFi Security".to_string(),
            vuln_type: "Missing Slippage Cap".to_string(),
            severity: 4,
            severity_label: "HIGH".to_string(),
            id: "SOL-072".to_string(),
            cwe: Some("CWE-20".to_string()),
            location: String::new(),
            function_name: String::new(),
            line_number: 0,
            vulnerable_code: String::new(),
            description: "DeFi instruction accepts a slippage parameter but doesn't enforce \
                a maximum cap. Users can pass 100% slippage (or 0 min_amount_out), making \
                their trades fully vulnerable to sandwich attacks.".to_string(),
            attack_scenario: "User's frontend has a bug and sends slippage=10000 (100%). \
                MEV bot sandwiches the trade, extracting maximum value. The protocol should \
                have rejected such extreme slippage at the program level.".to_string(),
            real_world_incident: None,
            secure_fix: "Enforce a maximum slippage cap: \
                `require!(slippage_bps <= MAX_SLIPPAGE_BPS, ErrorCode::SlippageTooHigh)`. \
                Typical max: 500 bps (5%).".to_string(),
            confidence: 50,
            prevention: "Always validate slippage parameters server-side. Define MAX_SLIPPAGE \
                constants. Never trust client-provided slippage without bounds checking.".to_string(),
        });
    }
    None
}

