//! Kani proof: Balance conservation for `handle_withdraw`
//! Auto-generated by kani-verifier — DO NOT EDIT
//! Source: lib.rs:42
//! Invariant: Token/SOL balance changes in 'handle_withdraw' must conserve total supply (no creation from nothing)

#[cfg(kani)]
mod kani_proofs {
    /// Verify that token transfers conserve total balance.
    /// For any transfer: sender_balance' + receiver_balance' == sender_balance + receiver_balance
    #[kani::proof]
    #[kani::unwind(16)]
    fn proof_handle_withdraw_balance_conservation() {
        // Symbolic account balances (before transfer)
        let sender_balance: u64 = kani::any();
        let receiver_balance: u64 = kani::any();
        let transfer_amount: u64 = kani::any();

        // Preconditions
        kani::assume(sender_balance <= 580_000_000_000_000_000u64);
        kani::assume(receiver_balance <= 580_000_000_000_000_000u64);
        kani::assume(transfer_amount > 0);
        kani::assume(transfer_amount <= sender_balance);

        // Total before
        let total_before = (sender_balance as u128) + (receiver_balance as u128);

        // Execute transfer
        let sender_after = sender_balance - transfer_amount;
        let receiver_after = receiver_balance.checked_add(transfer_amount);

        // Postcondition: total conservation
        if let Some(recv) = receiver_after {
            let total_after = (sender_after as u128) + (recv as u128);
            kani::assert(
                total_before == total_after,
                "Balance conservation violated: tokens created or destroyed"
            );

            // Verify no negative balance
            kani::assert(sender_after <= sender_balance, "Sender balance underflow");
        } else {
            // Receiver overflow — this itself is a bug
            kani::assert(false, "Receiver balance overflow — conservation cannot hold");
        }
    }

    /// Double-transfer conservation (A→B→C must conserve)
    #[kani::proof]
    #[kani::unwind(8)]
    fn proof_handle_withdraw_balance_conservation_transitive() {
        let balance_a: u64 = kani::any();
        let balance_b: u64 = kani::any();
        let balance_c: u64 = kani::any();
        let amount_1: u64 = kani::any();
        let amount_2: u64 = kani::any();

        kani::assume(balance_a <= 1_000_000_000_000u64);
        kani::assume(balance_b <= 1_000_000_000_000u64);
        kani::assume(balance_c <= 1_000_000_000_000u64);
        kani::assume(amount_1 > 0 && amount_1 <= balance_a);
        kani::assume(amount_2 > 0);

        let total_before = (balance_a as u128) + (balance_b as u128) + (balance_c as u128);

        // Transfer A → B
        let a_after = balance_a - amount_1;
        let b_mid = balance_b.checked_add(amount_1);

        if let Some(b_mid_val) = b_mid {
            kani::assume(amount_2 <= b_mid_val);
            // Transfer B → C
            let b_after = b_mid_val - amount_2;
            if let Some(c_after) = balance_c.checked_add(amount_2) {
                let total_after = (a_after as u128) + (b_after as u128) + (c_after as u128);
                kani::assert(total_before == total_after, "Transitive balance conservation violated");
            }
        }
    }
}
