[
  {
    "category": "Account Validation",
    "vuln_type": "Account Data Mismatch",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-012",
    "cwe": "CWE-20",
    "location": "lib.rs",
    "function_name": "initialize",
    "line_number": 18,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: Initialize */\n#[derive (Accounts)] pub struct Initialize < 'info> { #[account (init, payer = payer , space = 8 + Vault :: LEN)] pub vault : Account<'info, Vault > , #[doc = \" CHECK: Not validated as signer — BUG\"] pub authority : AccountInfo<'info> , #[account (mut)] pub payer : Signer<'info> , pub system_program : Program<'info, System > , }\n/* HANDLER: */\npub fn initialize (ctx : Context<Initialize > , bump : u8) -> Result<() > { let vault = & mut ctx . accounts . vault ; vault . authority = ctx . accounts . authority . key () ; vault . total_deposits = 0 ; vault . total_shares = 0 ; vault . bump = bump ; Ok (()) }",
    "description": "An instruction takes both a state account (vault/pool) and an authority/user account, but does not validate their relationship. Without `has_one = authority` or an equivalent constraint, an attacker can pass any vault with any authority — even one they control — to access someone else's funds.",
    "attack_scenario": "Instruction takes `vault: Account<Vault>` and `authority: Signer`. Attacker creates their own vault where they are the authority. Passes their vault + their signer to an instruction that reads from a different token account (passed separately). The program verifies `authority == vault.authority` (both attacker-controlled), then processes the operation on the victim's token account.",
    "real_world_incident": null,
    "secure_fix": "Add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the vault/pool account to ensure the signer matches the stored authority.",
    "prevention": "Always validate relationships between accounts using `has_one` or `constraint`. Every state account that references an authority must be validated against the actual signer.",
    "confidence": 70
  },
  {
    "category": "Arithmetic",
    "vuln_type": "Rounding Direction Error",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-039",
    "cwe": "CWE-682",
    "location": "lib.rs",
    "function_name": "initialize",
    "line_number": 18,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: Initialize */\n#[derive (Accounts)] pub struct Initialize < 'info> { #[account (init, payer = payer , space = 8 + Vault :: LEN)] pub vault : Account<'info, Vault > , #[doc = \" CHECK: Not validated as signer — BUG\"] pub authority : AccountInfo<'info> , #[account (mut)] pub payer : Signer<'info> , pub system_program : Program<'info, System > , }\n/* HANDLER: */\npub fn initialize (ctx : Context<Initialize > , bump : u8) -> Result<() > { let vault = & mut ctx . accounts . vault ; vault . authority = ctx . accounts . authority . key () ; vault . total_deposits = 0 ; vault . total_shares = 0 ; vault . bump = bump ; Ok (()) }",
    "description": "Rounding direction may favor attacker.",
    "attack_scenario": "Attacker profits from repeated rounding errors.",
    "real_world_incident": null,
    "secure_fix": "Round in favor of protocol, not user",
    "prevention": "Always round against the user in financial ops",
    "confidence": 70
  },
  {
    "category": "Authentication",
    "vuln_type": "Missing Signer Check",
    "severity": 5,
    "severity_label": "CRITICAL",
    "id": "SOL-001",
    "cwe": "CWE-287",
    "location": "lib.rs",
    "function_name": "handle_withdraw",
    "line_number": 42,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: Withdraw */\n#[derive (Accounts)] pub struct Withdraw < 'info> { #[account (mut)] pub vault : Account<'info, Vault > , #[doc = \" CHECK: authority not validated — BUG\"] pub authority : AccountInfo<'info> , }\n/* HANDLER: */\npub fn handle_withdraw (ctx : Context<Withdraw > , amount : u64) -> Result<() > { let vault = & mut ctx . accounts . vault ; vault . total_deposits -= amount ; Ok (()) }",
    "description": "An authority/admin/owner account is passed as raw `AccountInfo<'info>` without enforcing `is_signer`. The Solana runtime will NOT check this — any pubkey can be passed, allowing anyone to impersonate the privileged role. Use `Signer<'info>` or add `#[account(signer)]` to enforce the runtime check.",
    "attack_scenario": "Attacker constructs a transaction passing their own pubkey as the `authority` AccountInfo. Since there is no `Signer<'info>` constraint or `require!(authority.is_signer)` guard, the runtime accepts the instruction. The attacker then executes privileged operations (withdraw, set_authority, etc.) as if they were the real authority.",
    "real_world_incident": {
      "project": "Wormhole",
      "loss": "$320M",
      "date": "2022-02-02"
    },
    "secure_fix": "Replace `pub authority: AccountInfo<'info>` with `pub authority: Signer<'info>`, or add `#[account(signer)]`. For Anchor programs, also add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the account being protected.",
    "prevention": "Never use raw AccountInfo for accounts that must be signers. Always use Signer<'info> for authority/admin/owner accounts in Anchor.",
    "confidence": 70
  },
  {
    "category": "Logic Security",
    "vuln_type": "Missing State Machine",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-059",
    "cwe": "CWE-841",
    "location": "lib.rs",
    "function_name": "handle_withdraw",
    "line_number": 42,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: Withdraw */\n#[derive (Accounts)] pub struct Withdraw < 'info> { #[account (mut)] pub vault : Account<'info, Vault > , #[doc = \" CHECK: authority not validated — BUG\"] pub authority : AccountInfo<'info> , }\n/* HANDLER: */\npub fn handle_withdraw (ctx : Context<Withdraw > , amount : u64) -> Result<() > { let vault = & mut ctx . accounts . vault ; vault . total_deposits -= amount ; Ok (()) }",
    "description": "Multi-step instruction flow (init→deposit→finalize) lacks a state machine to enforce ordering. Instructions can be called out-of-order, skipping required preconditions.",
    "attack_scenario": "Protocol has init→deposit→finalize flow. Attacker calls finalize directly without depositing, claiming rewards without providing collateral.",
    "real_world_incident": null,
    "secure_fix": "Add an enum State { Initialized, Active, Finalized } and validate transitions: `require!(account.state == State::Active)`.",
    "prevention": "All multi-step processes need explicit state tracking with validated transitions.",
    "confidence": 70
  },
  {
    "category": "DeFi Security",
    "vuln_type": "Missing Slippage Protection",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-033",
    "cwe": "CWE-20",
    "location": "lib.rs",
    "function_name": "handle_swap",
    "line_number": 95,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: Swap */\n#[derive (Accounts)] pub struct Swap < 'info> { #[account (mut)] pub source_vault : Account<'info, Vault > , #[account (mut)] pub dest_vault : Account<'info, Vault > , pub authority : Signer<'info> , }\n/* HANDLER: */\npub fn handle_swap (ctx : Context<Swap > , amount : u64) -> Result<() > { let source = & mut ctx . accounts . source_vault ; let dest = & mut ctx . accounts . dest_vault ; source . total_deposits -= amount ; dest . total_deposits += amount ; Ok (()) }",
    "description": "Swap operation without slippage protection.",
    "attack_scenario": "MEV bots sandwich the transaction for profit.",
    "real_world_incident": null,
    "secure_fix": "Add min_amount_out parameter and validate",
    "prevention": "Always implement slippage tolerance",
    "confidence": 70
  },
  {
    "category": "Transaction Safety",
    "vuln_type": "Missing Deadline Check",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-051",
    "cwe": "CWE-367",
    "location": "lib.rs",
    "function_name": "handle_swap",
    "line_number": 95,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: Swap */\n#[derive (Accounts)] pub struct Swap < 'info> { #[account (mut)] pub source_vault : Account<'info, Vault > , #[account (mut)] pub dest_vault : Account<'info, Vault > , pub authority : Signer<'info> , }\n/* HANDLER: */\npub fn handle_swap (ctx : Context<Swap > , amount : u64) -> Result<() > { let source = & mut ctx . accounts . source_vault ; let dest = & mut ctx . accounts . dest_vault ; source . total_deposits -= amount ; dest . total_deposits += amount ; Ok (()) }",
    "description": "Transaction has no expiry deadline.",
    "attack_scenario": "Stale transactions execute at unfavorable prices.",
    "real_world_incident": null,
    "secure_fix": "Add deadline parameter and validate",
    "prevention": "All user-facing txs should have deadlines",
    "confidence": 70
  },
  {
    "category": "MEV Security",
    "vuln_type": "Insufficient MEV Protection",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-066",
    "cwe": "CWE-362",
    "location": "lib.rs",
    "function_name": "handle_swap",
    "line_number": 95,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: Swap */\n#[derive (Accounts)] pub struct Swap < 'info> { #[account (mut)] pub source_vault : Account<'info, Vault > , #[account (mut)] pub dest_vault : Account<'info, Vault > , pub authority : Signer<'info> , }\n/* HANDLER: */\npub fn handle_swap (ctx : Context<Swap > , amount : u64) -> Result<() > { let source = & mut ctx . accounts . source_vault ; let dest = & mut ctx . accounts . dest_vault ; source . total_deposits -= amount ; dest . total_deposits += amount ; Ok (()) }",
    "description": "DeFi swap/trade instruction lacks slippage protection and MEV mitigation. Transactions are vulnerable to sandwich attacks where a searcher front-runs and back-runs the user's trade for profit.",
    "attack_scenario": "User submits swap(100 SOL → USDC) without min_amount_out. MEV bot front-runs with a large buy (pumps price), user swaps at inflated price, bot back-runs with a sell. User receives fewer tokens.",
    "real_world_incident": null,
    "secure_fix": "Require minimum output amount: `require!(amount_out >= min_amount_out, ErrorCode::SlippageExceeded)`. Consider Jito bundles for MEV protection.",
    "prevention": "All swap instructions must accept and enforce min_amount_out. Educate users to set reasonable slippage tolerance.",
    "confidence": 70
  }
]
