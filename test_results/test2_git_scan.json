[
  {
    "category": "Sysvar Security",
    "vuln_type": "Sysvar Address Issues",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-010",
    "cwe": "CWE-20",
    "location": "lib.rs",
    "function_name": "process_initialize_mint",
    "line_number": 104,
    "vulnerable_code": "pub fn process_initialize_mint (accounts : & [AccountInfo] , decimals : u8) -> ProgramResult { let InitializeMint { mint , payer , upstream_authority , system_program , token_program , } = InitializeMint :: load (accounts) ? ; let space = spl_token :: state :: Mint :: LEN ; invoke (& system_instruction :: create_account (payer . key , mint . key , Rent :: get () ? . minimum_balance (space) , space as u64 , token_program . key ,) , & [payer . clone () , mint . clone () , system_program . clone ()] ,) ? ; let (authority , _) = get_authority (upstream_authority . key) ; initialize_mint (& authority , & authority , mint , token_program , decimals) }",
    "description": "Sysvar (Clock/Rent/SlotHashes) is accessed via raw `AccountInfo` without validating the account address is the real sysvar. An attacker can pass a fake account with fabricated data (e.g., a manipulated timestamp or artificial rent value). Use Anchor's `Sysvar<'info, Clock>` which validates the address automatically, or manually check against `sysvar::clock::id()`.",
    "attack_scenario": "Attacker creates a fake account with arbitrary data and passes it as the Clock sysvar. The program reads a manipulated `unix_timestamp`, allowing the attacker to bypass time-locked operations (vesting schedules, staking cooldowns, auction deadlines).",
    "real_world_incident": null,
    "secure_fix": "Use `pub clock: Sysvar<'info, Clock>` in your Accounts struct, or validate: `require!(clock_info.key() == sysvar::clock::id())`",
    "prevention": "Always use Anchor's typed `Sysvar<'info, T>` wrapper which validates the sysvar address during account deserialization.",
    "confidence": 67
  },
  {
    "category": "Initialization",
    "vuln_type": "Reinitialization Vulnerability",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-011",
    "cwe": "CWE-665",
    "location": "lib.rs",
    "function_name": "process_initialize_mint",
    "line_number": 104,
    "vulnerable_code": "pub fn process_initialize_mint (accounts : & [AccountInfo] , decimals : u8) -> ProgramResult { let InitializeMint { mint , payer , upstream_authority , system_program , token_program , } = InitializeMint :: load (accounts) ? ; let space = spl_token :: state :: Mint :: LEN ; invoke (& system_instruction :: create_account (payer . key , mint . key , Rent :: get () ? . minimum_balance (space) , space as u64 , token_program . key ,) , & [payer . clone () , mint . clone () , system_program . clone ()] ,) ? ; let (authority , _) = get_authority (upstream_authority . key) ; initialize_mint (& authority , & authority , mint , token_program , decimals) }",
    "description": "An initialization function exists without a guard to prevent reinitialization. An attacker can call `initialize` again to reset the program's state, overwriting the authority, resetting balances, or changing configuration. Anchor's `#[account(init)]` prevents this by requiring the account to not exist yet (checked via lamports == 0).",
    "attack_scenario": "Program has `fn initialize(authority: Pubkey)` that writes the authority to state but doesn't check if state is already initialized. Attacker calls `initialize` with their own pubkey as authority. The program overwrites the legitimate authority, giving the attacker full admin control.",
    "real_world_incident": null,
    "secure_fix": "Add an `is_initialized` flag to state and check it at the start of `initialize`, or use Anchor's `#[account(init)]` which ensures the account was just created (lamports == 0) and sets the discriminator.\n```rust\nrequire!(!state.is_initialized, ErrorCode::AlreadyInitialized);\nstate.is_initialized = true;\n```",
    "prevention": "Use Anchor's `#[account(init)]` constraint. For native programs, always include an `is_initialized: bool` field and check it before writing state.",
    "confidence": 67
  },
  {
    "category": "Account Security",
    "vuln_type": "Account Hijacking Risk",
    "severity": 5,
    "severity_label": "CRITICAL",
    "id": "SOL-048",
    "cwe": "CWE-287",
    "location": "lib.rs",
    "function_name": "process_initialize_mint",
    "line_number": 104,
    "vulnerable_code": "pub fn process_initialize_mint (accounts : & [AccountInfo] , decimals : u8) -> ProgramResult { let InitializeMint { mint , payer , upstream_authority , system_program , token_program , } = InitializeMint :: load (accounts) ? ; let space = spl_token :: state :: Mint :: LEN ; invoke (& system_instruction :: create_account (payer . key , mint . key , Rent :: get () ? . minimum_balance (space) , space as u64 , token_program . key ,) , & [payer . clone () , mint . clone () , system_program . clone ()] ,) ? ; let (authority , _) = get_authority (upstream_authority . key) ; initialize_mint (& authority , & authority , mint , token_program , decimals) }",
    "description": "Account is created at a keypair address (not a PDA). An attacker who observes the target address in the mempool can front-run the creation by sending lamports to the address first (making it 'already initialized'). The legitimate create_account instruction then fails. Use PDAs with deterministic seeds instead.",
    "attack_scenario": "User's transaction includes create_account for a new keypair. Attacker sees the pending transaction, extracts the target address, and sends lamports to it. When the user's transaction executes, create_account fails because the account already has lamports. The user must generate a new keypair and retry.",
    "real_world_incident": null,
    "secure_fix": "Use PDAs with deterministic seeds: `#[account(init, seeds = [b\"state\", user.key().as_ref()], bump, payer = user)]`. PDAs cannot be front-run because their address is derived from the program ID.",
    "prevention": "Always use PDA-derived addresses for program accounts. Never use keypair-based accounts that require a separate create_account instruction.",
    "confidence": 67
  },
  {
    "category": "Sysvar Security",
    "vuln_type": "Sysvar Address Issues",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-010",
    "cwe": "CWE-20",
    "location": "process_execute_transaction.rs",
    "function_name": "process_execute_transaction",
    "line_number": 23,
    "vulnerable_code": "#[doc = \" Processes ExecuteTransaction instruction\"] pub fn process_execute_transaction (program_id : & Pubkey , accounts : & [AccountInfo]) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let governance_info = next_account_info (account_info_iter) ? ; let proposal_info = next_account_info (account_info_iter) ? ; let proposal_transaction_info = next_account_info (account_info_iter) ? ; let clock = Clock :: get () ? ; let governance_data = get_governance_data (program_id , governance_info) ? ; let mut proposal_data = get_proposal_data_for_governance (program_id , proposal_info , governance_info . key) ? ; let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal (program_id , proposal_transaction_info , proposal_info . key ,) ? ; proposal_data . assert_can_execute_transaction (& proposal_transaction_data , & governance_data . config , clock . unix_timestamp ,) ? ; let instructions = proposal_transaction_data . instructions . iter () . map (Instruction :: from) ; let instruction_account_infos = account_info_iter . as_slice () ; let mut signers_seeds : Vec<& [& [u8]] > = vec ! [] ; let mut governance_seeds = governance_data . get_governance_address_seeds () ? . to_vec () ; let (_ , bump_seed) = Pubkey :: find_program_address (& governance_seeds , program_id) ; let bump = & [bump_seed] ; governance_seeds . push (bump) ; signers_seeds . push (& governance_seeds [..]) ; let mut treasury_seeds = get_native_treasury_address_seeds (governance_info . key) . to_vec () ; let (treasury_address , treasury_bump_seed) = Pubkey :: find_program_address (& treasury_seeds , program_id) ; let treasury_bump = & [treasury_bump_seed] ; if instruction_account_infos . iter () . any (| a | a . key == & treasury_address) { treasury_seeds . push (treasury_bump) ; signers_seeds . push (& treasury_seeds [..]) ; } for instruction in instructions { invoke_signed (& instruction , instruction_account_infos , & signers_seeds [..]) ? ; } if proposal_data . state == ProposalState :: Succeeded { proposal_data . executing_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Executing ; } let option = & mut proposal_data . options [proposal_transaction_data . option_index as usize] ; option . transactions_executed_count = option . transactions_executed_count . checked_add (1) . unwrap () ; if (proposal_data . state == ProposalState :: Executing || proposal_data . state == ProposalState :: ExecutingWithErrors) && proposal_data . options . iter () . filter (| o | o . vote_result == OptionVoteResult :: Succeeded) . all (| o | o . transactions_executed_count == o . transactions_count) { proposal_data . closed_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Completed ; } proposal_data . serialize (& mut proposal_info . data . borrow_mut () [..]) ? ; proposal_transaction_data . executed_at = Some (clock . unix_timestamp) ; proposal_transaction_data . execution_status = TransactionExecutionStatus :: Success ; proposal_transaction_data . serialize (& mut proposal_transaction_info . data . borrow_mut () [..]) ? ; Ok (()) }",
    "description": "Sysvar (Clock/Rent/SlotHashes) is accessed via raw `AccountInfo` without validating the account address is the real sysvar. An attacker can pass a fake account with fabricated data (e.g., a manipulated timestamp or artificial rent value). Use Anchor's `Sysvar<'info, Clock>` which validates the address automatically, or manually check against `sysvar::clock::id()`.",
    "attack_scenario": "Attacker creates a fake account with arbitrary data and passes it as the Clock sysvar. The program reads a manipulated `unix_timestamp`, allowing the attacker to bypass time-locked operations (vesting schedules, staking cooldowns, auction deadlines).",
    "real_world_incident": null,
    "secure_fix": "Use `pub clock: Sysvar<'info, Clock>` in your Accounts struct, or validate: `require!(clock_info.key() == sysvar::clock::id())`",
    "prevention": "Always use Anchor's typed `Sysvar<'info, T>` wrapper which validates the sysvar address during account deserialization.",
    "confidence": 67
  },
  {
    "category": "Reentrancy",
    "vuln_type": "Cross-Program Reentrancy",
    "severity": 5,
    "severity_label": "CRITICAL",
    "id": "SOL-017",
    "cwe": "CWE-841",
    "location": "process_execute_transaction.rs",
    "function_name": "process_execute_transaction",
    "line_number": 23,
    "vulnerable_code": "#[doc = \" Processes ExecuteTransaction instruction\"] pub fn process_execute_transaction (program_id : & Pubkey , accounts : & [AccountInfo]) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let governance_info = next_account_info (account_info_iter) ? ; let proposal_info = next_account_info (account_info_iter) ? ; let proposal_transaction_info = next_account_info (account_info_iter) ? ; let clock = Clock :: get () ? ; let governance_data = get_governance_data (program_id , governance_info) ? ; let mut proposal_data = get_proposal_data_for_governance (program_id , proposal_info , governance_info . key) ? ; let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal (program_id , proposal_transaction_info , proposal_info . key ,) ? ; proposal_data . assert_can_execute_transaction (& proposal_transaction_data , & governance_data . config , clock . unix_timestamp ,) ? ; let instructions = proposal_transaction_data . instructions . iter () . map (Instruction :: from) ; let instruction_account_infos = account_info_iter . as_slice () ; let mut signers_seeds : Vec<& [& [u8]] > = vec ! [] ; let mut governance_seeds = governance_data . get_governance_address_seeds () ? . to_vec () ; let (_ , bump_seed) = Pubkey :: find_program_address (& governance_seeds , program_id) ; let bump = & [bump_seed] ; governance_seeds . push (bump) ; signers_seeds . push (& governance_seeds [..]) ; let mut treasury_seeds = get_native_treasury_address_seeds (governance_info . key) . to_vec () ; let (treasury_address , treasury_bump_seed) = Pubkey :: find_program_address (& treasury_seeds , program_id) ; let treasury_bump = & [treasury_bump_seed] ; if instruction_account_infos . iter () . any (| a | a . key == & treasury_address) { treasury_seeds . push (treasury_bump) ; signers_seeds . push (& treasury_seeds [..]) ; } for instruction in instructions { invoke_signed (& instruction , instruction_account_infos , & signers_seeds [..]) ? ; } if proposal_data . state == ProposalState :: Succeeded { proposal_data . executing_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Executing ; } let option = & mut proposal_data . options [proposal_transaction_data . option_index as usize] ; option . transactions_executed_count = option . transactions_executed_count . checked_add (1) . unwrap () ; if (proposal_data . state == ProposalState :: Executing || proposal_data . state == ProposalState :: ExecutingWithErrors) && proposal_data . options . iter () . filter (| o | o . vote_result == OptionVoteResult :: Succeeded) . all (| o | o . transactions_executed_count == o . transactions_count) { proposal_data . closed_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Completed ; } proposal_data . serialize (& mut proposal_info . data . borrow_mut () [..]) ? ; proposal_transaction_data . executed_at = Some (clock . unix_timestamp) ; proposal_transaction_data . execution_status = TransactionExecutionStatus :: Success ; proposal_transaction_data . serialize (& mut proposal_transaction_info . data . borrow_mut () [..]) ? ; Ok (()) }",
    "description": "State modification after CPI allows reentrancy attack.",
    "attack_scenario": "Attacker's program calls back before state is finalized.",
    "real_world_incident": {
      "project": "Various DeFi",
      "loss": "$100M+",
      "date": "2021-2023"
    },
    "secure_fix": "Update state BEFORE making CPI calls (Checks-Effects-Interactions)",
    "prevention": "Follow CEI pattern, add reentrancy guards",
    "confidence": 67
  },
  {
    "category": "Resource Safety",
    "vuln_type": "Compute Unit Exhaustion with Partial State",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-061",
    "cwe": "CWE-400",
    "location": "process_execute_transaction.rs",
    "function_name": "process_execute_transaction",
    "line_number": 23,
    "vulnerable_code": "#[doc = \" Processes ExecuteTransaction instruction\"] pub fn process_execute_transaction (program_id : & Pubkey , accounts : & [AccountInfo]) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let governance_info = next_account_info (account_info_iter) ? ; let proposal_info = next_account_info (account_info_iter) ? ; let proposal_transaction_info = next_account_info (account_info_iter) ? ; let clock = Clock :: get () ? ; let governance_data = get_governance_data (program_id , governance_info) ? ; let mut proposal_data = get_proposal_data_for_governance (program_id , proposal_info , governance_info . key) ? ; let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal (program_id , proposal_transaction_info , proposal_info . key ,) ? ; proposal_data . assert_can_execute_transaction (& proposal_transaction_data , & governance_data . config , clock . unix_timestamp ,) ? ; let instructions = proposal_transaction_data . instructions . iter () . map (Instruction :: from) ; let instruction_account_infos = account_info_iter . as_slice () ; let mut signers_seeds : Vec<& [& [u8]] > = vec ! [] ; let mut governance_seeds = governance_data . get_governance_address_seeds () ? . to_vec () ; let (_ , bump_seed) = Pubkey :: find_program_address (& governance_seeds , program_id) ; let bump = & [bump_seed] ; governance_seeds . push (bump) ; signers_seeds . push (& governance_seeds [..]) ; let mut treasury_seeds = get_native_treasury_address_seeds (governance_info . key) . to_vec () ; let (treasury_address , treasury_bump_seed) = Pubkey :: find_program_address (& treasury_seeds , program_id) ; let treasury_bump = & [treasury_bump_seed] ; if instruction_account_infos . iter () . any (| a | a . key == & treasury_address) { treasury_seeds . push (treasury_bump) ; signers_seeds . push (& treasury_seeds [..]) ; } for instruction in instructions { invoke_signed (& instruction , instruction_account_infos , & signers_seeds [..]) ? ; } if proposal_data . state == ProposalState :: Succeeded { proposal_data . executing_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Executing ; } let option = & mut proposal_data . options [proposal_transaction_data . option_index as usize] ; option . transactions_executed_count = option . transactions_executed_count . checked_add (1) . unwrap () ; if (proposal_data . state == ProposalState :: Executing || proposal_data . state == ProposalState :: ExecutingWithErrors) && proposal_data . options . iter () . filter (| o | o . vote_result == OptionVoteResult :: Succeeded) . all (| o | o . transactions_executed_count == o . transactions_count) { proposal_data . closed_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Completed ; } proposal_data . serialize (& mut proposal_info . data . borrow_mut () [..]) ? ; proposal_transaction_data . executed_at = Some (clock . unix_timestamp) ; proposal_transaction_data . execution_status = TransactionExecutionStatus :: Success ; proposal_transaction_data . serialize (& mut proposal_transaction_info . data . borrow_mut () [..]) ? ; Ok (()) }",
    "description": "Loop processes items while mutating state. If compute units run out mid-loop, the transaction fails but on-chain state may be partially updated (Solana does NOT roll back on CU exhaustion in inner instructions).",
    "attack_scenario": "Attacker provides a large input array. The loop processes 10 of 100 items before CU exhaustion. Those 10 state changes persist, creating an inconsistent state that can be exploited in subsequent transactions.",
    "real_world_incident": null,
    "secure_fix": "Add CU consumption checks in loops, or use pagination/cranking patterns. Process items in fixed-size batches.",
    "prevention": "Bound loop iterations. Use pagination for large datasets. Check remaining CU budget with `sol_remaining_compute_units()`.",
    "confidence": 67
  },
  {
    "category": "Input Validation",
    "vuln_type": "Unbounded Input Length",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-062",
    "cwe": "CWE-400",
    "location": "process_execute_transaction.rs",
    "function_name": "process_execute_transaction",
    "line_number": 23,
    "vulnerable_code": "#[doc = \" Processes ExecuteTransaction instruction\"] pub fn process_execute_transaction (program_id : & Pubkey , accounts : & [AccountInfo]) -> ProgramResult { let account_info_iter = & mut accounts . iter () ; let governance_info = next_account_info (account_info_iter) ? ; let proposal_info = next_account_info (account_info_iter) ? ; let proposal_transaction_info = next_account_info (account_info_iter) ? ; let clock = Clock :: get () ? ; let governance_data = get_governance_data (program_id , governance_info) ? ; let mut proposal_data = get_proposal_data_for_governance (program_id , proposal_info , governance_info . key) ? ; let mut proposal_transaction_data = get_proposal_transaction_data_for_proposal (program_id , proposal_transaction_info , proposal_info . key ,) ? ; proposal_data . assert_can_execute_transaction (& proposal_transaction_data , & governance_data . config , clock . unix_timestamp ,) ? ; let instructions = proposal_transaction_data . instructions . iter () . map (Instruction :: from) ; let instruction_account_infos = account_info_iter . as_slice () ; let mut signers_seeds : Vec<& [& [u8]] > = vec ! [] ; let mut governance_seeds = governance_data . get_governance_address_seeds () ? . to_vec () ; let (_ , bump_seed) = Pubkey :: find_program_address (& governance_seeds , program_id) ; let bump = & [bump_seed] ; governance_seeds . push (bump) ; signers_seeds . push (& governance_seeds [..]) ; let mut treasury_seeds = get_native_treasury_address_seeds (governance_info . key) . to_vec () ; let (treasury_address , treasury_bump_seed) = Pubkey :: find_program_address (& treasury_seeds , program_id) ; let treasury_bump = & [treasury_bump_seed] ; if instruction_account_infos . iter () . any (| a | a . key == & treasury_address) { treasury_seeds . push (treasury_bump) ; signers_seeds . push (& treasury_seeds [..]) ; } for instruction in instructions { invoke_signed (& instruction , instruction_account_infos , & signers_seeds [..]) ? ; } if proposal_data . state == ProposalState :: Succeeded { proposal_data . executing_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Executing ; } let option = & mut proposal_data . options [proposal_transaction_data . option_index as usize] ; option . transactions_executed_count = option . transactions_executed_count . checked_add (1) . unwrap () ; if (proposal_data . state == ProposalState :: Executing || proposal_data . state == ProposalState :: ExecutingWithErrors) && proposal_data . options . iter () . filter (| o | o . vote_result == OptionVoteResult :: Succeeded) . all (| o | o . transactions_executed_count == o . transactions_count) { proposal_data . closed_at = Some (clock . unix_timestamp) ; proposal_data . state = ProposalState :: Completed ; } proposal_data . serialize (& mut proposal_info . data . borrow_mut () [..]) ? ; proposal_transaction_data . executed_at = Some (clock . unix_timestamp) ; proposal_transaction_data . execution_status = TransactionExecutionStatus :: Success ; proposal_transaction_data . serialize (& mut proposal_transaction_info . data . borrow_mut () [..]) ? ; Ok (()) }",
    "description": "Instruction accepts Vec<> input without length bounds. An attacker can pass an extremely large array to consume all compute units or cause excessive memory allocation.",
    "attack_scenario": "Attacker passes a Vec with 10,000 elements. The instruction tries to iterate and runs out of compute units, DOS-ing the program.",
    "real_world_incident": null,
    "secure_fix": "Add length validation: `require!(items.len() <= MAX_ITEMS)`. Define reasonable constants for maximum array sizes.",
    "prevention": "Always validate collection lengths at instruction entry. Define MAX_* constants for all bounded collections.",
    "confidence": 67
  },
  {
    "category": "Account Validation",
    "vuln_type": "Unvalidated remaining_accounts",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-063",
    "cwe": "CWE-20",
    "location": "lib.rs",
    "function_name": "init_prepared_tree_with_root",
    "line_number": 289,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: Modify */\n#[doc = \" Context for modifying a tree: inserting, appending, or replacing a leaf in\"] #[doc = \" the existing tree and setting the canopy or finalizing a prepared tree.\"] #[doc = \"\"] #[doc = \" Modification instructions also require the proof to the leaf to be provided\"] #[doc = \" as 32-byte nodes via \\\"remaining accounts\\\".\"] #[derive (Accounts)] pub struct Modify < 'info> { #[account (mut)] #[doc = \" CHECK: This account is validated in the instruction\"] pub merkle_tree : UncheckedAccount<'info> , #[doc = \" Authority that controls write-access to the tree\"] #[doc = \" Typically a program, e.g., the Bubblegum contract validates that leaves are valid NFTs.\"] pub authority : Signer<'info> , #[doc = \" Program used to emit changelogs as cpi instruction data.\"] pub noop : Program<'info, Noop > , }\n/* HANDLER: */\n#[doc = \" (Devnet only) Initializes a prepared tree with a root and a rightmost leaf. The rightmost leaf is used to\"] #[doc = \" verify the canopy if the tree has it. Before calling this instruction, the tree should be\"] #[doc = \" prepared with `prepare_batch_merkle_tree` and the canopy should be filled with the necessary\"] #[doc = \" nodes with `append_canopy_nodes` (if the canopy is used). This method should be used for\"] #[doc = \" batch creation of trees. The indexing of such batches should be done off-chain. The\"] #[doc = \" programs calling this instruction should take care of ensuring the indexing is possible.\"] #[doc = \" For example, staking may be required to ensure the tree creator has some responsibility\"] #[doc = \" for what is being indexed. If indexing is not possible, there should be a mechanism to\"] #[doc = \" penalize the tree creator.\"] pub fn init_prepared_tree_with_root (ctx : Context<Modify > , root : [u8 ; 32] , rightmost_leaf : [u8 ; 32] , rightmost_index : u32 ,) -> Result<() > { require_eq ! (* ctx . accounts . merkle_tree . owner , crate :: id () , AccountCompressionError :: IncorrectAccountOwner) ; let mut merkle_tree_bytes = ctx . accounts . merkle_tree . try_borrow_mut_data () ? ; let (header_bytes , rest) = merkle_tree_bytes . split_at_mut (CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1) ; let header = ConcurrentMerkleTreeHeader :: try_from_slice (header_bytes) ? ; header . assert_valid_authority (& ctx . accounts . authority . key ()) ? ; header . assert_is_batch_initialized () ? ; let merkle_tree_size = merkle_tree_get_size (& header) ? ; let (tree_bytes , canopy_bytes) = rest . split_at_mut (merkle_tree_size) ; check_canopy_root (canopy_bytes , & root , header . get_max_depth ()) ? ; check_canopy_no_nodes_to_right_of_index (canopy_bytes , header . get_max_depth () , rightmost_index ,) ? ; let mut proof = vec ! [] ; for node in ctx . remaining_accounts . iter () { proof . push (node . key () . to_bytes ()) ; } fill_in_proof_from_canopy (canopy_bytes , header . get_max_depth () , rightmost_index , & mut proof ,) ? ; assert_eq ! (proof . len () , header . get_max_depth () as usize) ; let id = ctx . accounts . merkle_tree . key () ; let args = & InitializeWithRootArgs { root , rightmost_leaf , proof_vec : proof , index : rightmost_index , } ; let change_log = merkle_tree_initialize_with_root (& header , id , tree_bytes , args) ? ; update_canopy (canopy_bytes , header . get_max_depth () , Some (& change_log)) ? ; wrap_event (& AccountCompressionEvent :: ChangeLog (* change_log) , & ctx . accounts . noop ,) }",
    "description": "The context uses `remaining_accounts` without validating the accounts' ownership, signer status, or expected keys. These accounts bypass Anchor's automatic validation, so ANY account can be passed.",
    "attack_scenario": "Program reads remaining_accounts[0] as a user's token account without checking owner. Attacker passes a token account they own, redirecting funds or spoofing identity.",
    "real_world_incident": null,
    "secure_fix": "Validate each remaining_account: check owner, key, signer status. Prefer typed accounts in the Accounts struct over remaining_accounts.",
    "prevention": "Minimize remaining_accounts usage. When required, validate each account's owner, key, and writable/signer constraints explicitly.",
    "confidence": 67
  },
  {
    "category": "Observability",
    "vuln_type": "Missing Event Emission",
    "severity": 2,
    "severity_label": "LOW",
    "id": "SOL-044",
    "cwe": null,
    "location": "lib.rs",
    "function_name": "transfer_authority",
    "line_number": 403,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: TransferAuthority */\n#[doc = \" Context for transferring `authority`\"] #[derive (Accounts)] pub struct TransferAuthority < 'info> { #[account (mut)] #[doc = \" CHECK: This account is validated in the instruction\"] pub merkle_tree : UncheckedAccount<'info> , #[doc = \" Authority that controls write-access to the tree\"] #[doc = \" Typically a program, e.g., the Bubblegum contract validates that leaves are valid NFTs.\"] pub authority : Signer<'info> , }\n/* HANDLER: */\n#[doc = \" Transfers `authority`.\"] #[doc = \" Requires `authority` to sign\"] pub fn transfer_authority (ctx : Context<TransferAuthority > , new_authority : Pubkey ,) -> Result<() > { require_eq ! (* ctx . accounts . merkle_tree . owner , crate :: id () , AccountCompressionError :: IncorrectAccountOwner) ; let mut merkle_tree_bytes = ctx . accounts . merkle_tree . try_borrow_mut_data () ? ; let (mut header_bytes , _) = merkle_tree_bytes . split_at_mut (CONCURRENT_MERKLE_TREE_HEADER_SIZE_V1) ; let mut header = ConcurrentMerkleTreeHeader :: try_from_slice (header_bytes) ? ; header . assert_valid_authority (& ctx . accounts . authority . key ()) ? ; header . set_new_authority (& new_authority) ; header . serialize (& mut header_bytes) ? ; Ok (()) }",
    "description": "Financial state changes (transfers, deposits, withdrawals) are made without emitting Anchor events (`emit!(EventName {...})`) or Solana logs (`msg!()`). This makes it impossible for off-chain indexers, monitoring systems, and forensic tools to track protocol activity. In a post-exploit scenario, the lack of events means the team cannot reconstruct what happened.",
    "attack_scenario": "An exploit drains protocol funds. The team tries to analyze what happened but there are no on-chain event logs to trace the attacker's transactions. They must manually decode instruction data from each transaction â€” a process that takes days instead of minutes.",
    "real_world_incident": null,
    "secure_fix": "Define events with `#[event]` and emit them after every significant state change: `emit!(DepositEvent { user: ctx.accounts.user.key(), amount, timestamp: Clock::get()?.unix_timestamp });`",
    "prevention": "Every instruction that modifies balances, authorities, or protocol parameters should emit a structured event. Use Anchor's `#[event]` macro for type-safe events that indexers can parse.",
    "confidence": 57
  }
]
