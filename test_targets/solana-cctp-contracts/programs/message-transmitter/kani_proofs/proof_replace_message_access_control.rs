//! Kani proof: Access control for `replace_message`
//! Auto-generated by kani-verifier â€” DO NOT EDIT
//! Source: lib.rs:128
//! Invariant: Instruction 'replace_message' must validate signer/authority before state mutation

#[cfg(kani)]
mod kani_proofs {
    /// Symbolic representation of Solana account info
    struct SymbolicAccountInfo {
        key: [u8; 32],
        is_signer: bool,
        is_writable: bool,
        owner: [u8; 32],
        lamports: u64,
    }

    impl kani::Arbitrary for SymbolicAccountInfo {
        fn any() -> Self {
            Self {
                key: kani::any(),
                is_signer: kani::any(),
                is_writable: kani::any(),
                owner: kani::any(),
                lamports: kani::any(),
            }
        }
    }

    /// Verify that privileged operations require signer validation.
    /// An attacker account (non-signer) must NOT be able to execute the instruction.
    #[kani::proof]
    #[kani::unwind(4)]
    fn proof_replace_message_access_control() {
        let authority: SymbolicAccountInfo = kani::any();
        let attacker: SymbolicAccountInfo = kani::any();

        // Authority is the legitimate signer
        kani::assume(authority.is_signer == true);

        // Attacker is NOT a signer
        kani::assume(attacker.is_signer == false);

        // Keys must be different
        kani::assume(authority.key != attacker.key);

        // Invariant: any function that checks `is_signer` should reject the attacker
        let should_reject_attacker = !attacker.is_signer;
        kani::assert(
            should_reject_attacker,
            "Access control violation: non-signer can execute privileged instruction"
        );

        // Verify that even if attacker matches authority key, signer check still holds
        let attacker_with_same_key = SymbolicAccountInfo {
            key: authority.key,
            is_signer: false,
            ..attacker
        };
        kani::assert(
            !attacker_with_same_key.is_signer,
            "Signer bypass: key match without signature"
        );
    }
}
