//! Kani proof: Account ownership for `update_pauser`
//! Auto-generated by kani-verifier â€” DO NOT EDIT
//! Source: lib.rs:64

#[cfg(kani)]
mod kani_proofs {
    const SYSTEM_PROGRAM: [u8; 32] = [0u8; 32];
    const TOKEN_PROGRAM: [u8; 32] = [6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70, 206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58, 140, 245, 133, 126, 255, 0, 169];

    struct SymbolicAccount {
        owner: [u8; 32],
        data_len: u64,
        executable: bool,
    }

    impl kani::Arbitrary for SymbolicAccount {
        fn any() -> Self {
            Self {
                owner: kani::any(),
                data_len: kani::any(),
                executable: kani::any(),
            }
        }
    }

    /// Verify that accounts passed to instruction have expected ownership.
    #[kani::proof]
    #[kani::unwind(4)]
    fn proof_update_pauser_account_ownership() {
        let program_id: [u8; 32] = kani::any();
        let account: SymbolicAccount = kani::any();
        let expected_owner: [u8; 32] = kani::any();

        // Precondition: expected_owner is a known valid program
        kani::assume(
            expected_owner == program_id
            || expected_owner == SYSTEM_PROGRAM
            || expected_owner == TOKEN_PROGRAM
        );

        // Invariant: account.owner must match expected program
        let ownership_valid = account.owner == expected_owner;

        // If ownership check is not performed, an attacker can substitute their own account
        // with a different owner, potentially draining funds
        kani::assert(
            ownership_valid || account.owner == program_id,
            "Account ownership mismatch: account owned by unexpected program"
        );
    }
}
