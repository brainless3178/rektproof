[
  {
    "category": "Account Validation",
    "vuln_type": "Account Data Mismatch",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-012",
    "cwe": "CWE-20",
    "location": "lib.rs",
    "function_name": "print_cash",
    "line_number": 39,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: PrintCash */\n#[doc = \" Accounts for printing $CASH.\"] #[derive (Accounts)] pub struct PrintCash < 'info> { #[doc = \" Common accounts.\"] pub common : BrrrCommon < 'info> , #[doc = \" The depositor into the pool.\"] #[account (mut)] pub depositor : Signer<'info> , #[doc = \" The source of the deposited [Collateral] tokens.\"] #[account (mut)] pub depositor_source : Box<Account<'info, TokenAccount > > , #[doc = \" Destination of the issued $CASH.\"] #[account (mut)] pub mint_destination : Box<Account<'info, TokenAccount > > , #[doc = \" The [ISSUE_AUTHORITY_ADDRESS].\"] #[doc = \" CHECK: this is handled by Vipers.\"] pub issue_authority : UncheckedAccount<'info> , }\n/* HANDLER: */\n#[doc = \" Prints $CASH.\"] #[doc = \"\"] #[doc = \" $CASH can be printed by depositing Saber LP tokens.\"] #[doc = \" The amount of $CASH created is based on the virtual price of the\"] #[doc = \" Saber LP token; for example, if one deposits 1 USDC-USDT LP\"] #[doc = \" but that LP's virtual price is 1.02, one will receive 1.02 $CASH\"] #[doc = \" for each 1 USDC-USDT LP deposited.\"] #[access_control (ctx . accounts . validate ())] pub fn print_cash (ctx : Context<PrintCash > , deposit_amount : u64) -> Result<() > { vipers :: invariant ! (false , \"temporarily disabled\") ; actions :: print_cash :: print_cash (ctx , deposit_amount) }",
    "description": "An instruction takes both a state account (vault/pool) and an authority/user account, but does not validate their relationship. Without `has_one = authority` or an equivalent constraint, an attacker can pass any vault with any authority — even one they control — to access someone else's funds.",
    "attack_scenario": "Instruction takes `vault: Account<Vault>` and `authority: Signer`. Attacker creates their own vault where they are the authority. Passes their vault + their signer to an instruction that reads from a different token account (passed separately). The program verifies `authority == vault.authority` (both attacker-controlled), then processes the operation on the victim's token account.",
    "real_world_incident": null,
    "secure_fix": "Add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the vault/pool account to ensure the signer matches the stored authority.",
    "prevention": "Always validate relationships between accounts using `has_one` or `constraint`. Every state account that references an authority must be validated against the actual signer.",
    "confidence": 65
  },
  {
    "category": "Logic Security",
    "vuln_type": "Missing State Machine",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-059",
    "cwe": "CWE-841",
    "location": "lib.rs",
    "function_name": "burn_cash",
    "line_number": 50,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: BurnCash */\n#[doc = \" Accounts for burning $CASH.\"] #[derive (Accounts)] pub struct BurnCash < 'info> { #[doc = \" Common accounts.\"] pub common : BrrrCommon < 'info> , #[doc = \" The depositor into the pool.\"] #[account (mut)] pub burner : Signer<'info> , #[doc = \" The source of the burned $CASH.\"] #[account (mut)] pub burned_cash_source : Box<Account<'info, TokenAccount > > , #[doc = \" Destination of the issued tokens.\"] #[account (mut)] pub withdraw_destination : Box<Account<'info, TokenAccount > > , #[doc = \" Author fee token destination\"] #[account (mut)] pub author_fee_destination : Account<'info, TokenAccount > , #[doc = \" Protocol fee token destination\"] #[account (mut)] pub protocol_fee_destination : Account<'info, TokenAccount > , #[doc = \" The [WITHDRAW_AUTHORITY_ADDRESS].\"] #[doc = \" CHECK: this is handled by Vipers.\"] pub withdraw_authority : UncheckedAccount<'info> , }\n/* HANDLER: */\n#[doc = \" Burns $CASH.\"] #[doc = \"\"] #[doc = \" $CASH may be burned for any of the underlying LP tokens.\"] #[doc = \" This means that $CASHs's underlying value is the value of its cheapest (\\\"floor\\\")\"] #[doc = \" LP token, minus the burn fee.\"] #[access_control (ctx . accounts . validate ())] pub fn burn_cash (ctx : Context<BurnCash > , burn_amount : u64) -> Result<() > { vipers :: invariant ! (false , \"temporarily disabled\") ; actions :: burn_cash :: burn_cash (ctx , burn_amount) }",
    "description": "Multi-step instruction flow (init→deposit→finalize) lacks a state machine to enforce ordering. Instructions can be called out-of-order, skipping required preconditions.",
    "attack_scenario": "Protocol has init→deposit→finalize flow. Attacker calls finalize directly without depositing, claiming rewards without providing collateral.",
    "real_world_incident": null,
    "secure_fix": "Add an enum State { Initialized, Active, Finalized } and validate transitions: `require!(account.state == State::Active)`.",
    "prevention": "All multi-step processes need explicit state tracking with validated transitions.",
    "confidence": 65
  },
  {
    "category": "Token Security",
    "vuln_type": "Unvalidated Freeze Authority",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-068",
    "cwe": "CWE-732",
    "location": "lib.rs",
    "function_name": "print_cash",
    "line_number": 39,
    "vulnerable_code": "/* ACCOUNTS_STRUCT: PrintCash */\n#[doc = \" Accounts for printing $CASH.\"] #[derive (Accounts)] pub struct PrintCash < 'info> { #[doc = \" Common accounts.\"] pub common : BrrrCommon < 'info> , #[doc = \" The depositor into the pool.\"] #[account (mut)] pub depositor : Signer<'info> , #[doc = \" The source of the deposited [Collateral] tokens.\"] #[account (mut)] pub depositor_source : Box<Account<'info, TokenAccount > > , #[doc = \" Destination of the issued $CASH.\"] #[account (mut)] pub mint_destination : Box<Account<'info, TokenAccount > > , #[doc = \" The [ISSUE_AUTHORITY_ADDRESS].\"] #[doc = \" CHECK: this is handled by Vipers.\"] pub issue_authority : UncheckedAccount<'info> , }\n/* HANDLER: */\n#[doc = \" Prints $CASH.\"] #[doc = \"\"] #[doc = \" $CASH can be printed by depositing Saber LP tokens.\"] #[doc = \" The amount of $CASH created is based on the virtual price of the\"] #[doc = \" Saber LP token; for example, if one deposits 1 USDC-USDT LP\"] #[doc = \" but that LP's virtual price is 1.02, one will receive 1.02 $CASH\"] #[doc = \" for each 1 USDC-USDT LP deposited.\"] #[access_control (ctx . accounts . validate ())] pub fn print_cash (ctx : Context<PrintCash > , deposit_amount : u64) -> Result<() > { vipers :: invariant ! (false , \"temporarily disabled\") ; actions :: print_cash :: print_cash (ctx , deposit_amount) }",
    "description": "DeFi protocol accepts token deposits without checking if the mint has a freeze authority. A freeze authority can freeze the protocol's token accounts, permanently locking user funds.",
    "attack_scenario": "Users deposit USDC into a lending pool. The token mint's freeze authority freezes the pool's token account. All deposits are permanently locked — users can never withdraw.",
    "real_world_incident": null,
    "secure_fix": "Check freeze authority: `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` or document the risk and implement contingency plans.",
    "prevention": "Audit accepted token mints for freeze authority. Warn users or reject tokens with active freeze authorities.",
    "confidence": 55
  }
]
