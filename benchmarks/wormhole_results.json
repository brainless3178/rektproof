[
  {
    "category": "Authorization",
    "vuln_type": "CPI Call Without Any Authorization",
    "severity": 5,
    "severity_label": "CRITICAL",
    "id": "SOL-CFG-02",
    "cwe": "CWE-862",
    "location": "governance.rs",
    "function_name": "upgrade_contract",
    "line_number": 115,
    "vulnerable_code": "invoke_signed(&upgrade_ix, ctx.accounts, &[seeds])?;",
    "description": "CFG analysis found ZERO authorization check blocks in `upgrade_contract`. The CPI Call at line 115 is completely unguarded.",
    "attack_scenario": "Anyone can call this function and execute the token transfer / CPI without authorization.",
    "real_world_incident": null,
    "secure_fix": "Add `require!(ctx.accounts.authority.is_signer)` or Anchor `#[account(signer)]` constraint before the operation.",
    "prevention": "Always verify authorization before sensitive operations.",
    "confidence": 73
  },
  {
    "category": "Governance Security",
    "vuln_type": "Governance/Timelock Bypass",
    "severity": 4,
    "severity_label": "HIGH",
    "id": "SOL-064",
    "cwe": "CWE-269",
    "location": "governance.rs",
    "function_name": "upgrade_contract",
    "line_number": 95,
    "vulnerable_code": "pub fn upgrade_contract (ctx : & ExecutionContext , accs : & mut UpgradeContract , _data : UpgradeContractData ,) -> Result<() > { verify_governance (& accs . vaa) ? ; claim :: consume (ctx , accs . payer . key , & mut accs . claim , & accs . vaa) ? ; let upgrade_ix = solana_program :: bpf_loader_upgradeable :: upgrade (ctx . program_id , & accs . vaa . new_contract , accs . upgrade_authority . key , accs . spill . key ,) ; let seeds = accs . upgrade_authority . self_bumped_seeds (None , ctx . program_id) ; let seeds : Vec<& [u8] > = seeds . iter () . map (| item | item . as_slice ()) . collect () ; let seeds = seeds . as_slice () ; invoke_signed (& upgrade_ix , ctx . accounts , & [seeds]) ? ; Ok (()) }",
    "description": "Admin/authority can change critical protocol parameters (fees, authority, config) without a timelock or governance delay. A compromised admin key can instantly rug-pull users.",
    "attack_scenario": "Admin key is compromised (phishing, leaked private key). Attacker immediately sets fee to 100%, drains all funds, and changes authority — all in a single transaction. Users have no time to react.",
    "real_world_incident": null,
    "secure_fix": "Implement two-step authority changes with timelock: propose_change → wait(DELAY) → execute_change. Use multisig for admin keys.",
    "prevention": "All admin operations should have timelocks (>= 24h). Use multisig wallets. Implement two-step authority transfers.",
    "confidence": 68
  },
  {
    "category": "Input Validation",
    "vuln_type": "Unbounded Input Length",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-062",
    "cwe": "CWE-400",
    "location": "governance.rs",
    "function_name": "upgrade_contract",
    "line_number": 95,
    "vulnerable_code": "pub fn upgrade_contract (ctx : & ExecutionContext , accs : & mut UpgradeContract , _data : UpgradeContractData ,) -> Result<() > { verify_governance (& accs . vaa) ? ; claim :: consume (ctx , accs . payer . key , & mut accs . claim , & accs . vaa) ? ; let upgrade_ix = solana_program :: bpf_loader_upgradeable :: upgrade (ctx . program_id , & accs . vaa . new_contract , accs . upgrade_authority . key , accs . spill . key ,) ; let seeds = accs . upgrade_authority . self_bumped_seeds (None , ctx . program_id) ; let seeds : Vec<& [u8] > = seeds . iter () . map (| item | item . as_slice ()) . collect () ; let seeds = seeds . as_slice () ; invoke_signed (& upgrade_ix , ctx . accounts , & [seeds]) ? ; Ok (()) }",
    "description": "Instruction accepts Vec<> input without length bounds. An attacker can pass an extremely large array to consume all compute units or cause excessive memory allocation.",
    "attack_scenario": "Attacker passes a Vec with 10,000 elements. The instruction tries to iterate and runs out of compute units, DOS-ing the program.",
    "real_world_incident": null,
    "secure_fix": "Add length validation: `require!(items.len() <= MAX_ITEMS)`. Define reasonable constants for maximum array sizes.",
    "prevention": "Always validate collection lengths at instruction entry. Define MAX_* constants for all bounded collections.",
    "confidence": 58
  },
  {
    "category": "Token Security",
    "vuln_type": "Missing Decimals Validation",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-032",
    "cwe": "CWE-682",
    "location": "governance.rs",
    "function_name": "transfer_fees",
    "line_number": 253,
    "vulnerable_code": "pub fn transfer_fees (ctx : & ExecutionContext , accs : & mut TransferFees , _data : TransferFeesData ,) -> Result<() > { verify_governance (& accs . vaa) ? ; claim :: consume (ctx , accs . payer . key , & mut accs . claim , & accs . vaa) ? ; if accs . vaa . to != accs . recipient . key . to_bytes () { return Err (InvalidFeeRecipient . into ()) ; } let new_balance = accs . fee_collector . lamports () . saturating_sub (accs . vaa . amount . as_u64 ()) ; if new_balance < accs . rent . minimum_balance (accs . fee_collector . data_len ()) { return Err (InvalidGovernanceWithdrawal . into ()) ; } accs . bridge . last_lamports = new_balance ; let transfer_ix = solana_program :: system_instruction :: transfer (accs . fee_collector . key , accs . recipient . key , accs . vaa . amount . as_u64 () ,) ; let seeds = accs . fee_collector . self_bumped_seeds (None , ctx . program_id) ; let seeds : Vec<& [u8] > = seeds . iter () . map (| item | item . as_slice ()) . collect () ; let seeds = seeds . as_slice () ; invoke_signed (& transfer_ix , ctx . accounts , & [seeds]) ? ; Ok (()) }",
    "description": "Token decimals not validated in calculations.",
    "attack_scenario": "Wrong decimals cause incorrect value calculations.",
    "real_world_incident": null,
    "secure_fix": "Normalize amounts based on token decimals",
    "prevention": "Always account for token decimals",
    "confidence": 58
  }
]
