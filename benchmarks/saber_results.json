[
  {
    "category": "Authentication",
    "vuln_type": "Missing Signer Check",
    "severity": 5,
    "severity_label": "CRITICAL",
    "id": "SOL-001",
    "cwe": "CWE-287",
    "location": "admin.rs",
    "function_name": "set_fee_account",
    "line_number": 179,
    "vulnerable_code": "#[doc = \" Set fee account\"] fn set_fee_account < 'a , 'b : 'a , I : Iterator < Item = & 'a AccountInfo<'b > > > (token_swap : & mut SwapInfo , account_info_iter : & mut I ,) -> ProgramResult { let new_fee_account_info = next_account_info (account_info_iter) ? ; let new_admin_fee_account = utils :: unpack_token_account (& new_fee_account_info . data . borrow_mut ()) ? ; msg ! (\"Admin: New fee account owner {}\" , new_admin_fee_account . owner) ; if new_admin_fee_account . mint == token_swap . token_a . mint { msg ! (\"Admin: Old fee account A {}\" , token_swap . token_a . admin_fees) ; token_swap . token_a . admin_fees = * new_fee_account_info . key ; msg ! (\"Admin: Fee account A set to {}\" , token_swap . token_a . admin_fees) ; } else if new_admin_fee_account . mint == token_swap . token_b . mint { msg ! (\"Admin: Old fee account B {}\" , token_swap . token_b . admin_fees) ; token_swap . token_b . admin_fees = * new_fee_account_info . key ; msg ! (\"Admin: Fee account B set to {}\" , token_swap . token_b . admin_fees) ; } else { return Err (SwapError :: InvalidAdmin . into ()) ; } Ok (()) }",
    "description": "An authority/admin/owner account is passed as raw `AccountInfo<'info>` without enforcing `is_signer`. The Solana runtime will NOT check this — any pubkey can be passed, allowing anyone to impersonate the privileged role. Use `Signer<'info>` or add `#[account(signer)]` to enforce the runtime check.",
    "attack_scenario": "Attacker constructs a transaction passing their own pubkey as the `authority` AccountInfo. Since there is no `Signer<'info>` constraint or `require!(authority.is_signer)` guard, the runtime accepts the instruction. The attacker then executes privileged operations (withdraw, set_authority, etc.) as if they were the real authority.",
    "real_world_incident": {
      "project": "Wormhole",
      "loss": "$320M",
      "date": "2022-02-02"
    },
    "secure_fix": "Replace `pub authority: AccountInfo<'info>` with `pub authority: Signer<'info>`, or add `#[account(signer)]`. For Anchor programs, also add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the account being protected.",
    "prevention": "Never use raw AccountInfo for accounts that must be signers. Always use Signer<'info> for authority/admin/owner accounts in Anchor.",
    "confidence": 81
  },
  {
    "category": "Authentication",
    "vuln_type": "Missing Signer Check",
    "severity": 5,
    "severity_label": "CRITICAL",
    "id": "SOL-001",
    "cwe": "CWE-287",
    "location": "swap.rs",
    "function_name": "handle_token_withdraw",
    "line_number": 534,
    "vulnerable_code": "fn handle_token_withdraw < 'a , 'b : 'a > (ctx : & WithdrawContext<'a , 'b > , (amount , admin_fee) : (u64 , u64) , reserves_info : & 'a AccountInfo<'b > , dest_token_info : & 'a AccountInfo<'b > , admin_fee_dest_info : & 'a AccountInfo<'b > ,) -> ProgramResult { token :: transfer_as_swap (ctx . swap_info . key , ctx . token_program_info . clone () , reserves_info . clone () , dest_token_info . clone () , ctx . swap_authority_info . clone () , ctx . token_swap . nonce , amount ,) ? ; token :: transfer_as_swap (ctx . swap_info . key , ctx . token_program_info . clone () , reserves_info . clone () , admin_fee_dest_info . clone () , ctx . swap_authority_info . clone () , ctx . token_swap . nonce , admin_fee ,) ? ; Ok (()) }",
    "description": "An authority/admin/owner account is passed as raw `AccountInfo<'info>` without enforcing `is_signer`. The Solana runtime will NOT check this — any pubkey can be passed, allowing anyone to impersonate the privileged role. Use `Signer<'info>` or add `#[account(signer)]` to enforce the runtime check.",
    "attack_scenario": "Attacker constructs a transaction passing their own pubkey as the `authority` AccountInfo. Since there is no `Signer<'info>` constraint or `require!(authority.is_signer)` guard, the runtime accepts the instruction. The attacker then executes privileged operations (withdraw, set_authority, etc.) as if they were the real authority.",
    "real_world_incident": {
      "project": "Wormhole",
      "loss": "$320M",
      "date": "2022-02-02"
    },
    "secure_fix": "Replace `pub authority: AccountInfo<'info>` with `pub authority: Signer<'info>`, or add `#[account(signer)]`. For Anchor programs, also add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the account being protected.",
    "prevention": "Never use raw AccountInfo for accounts that must be signers. Always use Signer<'info> for authority/admin/owner accounts in Anchor.",
    "confidence": 81
  },
  {
    "category": "Authentication",
    "vuln_type": "Missing Signer Check",
    "severity": 5,
    "severity_label": "CRITICAL",
    "id": "SOL-001",
    "cwe": "CWE-287",
    "location": "token.rs",
    "function_name": "burn",
    "line_number": 8,
    "vulnerable_code": "#[doc = \" Issue a spl_token `Burn` instruction.\"] pub fn burn < 'a > (token_program : AccountInfo<'a > , burn_account : AccountInfo<'a > , mint : AccountInfo<'a > , user_authority : AccountInfo<'a > , amount : u64 ,) -> Result<() , ProgramError > { let ix = spl_token :: instruction :: burn (token_program . key , burn_account . key , mint . key , user_authority . key , & [] , amount ,) ? ; solana_program :: program :: invoke (& ix , & [token_program , burn_account , mint , user_authority]) }",
    "description": "An authority/admin/owner account is passed as raw `AccountInfo<'info>` without enforcing `is_signer`. The Solana runtime will NOT check this — any pubkey can be passed, allowing anyone to impersonate the privileged role. Use `Signer<'info>` or add `#[account(signer)]` to enforce the runtime check.",
    "attack_scenario": "Attacker constructs a transaction passing their own pubkey as the `authority` AccountInfo. Since there is no `Signer<'info>` constraint or `require!(authority.is_signer)` guard, the runtime accepts the instruction. The attacker then executes privileged operations (withdraw, set_authority, etc.) as if they were the real authority.",
    "real_world_incident": {
      "project": "Wormhole",
      "loss": "$320M",
      "date": "2022-02-02"
    },
    "secure_fix": "Replace `pub authority: AccountInfo<'info>` with `pub authority: Signer<'info>`, or add `#[account(signer)]`. For Anchor programs, also add `#[account(has_one = authority @ ErrorCode::Unauthorized)]` on the account being protected.",
    "prevention": "Never use raw AccountInfo for accounts that must be signers. Always use Signer<'info> for authority/admin/owner accounts in Anchor.",
    "confidence": 81
  },
  {
    "category": "Authorization",
    "vuln_type": "CPI Call Without Any Authorization",
    "severity": 5,
    "severity_label": "CRITICAL",
    "id": "SOL-CFG-02",
    "cwe": "CWE-862",
    "location": "token.rs",
    "function_name": "burn",
    "line_number": 23,
    "vulnerable_code": "solana_program::program::invoke(&ix, &[token_program, burn_account, mint, user_authority])",
    "description": "CFG analysis found ZERO authorization check blocks in `burn`. The CPI Call at line 23 is completely unguarded.",
    "attack_scenario": "Anyone can call this function and execute the token transfer / CPI without authorization.",
    "real_world_incident": null,
    "secure_fix": "Add `require!(ctx.accounts.authority.is_signer)` or Anchor `#[account(signer)]` constraint before the operation.",
    "prevention": "Always verify authorization before sensitive operations.",
    "confidence": 71
  },
  {
    "category": "Token Security",
    "vuln_type": "Unvalidated Freeze Authority",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-068",
    "cwe": "CWE-732",
    "location": "admin.rs",
    "function_name": "set_fee_account",
    "line_number": 179,
    "vulnerable_code": "#[doc = \" Set fee account\"] fn set_fee_account < 'a , 'b : 'a , I : Iterator < Item = & 'a AccountInfo<'b > > > (token_swap : & mut SwapInfo , account_info_iter : & mut I ,) -> ProgramResult { let new_fee_account_info = next_account_info (account_info_iter) ? ; let new_admin_fee_account = utils :: unpack_token_account (& new_fee_account_info . data . borrow_mut ()) ? ; msg ! (\"Admin: New fee account owner {}\" , new_admin_fee_account . owner) ; if new_admin_fee_account . mint == token_swap . token_a . mint { msg ! (\"Admin: Old fee account A {}\" , token_swap . token_a . admin_fees) ; token_swap . token_a . admin_fees = * new_fee_account_info . key ; msg ! (\"Admin: Fee account A set to {}\" , token_swap . token_a . admin_fees) ; } else if new_admin_fee_account . mint == token_swap . token_b . mint { msg ! (\"Admin: Old fee account B {}\" , token_swap . token_b . admin_fees) ; token_swap . token_b . admin_fees = * new_fee_account_info . key ; msg ! (\"Admin: Fee account B set to {}\" , token_swap . token_b . admin_fees) ; } else { return Err (SwapError :: InvalidAdmin . into ()) ; } Ok (()) }",
    "description": "DeFi protocol accepts token deposits without checking if the mint has a freeze authority. A freeze authority can freeze the protocol's token accounts, permanently locking user funds.",
    "attack_scenario": "Users deposit USDC into a lending pool. The token mint's freeze authority freezes the pool's token account. All deposits are permanently locked — users can never withdraw.",
    "real_world_incident": null,
    "secure_fix": "Check freeze authority: `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` or document the risk and implement contingency plans.",
    "prevention": "Audit accepted token mints for freeze authority. Warn users or reject tokens with active freeze authorities.",
    "confidence": 56
  },
  {
    "category": "Sysvar Security",
    "vuln_type": "Sysvar Address Issues",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-010",
    "cwe": "CWE-20",
    "location": "admin.rs",
    "function_name": "commit_new_admin",
    "line_number": 231,
    "vulnerable_code": "#[doc = \" Commit new admin (initiate admin transfer)\"] fn commit_new_admin < 'a , 'b : 'a , I : Iterator < Item = & 'a AccountInfo<'b > > > (token_swap : & mut SwapInfo , account_info_iter : & mut I ,) -> ProgramResult { let new_admin_info = next_account_info (account_info_iter) ? ; let clock = Clock :: get () ? ; if clock . unix_timestamp < token_swap . future_admin_deadline { return Err (SwapError :: ActiveTransfer . into ()) ; } token_swap . future_admin_key = * new_admin_info . key ; token_swap . future_admin_deadline = clock . unix_timestamp . checked_add (ADMIN_TRANSFER_DELAY) . ok_or (SwapError :: CalculationFailure) ? ; msg ! (\"Admin: Starting admin transfer to {}, deadline at {}\" , token_swap . future_admin_key , token_swap . future_admin_deadline) ; Ok (()) }",
    "description": "Sysvar (Clock/Rent/SlotHashes) is accessed via raw `AccountInfo` without validating the account address is the real sysvar. An attacker can pass a fake account with fabricated data (e.g., a manipulated timestamp or artificial rent value). Use Anchor's `Sysvar<'info, Clock>` which validates the address automatically, or manually check against `sysvar::clock::id()`.",
    "attack_scenario": "Attacker creates a fake account with arbitrary data and passes it as the Clock sysvar. The program reads a manipulated `unix_timestamp`, allowing the attacker to bypass time-locked operations (vesting schedules, staking cooldowns, auction deadlines).",
    "real_world_incident": null,
    "secure_fix": "Use `pub clock: Sysvar<'info, Clock>` in your Accounts struct, or validate: `require!(clock_info.key() == sysvar::clock::id())`",
    "prevention": "Always use Anchor's typed `Sysvar<'info, T>` wrapper which validates the sysvar address during account deserialization.",
    "confidence": 56
  },
  {
    "category": "Token Security",
    "vuln_type": "Unvalidated Freeze Authority",
    "severity": 3,
    "severity_label": "MEDIUM",
    "id": "SOL-068",
    "cwe": "CWE-732",
    "location": "token.rs",
    "function_name": "mint_to",
    "line_number": 27,
    "vulnerable_code": "#[doc = \" Issue a spl_token `MintTo` instruction.\"] pub fn mint_to < 'a > (swap : & Pubkey , token_program : AccountInfo<'a > , mint : AccountInfo<'a > , destination : AccountInfo<'a > , authority : AccountInfo<'a > , nonce : u8 , amount : u64 ,) -> Result<() , ProgramError > { let swap_bytes = swap . to_bytes () ; let authority_signature_seeds = [& swap_bytes [.. 32] , & [nonce]] ; let signers = & [& authority_signature_seeds [..]] ; let ix = spl_token :: instruction :: mint_to (token_program . key , mint . key , destination . key , authority . key , & [] , amount ,) ? ; invoke_signed (& ix , & [mint , destination , authority , token_program] , signers) }",
    "description": "DeFi protocol accepts token deposits without checking if the mint has a freeze authority. A freeze authority can freeze the protocol's token accounts, permanently locking user funds.",
    "attack_scenario": "Users deposit USDC into a lending pool. The token mint's freeze authority freezes the pool's token account. All deposits are permanently locked — users can never withdraw.",
    "real_world_incident": null,
    "secure_fix": "Check freeze authority: `require!(mint.freeze_authority.is_none(), ErrorCode::FreezeRisk)` or document the risk and implement contingency plans.",
    "prevention": "Audit accepted token mints for freeze authority. Warn users or reject tokens with active freeze authorities.",
    "confidence": 56
  }
]
